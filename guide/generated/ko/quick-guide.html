<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: 개발자 속성 가이드</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link type="text/css" rel="stylesheet" href="../../../assets/css/galmuri.css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('quick-guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">개발자 속성 가이드 </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md7">언어 디자인 철학</a><ul><li class="level2"><a href="#autotoc_md8">주석</a></li>
<li class="level2"><a href="#autotoc_md9">기본 타입 제공</a></li>
<li class="level2"><a href="#autotoc_md10">프로퍼티 정의</a></li>
<li class="level2"><a href="#autotoc_md11">StringTemplate</a></li>
<li class="level2"><a href="#autotoc_md12">Map</a></li>
<li class="level2"><a href="#autotoc_md13">배열</a></li>
<li class="level2"><a href="#autotoc_md14">시퀸스</a></li>
<li class="level2"><a href="#autotoc_md15">if</a></li>
<li class="level2"><a href="#autotoc_md16">Block문</a></li>
<li class="level2"><a href="#autotoc_md17">while</a></li>
<li class="level2"><a href="#autotoc_md18">for</a></li>
<li class="level2"><a href="#autotoc_md19">Explicit 캐스팅</a></li>
<li class="level2"><a href="#autotoc_md20">Implicit 캐스팅</a></li>
<li class="level2"><a href="#autotoc_md21">연산자들</a></li>
<li class="level2"><a href="#autotoc_md22">함수</a></li>
<li class="level2"><a href="#autotoc_md23">ret</a></li>
<li class="level2"><a href="#autotoc_md24">객체 정의</a><ul><li class="level3"><a href="#autotoc_md25">새로운 객체 만들기</a></li>
<li class="level3"><a href="#autotoc_md26">객체 복제하기</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md27">생성자</a></li>
<li class="level2"><a href="#autotoc_md28">Pack</a></li>
<li class="level2"><a href="#autotoc_md29">scope</a></li>
<li class="level2"><a href="#autotoc_md30">오버로딩</a></li>
<li class="level2"><a href="#autotoc_md31">평가전략</a></li>
<li class="level2"><a href="#autotoc_md32">중첩 객체</a></li>
<li class="level2"><a href="#autotoc_md33">중첩 함수</a></li>
<li class="level2"><a href="#autotoc_md34">클로저</a></li>
<li class="level2"><a href="#autotoc_md35">is</a></li>
<li class="level2"><a href="#autotoc_md36">in</a></li>
<li class="level2"><a href="#autotoc_md37">Pattern Matching</a></li>
<li class="level2"><a href="#autotoc_md38">단축된 할당 문법</a></li>
<li class="level2"><a href="#autotoc_md39">변수명을 타입명과 동일하게 하려면 &lsquo;&rsquo;`으로 편하게 합니다.</a></li>
<li class="level2"><a href="#autotoc_md40">클래스라는 건 없습니다</a></li>
<li class="level2"><a href="#autotoc_md41">스타일로 Attribute 정의</a></li>
<li class="level2"><a href="#autotoc_md42">타입 추론</a></li>
<li class="level2"><a href="#autotoc_md43">프로퍼티</a></li>
<li class="level2"><a href="#autotoc_md44">우리는 typedef가 필요 없습니다.</a></li>
<li class="level2"><a href="#autotoc_md45">it</a></li>
<li class="level2"><a href="#autotoc_md46">기본 타입도 객체</a></li>
<li class="level2"><a href="#autotoc_md47">표현식 기반 언어</a></li>
<li class="level2"><a href="#autotoc_md48">with</a></li>
<li class="level2"><a href="#autotoc_md49">타입 확장으로 활용</a></li>
<li class="level2"><a href="#autotoc_md50">오버라이딩</a></li>
<li class="level2"><a href="#autotoc_md51">&lt;tt&gt;A::B&lt;/tt&gt; 함수 호출</a></li>
<li class="level2"><a href="#autotoc_md52">다중 확장</a></li>
<li class="level2"><a href="#autotoc_md53">static으로 활용</a></li>
<li class="level2"><a href="#autotoc_md54">delegation으로 활용</a></li>
<li class="level2"><a href="#autotoc_md55">import</a></li>
<li class="level2"><a href="#autotoc_md56">err</a></li>
<li class="level2"><a href="#autotoc_md57">errorable type</a></li>
<li class="level2"><a href="#autotoc_md58">safe-navigation</a></li>
<li class="level2"><a href="#autotoc_md59">exception이란?</a></li>
<li class="level2"><a href="#autotoc_md60">abstract</a></li>
<li class="level2"><a href="#autotoc_md61">함수타입 대신 메소드을 사용</a></li>
<li class="level2"><a href="#autotoc_md62">제네릭</a></li>
<li class="level2"><a href="#autotoc_md63">enumeration</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md64">끝맺으면서</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md__home_runner_work_byeol_byeol_doc_guide_ko_quick_guide"></a></p>
<ul>
<li>Byeol 언어는 현재 일종의 <b>베타테스트</b> 기간입니다.</li>
<li>언제든지 spec의 <b>내용이 변경</b> 될 수 있습니다.</li>
<li>각 항목 앞에 ✅ 가 되어있는 항목은 구현이 완료된 겁니다.</li>
<li>이 문서는 다른 프로그래밍 언어를 다뤄본적이 있는 익숙한 <b>개발자</b> 를 대상으로 작성되었습니다.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
언어 디자인 철학</h1>
<ul>
<li>빠르게 기능만 익히고 싶은 분은 넘어가셔도 됩니다.</li>
<li>관심이 있으신 분은 한번 꼭 <a class="el" href="design-philosophy.html">읽어보세요</a>. 이 언어가 왜 이렇게 설계되었는지 이해하는데 큰 도움이 되실겁니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
주석</h2>
<ul>
<li>✅ 주석은 <code>#</code> 으로 표현합니다.</li>
</ul>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;classList&quot;: &quot;verified&quot;,</div>
<div class="line">    &quot;shown&quot;:</div>
<div class="line">`</div>
<div class="line"># 한줄짜리 주석이고,</div>
<div class="line"> </div>
<div class="line">## 여러줄</div>
<div class="line">주석입니다.##</div>
<div class="line">`,  &quot;code&quot;:</div>
<div class="line">`</div>
<div class="line">main() void</div>
<div class="line">    # 한줄짜리 주석이고,</div>
<div class="line"> </div>
<div class="line">    ## 여러줄</div>
<div class="line">    주석입니다.##</div>
<div class="line">    ret</div>
<div class="line">`</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
기본 타입 제공</h2>
<ul>
<li>✅ 다음의 기본타입(primitive types)이 있습니다.</li>
</ul>
<div class="fragment"><div class="line">&quot;문자열&quot; # str: 쌍따옴표로 표현합니다.</div>
<div class="line">3020202302 # int: 4byte 정수입니다.</div>
<div class="line">true # bool</div>
<div class="line">3.5 # flt: 4byte float.</div>
<div class="line">0xff # 255를 뜻하는 16진법 int</div>
<div class="line">017 # 15를 뜻하는 8진법 int</div>
<div class="line">&quot;a&quot; # character type 은 존재하지 않습니다.</div>
<div class="line">&quot;\0x2B&quot; # ascii 2B(10진수 43)에 해당하는 &#39;+&#39;</div>
<div class="line">&quot;\43&quot; # ascii &#39;+&#39;. 위와 같은 코드입니다.</div>
<div class="line"># byte도 있어요. 0 ~ 255까지 표현 가능하죠.</div>
<div class="line"># void 도 있습니다만, 물론 void 타입의 변수를 만들</div>
<div class="line"># 수는 없죠.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
프로퍼티 정의</h2>
<ul>
<li>✅ 무언가 값을 저장할 수 있는 변수를 byeol언어에서는 프로퍼티라고 합니다.</li>
<li>✅ byeol언어에서 타입을 명시적으로 표현할때는 <code>식별자 &lt;space&gt; 타입명</code>으로, 항상 띄어쓰기 후 타입을 식별자 뒤에 표현합니다.</li>
<li>✅ 따라서 프로퍼티를 정의할때도 위의 타입 규칙을 따릅니다. 즉, 타입은 항상 뒤에오죠.</li>
</ul>
<div class="fragment"><div class="line">age int # 뒤의 int가 타입이죠.</div>
<div class="line">age = 22 # 누군지 몰라도, 부럽네요.</div>
</div><!-- fragment --><ul>
<li>✅ 변수를 정의하면서 초기화도 같이 할 수 있는데, 그럴때는 <code>:=</code> 기호를 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">everything int := 42 # int 타입이며, 그 값은 42 입니다.</div>
<div class="line">everything2 := everything # everything2는 everything과 같은 int 타입이며, 값도 같습니다.</div>
</div><!-- fragment --><ul>
<li>✅ 식별자는 영문자나 <code>_</code> 혹은 숫자로 정의합니다만, 첫글자는 오직 영문자만 가능합니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
StringTemplate</h2>
<ul>
<li>✅ StringTemplate도 지원합니다.</li>
</ul>
<div class="fragment"><div class="line">ch := &quot;+&quot;</div>
<div class="line">print(&quot;ch=$ch&quot;) # &quot;ch=+&quot;</div>
<div class="line">print(&quot;ch=&quot; + ch) # &quot;ch=+&quot;</div>
</div><!-- fragment --><ul>
<li>✅ 기호가 포함될 경우에는 <code>{}</code> 로 감싸세요.</li>
</ul>
<div class="fragment"><div class="line">print(&quot;${a + b}&quot;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Map</h2>
<ul>
<li>☐ byeol언어는 배열, map, sequence를 기본 제공합니다.</li>
<li>☐ Map 객체는 대괄호를 사용해서 정의합니다.</li>
</ul>
<div class="fragment"><div class="line"># &lt;타입&gt;[&lt;타입&gt;] 으로 Map 타입을 표현합니다.</div>
<div class="line">map int[str] # str이 key, int가 value인 map 입니다.</div>
</div><!-- fragment --><ul>
<li>✅ 아쉽게도 Map에 대해, Literal 상수를 표현할 수는 없습니다.</li>
<li>☐ 존재하지 않는 원소에 대괄호를 사용해 접근하면, 자동으로 기본값이 할당됩니다.</li>
<li>✅ 모든 Container는 객체이므로, 여러 메소드를 가집니다.</li>
</ul>
<div class="fragment"><div class="line">map int[str] # str이 key, int가 value인 map을 만듭니다.</div>
<div class="line">map[&quot;apple&quot;] = 300</div>
<div class="line">map[&quot;banana&quot;] = 700</div>
<div class="line">print(map[&quot;apple&quot;]) # &quot;300&quot;입니다. 사과 참 싸네요.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
배열</h2>
<ul>
<li>✅ 배열타입은 어떻게 표현할까요? 배열은 Key가 항상 int인 Map처럼 표현합니다. 실제로 둘은 매우 유사한 부분이 많습니다.</li>
</ul>
<div class="fragment"><div class="line">myArray int[] # int 배열입니다.</div>
<div class="line">myArray2 := int[]() # 배열은 객체이므로, 생성자도 있죠.</div>
</div><!-- fragment --><ul>
<li>✅ 중괄호로 Literal 상수를 표현합니다.</li>
</ul>
<div class="fragment"><div class="line">myArray3 := {2, 3, 4} # 원소 2, 3, 4를 보고 int배열이라는 걸 유추합니다.</div>
</div><!-- fragment --><ul>
<li>✅ 모든 container는 유동적인 size를 갖습니다.</li>
<li>✅ 전통을 따라, Index는 0부터 시작합니다.</li>
<li>✅ 대괄호로 원소에 접근합니다.</li>
</ul>
<div class="fragment"><div class="line">myArray.add(5)</div>
<div class="line">++myArray[0] == 6 # true</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
시퀸스</h2>
<ul>
<li>✅ <code>..</code> 으로 표현합니다. 정수의 범위를 표현합니다.</li>
<li>✅ container의 일종이므로, 객체입니다.</li>
<li>✅ 끝은 포함되지 않아요(exclusive). 예를들어 1..3 이라고 하면 {1, 2} 2개의 값까지만 의미합니다.</li>
</ul>
<div class="fragment"><div class="line">&quot;message&quot;[1..3] # &quot;es&quot;</div>
<div class="line">for n in 2..5</div>
<div class="line">    print(n) # 234 출력</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
if</h2>
<ul>
<li>✅ if, else를 제공합니다.</li>
<li>✅ byeol언어는 소괄호를 싫어합니다. 조건절에 소괄호를 넣지 않습니다.</li>
</ul>
<div class="fragment"><div class="line">if a == 5</div>
<div class="line">    foo(1)</div>
<div class="line">else if a == 7</div>
<div class="line">    foo(2)</div>
<div class="line">else</div>
<div class="line">    foo(4)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Block문</h2>
<ul>
<li>✅ offside-rule로 블록문을 표현합니다. 들여쓰기를 해야한단 얘기예요.</li>
<li>✅ 블록문은 2 종류로 분류됩니다.<ul>
<li>1) 구문과 정의문을 모두 쓸 수 있는 <code>일반블록문</code></li>
<li>2) 정의문만 쓸 수 있는 <code>정의블록문</code></li>
</ul>
</li>
<li>✅ 모든 Block문은 Scope를 표현합니다. Scope에 대해서는 나중에 더 얘기해보죠.</li>
<li>✅ <code>:</code> 는 블록문을 붙여서 쓸 수 있어요.</li>
<li>✅ <code>;</code> 는 이전 줄과 같은 블록문에 있는 구문을 한줄에 붙여 쓰겠다는 의미입니다.</li>
</ul>
<div class="fragment"><div class="line">if val == 0 # 2번: 위의 1번과 같은 코드입니다.</div>
<div class="line">    print(&quot;1&quot;)</div>
<div class="line">    print(&quot;2&quot;)</div>
<div class="line"># 위 코드를 한줄에 쓸 수도 있습니다:</div>
<div class="line">if val == 0: print(&quot;1&quot;); print(&quot;2&quot;)</div>
</div><!-- fragment --><ul>
<li>✅ <code>:</code>를 응용하면 이렇게도 쓸 수 있어요.</li>
</ul>
<div class="fragment"><div class="line"># 아래 if는 `:`를 2번합니다.</div>
<div class="line">if val == 0: if val &gt; 0: print(&quot;ok&quot;)</div>
<div class="line">    else: print(&quot;no&quot;) # 이 else는 indent를 1번 했죠? 그래서 두번째 if에 대한 else 입니다.</div>
<div class="line"> </div>
<div class="line">## 풀어쓰면 이런 코드가 됩니다.</div>
<div class="line">if val == 0</div>
<div class="line">    if val &gt; 0</div>
<div class="line">        print(&quot;ok&quot;)</div>
<div class="line">    else</div>
<div class="line">        print(&quot;no&quot;)</div>
<div class="line"> </div>
<div class="line">##</div>
</div><!-- fragment --><ul>
<li>✅ byeol언어는 비어있는 블록문을 가능하면 피하고 싶습니다.</li>
<li>꼭 명시해야하는 상황이라면 <code>: ;</code> 로 표현합니다.</li>
</ul>
<div class="fragment"><div class="line">if val == 0: ;</div>
<div class="line">else: val = 1</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
while</h2>
<ul>
<li>✅ 조건식이 참(true) 일 동안 블록문을 반복 실행합니다.</li>
</ul>
<div class="fragment"><div class="line"># while &lt;조건절&gt;</div>
<div class="line">#  &lt;블록문&gt;</div>
<div class="line">cnt := 0</div>
<div class="line">while cnt++ &lt; 5</div>
<div class="line">    print(&quot;forever?&quot;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
for</h2>
<ul>
<li>✅ <code>for</code>는 container를 순회합니다.</li>
<li>✅ <code>break</code>는 가장 최근의 <code>while</code> 혹은 <code>for</code>을 벗어납니다.</li>
<li>✅ <code>next</code>는 다음 원소로 넘어갑니다.</li>
</ul>
<div class="fragment"><div class="line"># for &lt;변수명&gt; in &lt;컨테이너&gt;</div>
<div class="line">#    &lt;블록문&gt;</div>
<div class="line">arr := {1, 2, 3}</div>
<div class="line">for n in arr</div>
<div class="line">    print(n)</div>
<div class="line">    if n == 2</div>
<div class="line">        break # 루프를 빠져나갑니다.</div>
<div class="line">    if n == 1</div>
<div class="line">        next # 다음 원소를 가지고 루프의 처음부터 다시 실행합니다.</div>
<div class="line"># 결과: &quot;12&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Explicit 캐스팅</h2>
<ul>
<li>✅ <code>as</code> 를 사용해서 다른 타입으로 변경할 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">val1 := 0 # int</div>
<div class="line">val2 := var1 as flt # val2는 flt이고 0.0 값을 갖죠.</div>
<div class="line">0 as str # &quot;0&quot;.</div>
<div class="line">&quot;123&quot; as int # 123, 문자를 숫자로 바꿀 수 있습니다.</div>
</div><!-- fragment --><ul>
<li>✅ 물론 각 객체가 <code>as</code>를 했을때 주어진 타입으로 변경하는 코드를 가지고 있어야 합니다. <code>primitive types</code>는 대부분 서로 변환이 가능합니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
Implicit 캐스팅</h2>
<ul>
<li>✅ 함수호출시 자동으로 동작하는 캐스팅입니다.</li>
<li>✅ 기본 타입끼리는 다음처럼 변환됩니다.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">타입   </th><th class="markdownTableHeadNone">변환 가능한 타입    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">byte   </td><td class="markdownTableBodyNone">bool, int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">int   </td><td class="markdownTableBodyNone">flt, byte, bool    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">flt   </td><td class="markdownTableBodyNone">int, byte, bool    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">flt, byte, int    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">str   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void   </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<ul>
<li>✅ 위의 표를 Explicit 캐스팅과 착각하시면 곤란합니다. 대부분의 모든 primitive types는 <code>as</code>를 사용하면 서로 변환합니다.</li>
<li>✅ 사용자가 만든 타입일 경우, <code>upcasting</code>만 지원합니다. 사용자가 Implicit 캐스팅에 뭔가 관여를 할 수는 없습니다.</li>
<li>✅ 2단계를 거쳐서 Implicit 캐스팅의 Implicit 캐스팅이 일어나진 않습니다.</li>
</ul>
<div class="fragment"><div class="line">foo(a flt)</div>
<div class="line">    print(a)</div>
<div class="line">val1 := 27 as byte</div>
<div class="line">val2 := foo(val1) # &lt;-- 에러.</div>
<div class="line"># byte --&gt; flt으로 Implicit 캐스팅이 불가능합니다.</div>
<div class="line"># byte --&gt; int --&gt; flt 이렇게 암시적 캐스팅이 2번 일어나면 에러가 아니었겠죠. 그러나 암시적 캐스팅은 1번만 일어납니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
연산자들</h2>
<ul>
<li>✅ 단형연산자 당연히 지원하고요.</li>
</ul>
<div class="fragment"><div class="line">var := 3</div>
<div class="line">++var # 4, 전위 연산자도 됩니다.</div>
<div class="line">var-- # 4, 후위도 됩니다.</div>
<div class="line">-var # -3</div>
</div><!-- fragment --><ul>
<li>✅ 2항도 지원합니다.</li>
</ul>
<div class="fragment"><div class="line">var1 := 1</div>
<div class="line">var2 := 3</div>
<div class="line">var1 + var2 # 4</div>
<div class="line">var1 - var2 # -2</div>
<div class="line">var1 * var2 # 3</div>
<div class="line">var2 / var1 # 3</div>
<div class="line">var2 % 2 # 1</div>
<div class="line">var1 &gt; var2 # false</div>
<div class="line">var1 &lt;= var2 # true</div>
<div class="line">var2 == (3 - 2) # false, 소괄호를 쓰면 계산 우선순위가 높아져요.</div>
</div><!-- fragment --><ul>
<li>☐ <code>==</code> 는 value equality를, <code>===</code> 를 reference equality를 검사합니다.</li>
</ul>
<div class="fragment"><div class="line">val1 := 1</div>
<div class="line">val2 := 1</div>
<div class="line">val1 == val2 # true</div>
<div class="line">val1 === val2 # false</div>
</div><!-- fragment --><ul>
<li>✅ 비트연산 지원합니다.</li>
</ul>
<div class="fragment"><div class="line">var1 := 3 # 3:  0011</div>
<div class="line">var1 &gt;&gt; 1 # 1:  0001</div>
<div class="line">var1 &lt;&lt; 2 # 12: 1100</div>
<div class="line">var1 | 4 # 7: 0111</div>
<div class="line">var1 &amp; 2 # 2: 0010</div>
<div class="line">60 ^ 13 # 49: 111100 ^ 001101 = 110001</div>
</div><!-- fragment --><ul>
<li>✅ 할당연산자도 지원합니다.</li>
</ul>
<div class="fragment"><div class="line">var1 := 0</div>
<div class="line">var1 = 2 # 2</div>
<div class="line">var1 += 1 # 3</div>
<div class="line">var1 *= 2 # 6</div>
<div class="line">var1 %= 4 # 2</div>
<div class="line">var1 &amp;= 2 # var1 = var1 &amp; 2 --&gt; 2</div>
</div><!-- fragment --><ul>
<li>✅ 연산자 우선순위는 이렇습니다. 높을 수록 우선됩니다.</li>
<li>✅ 도중에 <code>is</code>, <code>in</code> 과 같이 아직 설명하지 않은 것들이 보일겁니다. 나중에 알려드릴테니 일단 무시하세요.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">순위   </th><th class="markdownTableHeadNone">연산자   </th><th class="markdownTableHeadNone">예시    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">(expr)   </td><td class="markdownTableBodyNone">(a || b)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">&ndash;, ++, ., []   </td><td class="markdownTableBodyNone">a&ndash;, a++, a.b, a[b]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">&ndash;, ++, -, !, ~   </td><td class="markdownTableBodyNone">&ndash;a, ++a, -a, !a, ~a    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">as, ..   </td><td class="markdownTableBodyNone">a as b, a..b    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">*, /, %   </td><td class="markdownTableBodyNone">a * b, a / b, a % b    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">+, -   </td><td class="markdownTableBodyNone">a + b, a - b    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone" rowspan="2">&amp;   </td><td class="markdownTableBodyNone">a &amp; b    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">a ^ b    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">|, is, in   </td><td class="markdownTableBodyNone">a | b, a is b, a in b    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">&gt;, &lt;, &gt;=,   </td><td class="markdownTableBodyNone">a &gt; b, a &lt; b, a &gt;= b    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">&lt;=, ==, !=   </td><td class="markdownTableBodyNone">a &lt;= b, a == b, a != b    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">&lt;&lt;, &gt;&gt;   </td><td class="markdownTableBodyNone">a &lt;&lt; b, a &gt;&gt; b    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">||, &amp;&amp;   </td><td class="markdownTableBodyNone">a || b, a &amp;&amp; b   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md22"></a>
함수</h2>
<ul>
<li>✅ parameter 목록과 반환형, Block문이 정의된 것을 함수라고 합니다.</li>
<li>✅ 프로퍼티때와 마찬가지로, 함수의 반환형 역시 뒤에 옵니다.</li>
</ul>
<div class="fragment"><div class="line"># foo() 함수는 int, flt, nbool를 인자로 받고 아무것도</div>
<div class="line"># 반환하지 않는(void) 함수입니다.</div>
<div class="line">foo(a int, b flt, c nbool) void</div>
<div class="line">    print(a + b + c) # print문은 기본 제공되는 함수로 화면에 값을 출력합니다.</div>
</div><!-- fragment --><ul>
<li>✅ 위에서 제가 언급한 함수 정의에 함수명이 없다는 점을 눈치채셨나요?</li>
<li>✅ 함수명을 적지 않으면 람다함수가 됩니다. 단, 람다함수는 반드시 함수 호출 안에서 적어야 합니다.</li>
<li>☐ 람다함수는 parameter타입과 반환형을 생략할 수 있죠.</li>
</ul>
<div class="fragment"><div class="line">if true</div>
<div class="line">    runLambda(val1, (a, b)</div>
<div class="line">        a + b</div>
<div class="line">    , 33) # indent를 한번 한 후, comma를 적었다는 걸 주의하십쇼.</div>
<div class="line">          # comma의 위치가 상당히 중요합니다.</div>
</div><!-- fragment --><ul>
<li>☐ 앞에 정의한 람다를 다음처럼 한줄에 적을 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">runLambda(val1, (a, b): a + b, 33)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
ret</h2>
<ul>
<li><code>ret</code> 는 값을 반환하고 함수를 종료합니다.</li>
<li>☐ <code>...</code> 로 가변 인자를 표현할 수 있는데, 가변인자는 인자목록 끝에 정의해야 합니다.</li>
</ul>
<div class="fragment"><div class="line">sum(args int...) int</div>
<div class="line">    sum := 0</div>
<div class="line">    for a in args # args 는 int[] 과 같은 겁니다.</div>
<div class="line">        sum += a</div>
<div class="line">    ret sum</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
객체 정의</h2>
<ul>
<li>✅ byeol언어는 OOP언어입니다.</li>
<li>✅ 객체를 만드는 방법은 2가지가 있습니다.<ul>
<li>✅ 1) 하나는 새로운 객체를 만드는 것이고</li>
<li>✅ 2) 다른 하나는 이미 만든 객체를 복제 하는 거예요.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
새로운 객체 만들기</h3>
<ul>
<li>✅ 다음 처럼 하면 됩니다.</li>
</ul>
<div class="fragment"><div class="line"># def &lt;객체이름&gt;</div>
<div class="line">#    &lt;정의블록문&gt;</div>
<div class="line">def person</div>
<div class="line">    age := 0 # 정의블록문에는 프로퍼티나 함수 등 정의하는 구문만 올 수 있습니다.</div>
<div class="line">    hello() void # 객체에 함수도 정의할 수 있죠.</div>
<div class="line">        print(&quot;I&#39;m foo and $age years old!\n&quot;)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
객체 복제하기</h3>
<ul>
<li>✅ 객체를 만드는 또다른 방법은 이미 만들어진 객체를 복제하는 건데요.</li>
<li>✅ 함수에 대고 호출하면 함수호출이 되듯, 객체에 대고 호출하면 객체 복제가 됩니다.</li>
<li>✅ 함수 안에서 이 함수를 소유한 객체를 <code>me</code> 로 접근합니다.</li>
<li>✅ <code>me</code> 는 생략이 가능합니다. 자세한 내용은 <code>scope</code>에서 다룹니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    age := 0</div>
<div class="line">    say() void: print(&quot;I&#39;m ${me.age} yo.\n&quot;)</div>
<div class="line">    # 위에서의 me를 사실은 생략할 수 있단 얘기죠.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p1 := Person() # (A)</div>
<div class="line">    p1.age = 1</div>
<div class="line">    p2 Person # (A)와 같은 코드입니다.</div>
<div class="line"> </div>
<div class="line">    for p in {p1, p2, Person()} # `Person()` 처럼 이름없는 객체를 만들 수도 있습니다.</div>
<div class="line">        p.say()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
생성자</h2>
<ul>
<li>✅ 생성자는 <code>ctor</code> 이라고 하는 고유 함수명을 사용합니다.</li>
<li>✅ 생성자를 정의할 때 반환형은 생략합니다.</li>
</ul>
<div class="fragment"><div class="line">def Food</div>
<div class="line">    name str</div>
<div class="line">    price int</div>
<div class="line">    ctor(name str, price int)</div>
<div class="line">        me.name = name</div>
<div class="line">        me.price = price</div>
<div class="line">pizza := Food(&quot;pizza&quot;, 15000)</div>
</div><!-- fragment --><ul>
<li>☐ 생성자 안에서만 <code>ctor</code>로 생성자를 호출할 수 있습니다.</li>
<li>✅ 내부적으로 생성자는 객체 생성되고 나서 자동으로 호출됩니다.</li>
<li>✅ 즉, 생성자 안에서 <code>ctor</code>로 또 호출한다고 해서 객체가 또 생기는 건 아니란 얘기입니다.</li>
</ul>
<div class="fragment"><div class="line">def Food</div>
<div class="line">    name str</div>
<div class="line">    price int</div>
<div class="line">    ctor()</div>
<div class="line">        print(&quot;call constructor!\n&quot;)</div>
<div class="line">        ctor(&quot;defaultName&quot;, 100)</div>
<div class="line">    ctor(name str, price int)</div>
<div class="line">        me.name = name</div>
<div class="line">        me.price = price</div>
<div class="line"> </div>
<div class="line">print(Food().name) # &quot;defaultName&quot;</div>
</div><!-- fragment --><ul>
<li>✅ 생성자를 명시하지 않으면 기본 생성자가 정의됩니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Pack</h2>
<ul>
<li>✅ <code>pack &lt;객체이름&gt;</code>으로 하면 그 <code>pack</code> 객체가 생성됩니다. 그 구문 밑에서 정의한 모든 객체며 함수는 이 <code>pack</code>에 속하게 됩니다.</li>
<li>✅ 따라서 같은 <code>pack</code>을 명시한 소스코드 끼리는 서로 공유가 됩니다.</li>
<li>✅ <code>pack</code>의 본질은 결국 <code>def</code>처럼, 사용자가 정의한 객체에 불과합니다.</li>
</ul>
<div class="fragment"><div class="line"># file &quot;a.nm&quot; --</div>
<div class="line">pack example # 이 파일은 example이라는 객체를 `pack` 으로 삼았습니다.</div>
<div class="line"># 여기서부터는 사실 example이라는 객체의 내부입니다. 즉 `def example` 과 같습니다.</div>
<div class="line"># -------------------------------</div>
<div class="line"># 여기서부터는 `example`의 정의블록문 입니다.</div>
<div class="line"> </div>
<div class="line">foo() int # example은 foo() 함수를 갖습니다.</div>
<div class="line">  print(&quot;this is pack &#39;example&#39;\n&quot;)</div>
<div class="line">  ret 33</div>
<div class="line"> </div>
<div class="line">def person # person 이라는 타입도 갖습니다.</div>
<div class="line">  age := 2</div>
<div class="line">  name := &quot;Chales&quot;</div>
<div class="line">  ctor(newAge int): age = newAge</div>
</div><!-- fragment --><ul>
<li>✅ 이 <code>pack</code>은 시스템이 가져올 수 있는(import) module의 최소 단위입니다. 어떻게 <code>pack</code>을 import 할 수 있는지는 밑에서 얘기할께요.</li>
<li>✅ <code>main()</code> 함수는 특정 pack에 대한 진입점 입니다.</li>
<li>✅ <code>main()</code> 함수는 반환형이 <code>void</code> 혹은 <code>int</code> 여야 합니다.</li>
<li>✅ <code>main()</code> 함수는 parameter가 비어있거나 <code>str[]</code> 여야 합니다.</li>
</ul>
<div class="fragment"><div class="line"># file &quot;b.nm&quot; --</div>
<div class="line">pack example</div>
<div class="line"># example의 scope 입니다. 그러니 파일이 달라도 example의 모든 식별자에 바로 접근 가능합니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    a := foo() # 다른 파일에 있는 foo함수를 호출합니다. 같은 객체(example)의 scope을 공유 하니까요.</div>
<div class="line">    print(person(a).age) # 1</div>
<div class="line">    print(example.person(a).age) # 1과 같은 코드입니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md29"></a>
scope</h2>
<ul>
<li>✅ 어느 객체가 scope로써 등록되면, 해당 객체가 소유한 하위 식별자 (함수, 프로퍼티, 또다른 객체 등)에 바로 접근할 수 있게 됩니다.</li>
<li>✅ 각 scope은 나름의 방법에 의해 시스템에 잠시 등록되었다가 등록이 해제됩니다.</li>
<li>✅ Scope이 메모리에서 사라지면 Scope이 각 식별자에 대한 참조도 잃습니다.</li>
<li>✅ 모든 참조를 잃어버린 객체는 메모리에서 해제됩니다.</li>
<li>✅ byeol언어의 Scope에는 5가지 존재합니다.<ul>
<li>✅ 1) local scope: 매 블록문마다 scope이 생성되고, 블록문이 끝나면 scope은 메모리에서 사라집니다. 함수가 가진 블록문도 여기에 속합니다.</li>
<li>✅ 2) func scope: 블록문을 제외하고 함수가 가진 하위 식별자들을 scope에 등록합니다. 함수 호출이 끝나면 scope은 등록이 해제됩니다.</li>
<li>✅ 3) obj scope: 함수를 가지고 있는 객체의 scope 입니다. 객체가 사라질때 이 scope도 사라집니다.</li>
<li>✅ 4) pack scope: pack이 제공하는 obj scope 입니다. pack에 속한 obj scope은 해당 pack scope와 항상 연결되어 있습니다. pack은 사라지지 않습니다.</li>
<li>✅ 5) file scope: 각 소스코드 파일 내에서만 접근 가능한 scope 입니다. 해당 파일의 코드가 실행될때만 scope이 등록됩니다.</li>
</ul>
</li>
<li>✅ scope의 우선순위는 위의 언급한 숫자가 작을 수록 높습니다. (local scope이 제일 높음)</li>
<li>✅ 보통 file scope에 외부 pack을 import 하기 위한 코드를 작성합니다.</li>
</ul>
<div class="fragment"><div class="line">pack mypack</div>
<div class="line"># 여기서부터는 pack scope:</div>
<div class="line">age := 27 # mypack.a</div>
<div class="line"> </div>
<div class="line">def Person</div>
<div class="line">    # Person에 대한 obj scope:</div>
<div class="line">    name str</div>
<div class="line">    ctor(newName str): name = newName</div>
<div class="line">    hello() void</div>
<div class="line">        # age는 pack scope에서 왔습니다.</div>
<div class="line">        print(&quot;I&#39;m $name and $age yo.\n&quot;)</div>
<div class="line">        # print(&quot;I&#39;m ${me.name} and ${mypack.age} yo.\n&quot;) 처럼 해도 되긴 합니다.</div>
<div class="line"> </div>
<div class="line">foo() str</div>
<div class="line">    # local scope:</div>
<div class="line">    name := &quot;kniz and $age yo&quot;</div>
<div class="line">    ret name</div>
<div class="line">    # 함수가 끝나면 local scope에 의한 name에 대한 참조는 사라지지만, name은 함수 밖으로 반환되므로, 함수에 의한 참조는 남아 있습니다.</div>
<div class="line">    # 그러니 name은 메모리에서 사라지지 않습니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    Person(foo()).hello()</div>
<div class="line"># name에 대한 참조는 이 Person 임시객체가 가졌습니다.</div>
<div class="line"># Person이 소속된 코드가 끝났으므로, Person은 사라집니다.</div>
<div class="line"># Person이 가졌던 name에 대한 참조도 사라지므로, name 또한 사라집니다.</div>
</div><!-- fragment --><ul>
<li>✅ <code>pack</code> 키워드 보다 윗 공간은 file scope 입니다.</li>
<li>✅ 하나의 scope 안에서 같은 식별자를 정의할 수 없습니다.</li>
<li>✅ 위 얘기는 scope이 다르다면 이름이 같아도 된다는 뜻이죠.</li>
</ul>
<div class="fragment"><div class="line"># file &quot;a.nm&quot; --</div>
<div class="line">pack example</div>
<div class="line"># 여기서부터는 pack scope.</div>
<div class="line">age := 4</div>
<div class="line"> </div>
<div class="line">foo() void</div>
<div class="line">  print(age) # &quot;5&quot;</div>
<div class="line"> </div>
<div class="line"># file &quot;b.nm&quot; --</div>
<div class="line"># -----------------------------------------------</div>
<div class="line"># 여기서부터는 file scope:</div>
<div class="line">age := 5</div>
<div class="line"># 이 age는 이 파일에서만 유효합니다.</div>
<div class="line"># example에도 `age` 라는 프로퍼티가 존재하기 때문에, 사실상 pack scope의 age를 덮어쓰는 효과가 발생합니다.</div>
<div class="line"># 인터프리터가 이 점에 대해 경고를 내보낼 겁니다.</div>
<div class="line"> </div>
<div class="line">pack example</div>
<div class="line"># -----------------------------------------------</div>
<div class="line"># 여기서부터는 pack scope:</div>
<div class="line">def Person</div>
<div class="line">  age := 3 # 눈치채셨나요? 사실 이 값들은 위에서 말한 우선순위를 나타내고 있습니다.</div>
<div class="line">  hello() void</div>
<div class="line">    print(age) # &quot;3&quot;</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  if true</div>
<div class="line">    age := 1</div>
<div class="line">    print(age) # &quot;1&quot;</div>
<div class="line">  print(age) # &quot;4&quot;</div>
<div class="line">  Person().hello() # &quot;3&quot; 출력.</div>
</div><!-- fragment --><ul>
<li>☐ obj가 아니라 pack scope 혹은 file scope 에 속한 식별자에 접근할때는 <code>pack</code>을 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">scope := &quot;file&quot;</div>
<div class="line">pack example</div>
<div class="line">scope := &quot;pack&quot;</div>
<div class="line"> </div>
<div class="line">def A</div>
<div class="line">  age := &quot;obj&quot;</div>
<div class="line">  foo() void</div>
<div class="line">    age := &quot;local&quot;</div>
<div class="line">    print(&quot;$age ${me.age} ${pack.age}&quot;)</div>
<div class="line"># 결과:</div>
<div class="line">#  local obj file</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
오버로딩</h2>
<ul>
<li>✅ 오버로딩을 지원합니다.</li>
</ul>
<div class="fragment"><div class="line">add(a str, b str) str</div>
<div class="line">    a + b</div>
<div class="line">add(a int, b int) int</div>
<div class="line">    a + b</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
평가전략</h2>
<ul>
<li>✅ by object 평가전략을 사용합니다.<ul>
<li>1) immutable 속성을 갖는 인자의 경우, 값에 의한 복사가(by val)</li>
<li>2) mutable 속성을 갖는 인자의 경우, 참조에 의한 복사가(by reference) 됩니다.</li>
</ul>
</li>
<li>✅ immutable은 primitive 객체에만 적용되는 것으로, 사용자는 자신이 정의한 객체에 immutable 속성을 줄 수 없습니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    age := 0</div>
<div class="line"> </div>
<div class="line">foo(val1 int ##by val##, val2 person##by ref##) void</div>
<div class="line">    val1 = 22</div>
<div class="line">    val2.age = 22</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    age := 1</div>
<div class="line">    p := person()</div>
<div class="line">    foo(age, p)</div>
<div class="line">    print(&quot;age=$age p.age=${p.age}&quot;) # age=1 p.age=22</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
중첩 객체</h2>
<ul>
<li>✅ 다른 언어에는 중첩 객체라는 기능이 있습니다.</li>
<li>☐ 변수 정의가 일반블록문에 올 수 있다면, 당연히 함수나 객체를 정의하는 것도 올 수 있어야 합니다.</li>
<li>✅ innerClass는 지원하지 않습니다.</li>
<li>✅ 함수 안에서 객체를 정의하더라도 아무것도 capture하지 않습니다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    def house # 중첩 객체</div>
<div class="line">        address str</div>
<div class="line">        ctor(a str): address = a</div>
<div class="line">        introduce(p person) void</div>
<div class="line">            # house는 person과 아무런 관련이 없기 때문에 person에 접근하려면 인자로 받아야 합니다.</div>
<div class="line">            print(&quot;hello! I&#39;m ${p.name}&quot;)</div>
<div class="line"> </div>
<div class="line">    myHome := house(&quot;korea&quot;)</div>
<div class="line">    age := 22</div>
<div class="line">    name := &quot;Sunsin&quot;</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    def mc # 함수안에도 객체를 정의할 수 있습니다. 이 객체는 func scope에 속합니다.</div>
<div class="line">        intro() void</div>
<div class="line">            p person</div>
<div class="line"># 일반 블록문 안에 변수는 정의할 수 있으면서, 클래스/함수를 정의할 수 없다면, 일관성이 없다고 생각되지 않나요?</div>
<div class="line">            p.house.introduce(p)</div>
<div class="line"># Byeol 언어에서는 정의블록문에 사용하는 모든 구문을 일반 블록문에서 사용할 수 있습니다.</div>
<div class="line">    mc().intro()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
중첩 함수</h2>
<ul>
<li>✅ 객체를 정의할 수 있는 곳에는, 함수도 정의할 수 있어야 합니다.</li>
<li>✅ 함수 안에 정의된 함수를 <code>중첩함수</code>라고 합니다.</li>
</ul>
<div class="fragment"><div class="line">def teacher</div>
<div class="line">    checkAttendence() void</div>
<div class="line">        def student</div>
<div class="line">            name str</div>
<div class="line">            me(n str): name = n</div>
<div class="line"> </div>
<div class="line">        bow(s student) void # bow는 중첩함수입니다.</div>
<div class="line">            print(&quot;Glad to see you. I&#39;m ${s.name}\n&quot;)</div>
<div class="line"> </div>
<div class="line">        for s in {student(&quot;Marie&quot;), student(&quot;Crono&quot;),</div>
<div class="line">                student(&quot;Lucca&quot;)}</div>
<div class="line">            bow(s)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  teacher().checkAttendence()</div>
<div class="line"># 결과:</div>
<div class="line">#   Glad to see you. I&#39;m Marie</div>
<div class="line">#   Glad to see you. I&#39;m Crono</div>
<div class="line">#   Glad to see you. I&#39;m Lucca</div>
</div><!-- fragment --><ul>
<li>✅ 중첩 함수는 외부함수와 같은 obj scope을 사용합니다.</li>
<li>☐ 중첩 함수는 호출 시점까지의 outer scope을 capture 합니다.</li>
</ul>
<div class="fragment"><div class="line">def app</div>
<div class="line">    foo() void</div>
<div class="line">        arr := {1, 2, 3} # (1)</div>
<div class="line">        getLenFrom() int</div>
<div class="line">            # if val: print(&quot;ok&quot;) # err.</div>
<div class="line">            # val은 이 함수 정의보다 뒤에 나옵니다. 그러니 getLenFrom()에서 val을 사용할 수 없습니다.</div>
<div class="line">            arr.len # 호출 시점에서의 밖에 있는 `arr` 배열에 접근합니다.</div>
<div class="line">        print(getLenFrom()) # 이 시점에서의 `arr`은 1번의 `arr`입니다.</div>
<div class="line"> </div>
<div class="line">        val := true # 이제 val이 정의되었습니다.</div>
<div class="line">        if val</div>
<div class="line">            arr := {4, 5} # (2)</div>
<div class="line">            print(getLenFrom()) # getLenFrom() 안에서 사용되는 `arr`은 (1)의 `arr` 입니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
클로저</h2>
<ul>
<li>✅ 함수를 다른 context로 넘기면(인자로 넣거나, 함수에서 반환) 클로저가 됩니다.</li>
<li>✅ 클로저 호출시에는 me 가 필요 없습니다.</li>
</ul>
<div class="fragment"><div class="line">def app</div>
<div class="line">    func() int</div>
<div class="line">    foo(n int) func</div>
<div class="line">        arr := {1, 2, 3}</div>
<div class="line">        getLenFrom() int</div>
<div class="line">            ret arr.len + n</div>
<div class="line">        # 함수를 넘기면, 이 함수는 클로저가 됩니다.</div>
<div class="line">        ret getLenFrom</div>
<div class="line"> </div>
<div class="line">    main() void</div>
<div class="line">        closure := app().foo(1)</div>
<div class="line">        closure() # &quot;4&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
is</h2>
<ul>
<li>✅ <code>A is B</code> 는 A가 B 타입일때 true가 반환됩니다.</li>
</ul>
<div class="fragment"><div class="line">value := get()</div>
<div class="line">if value is flt</div>
<div class="line">    print(value as flt)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
in</h2>
<ul>
<li>✅ <code>A in B</code> 는 B container의 A가 원소로 들어가 있으면 true 입니다.</li>
<li>✅ <code>in</code>은 value equality 관점에서 원소가 존재하는지를 검사합니다.</li>
</ul>
<div class="fragment"><div class="line">arr := {1, 2, 3}</div>
<div class="line">2 in arr # true</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Pattern Matching</h2>
<ul>
<li>☐ 패턴매칭을 실행할 구문은 한줄짜리 일반 구문이어야 합니다. 단, 예외적으로 할당정의문도 올 수 있습니다.</li>
<li>☐ 검사 구문이란, 패턴이 일치하는지 확인하는 블록문이 아닌 한줄짜리 구문을 말합니다.</li>
<li>☐ 검사 구문에는 <code>in</code>, <code>is</code>, <code>비교문</code>을 lhs만 생략해서 그대로 사용할 수 있습니다.</li>
<li>☐ 검사 구문에는 <code>&amp;&amp;</code>, <code>||</code> 를 사용할 수 없습니다.</li>
<li>☐ 기호나 <code>in</code>, <code>is</code>로 시작하지 않는 경우, 해당 검사는 <code>==</code>로 간주합니다.</li>
<li>☐ 위의 경우 <code>,</code> 를 통해 여러가지 값들 중 하나라도 매칭되는지 검사 할 수 있습니다.</li>
<li>☐ fallthrough 를 지원하지 않습니다.</li>
</ul>
<div class="fragment"><div class="line"># matchers가 다음 중 하나일때,</div>
<div class="line">#    (&lt;inline-expr&gt; [, &lt;inline-expr&gt;]*)* &lt;indentBlock&gt;</div>
<div class="line">#    | in &lt;inline-expr&gt; &lt;indentBlock&gt;</div>
<div class="line">#    | is &lt;type&gt; &lt;indentBlock&gt;</div>
<div class="line">#    | `==` &lt;inline-expr&gt;</div>
<div class="line">#    | `&gt;` &lt;inline-expr&gt;</div>
<div class="line">#    ......</div>
<div class="line"># )</div>
<div class="line">#</div>
<div class="line"># 다음과 같이 사용합니다:</div>
<div class="line"># &lt;inline-expr || def-assign-expr&gt;</div>
<div class="line">#    &lt;matchers&gt;+</div>
<div class="line"> </div>
<div class="line">while true</div>
<div class="line">    intValue := nextIncreasedInt()</div>
<div class="line">        in {1, 2, 4, 5}: print(&quot;$intValue &quot;)</div>
<div class="line">        3, 6: print(&quot;*clap* &quot;)</div>
<div class="line">        is int</div>
<div class="line">            print(&quot;!&quot;)</div>
<div class="line">        &gt; 6: break # for while</div>
<div class="line">        # &gt; 7 &amp;&amp; &lt; 9: .... # 컴파일 에러, 검사구문</div>
<div class="line">        # 안에서 `&amp;&amp;` 나 `||` 쓰면 안됩니다</div>
<div class="line"># 결과:</div>
<div class="line">#  1 2 *clap* 4 5 *clap*</div>
</div><!-- fragment --><ul>
<li>☐ 유일하게 예외적으로 inline 구문에 할당정의문도 포함됩니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md38"></a>
단축된 할당 문법</h2>
<ul>
<li>☐ obj 내 함수를 정의할 때 assignment를 처음부터 실행해놓고 본문을 수행하도록 하는 편의 기능이 있습니다.</li>
<li>☐ 이때는 파라메터를 정의할 때 타입 없이 <code>=프로퍼티명</code>을 적습니다.</li>
<li>☐ 이 기능을 사용하면 함수의 정의를 비워도 abstract 가 아닙니다.</li>
</ul>
<div class="fragment"><div class="line">def A</div>
<div class="line">    age := 0</div>
<div class="line">    name str</div>
<div class="line"> </div>
<div class="line">    # 오리지널 버전:</div>
<div class="line">    ctor(age int, name str)</div>
<div class="line">        me.age = age</div>
<div class="line">        me.name = name</div>
<div class="line">        print(&quot;ctor\n&quot;)</div>
<div class="line"> </div>
<div class="line">    # 축약버전:</div>
<div class="line">    ctor(=age, =name)</div>
<div class="line">        print(&quot;ctor\n&quot;)</div>
</div><!-- fragment --><ul>
<li>☐ 생성자 뿐만 아니라 함수 정의시라면 다 사용합니다.</li>
<li>☐ 람다에서도 동작합니다.</li>
</ul>
<div class="fragment"><div class="line">def Button</div>
<div class="line">    ctor(=name)</div>
<div class="line">    name str</div>
<div class="line"> </div>
<div class="line">def a</div>
<div class="line">    handler onClick</div>
<div class="line">    onClick(btn Button) int # abstract</div>
<div class="line">    setHandler(=handler) void # abstract가 아닙니다.</div>
<div class="line">    setHandler(=onClick) void # err. onClick이라는 프로퍼티는 없습니다.</div>
<div class="line">    dispatch() int: onClick(Button())</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    # `=btn`이 먼저 동작합니다.</div>
<div class="line">    # 그리고 함수 body가 실행됩니다.</div>
<div class="line">    a.setHandler((=btn): print(&quot;${btn.name} click&quot;))</div>
<div class="line">    a.dispatch()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
변수명을 타입명과 동일하게 하려면 ‘’`으로 편하게 합니다.</h2>
<ul>
<li>✅ 변수 정의시에 <code>button Button</code>을 &lsquo;Button&rsquo;<code>라고 정의할 수 있습니다.</code></li>
<li><code>✅</code>'<code>를 사용할때는</code>int<code>같은 primitive type을 사용할 수 없습니다.</code></li>
<li><code>✅</code>person[]<code>와 같은</code>map<code>,</code>array<code>,</code>seq` 도 사용 할 수 없습니다.</li>
<li>✅ 변수 정의시에 사용하므로 함수 parameter에서도, 본문에서도, 프로퍼티 선언시에도 다 됩니다.</li>
<li>✅ 불완전객체에 대해서 &lsquo;&rsquo;`를 사용하면 첫글자가 소문자로 풀어집니다.</li>
<li>☐ 함수 타입 접근시에도 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">def Abc</div>
<div class="line">    foo(n int, x int) int: n + x</div>
<div class="line">    boo(int&#39;) int: int + x # err. int는 `&#39;`를 사용할 수 없다.</div>
<div class="line"> </div>
<div class="line">koo(Abc&#39;) int # --&gt; abc Abc 로 풀어집니다.</div>
<div class="line">    ret abc.foo(1, 2)</div>
</div><!-- fragment --><ul>
<li>☐ 당연히, &lsquo;Abe&rsquo;<code>와</code>=Abe'`를 같이 쓸 수 없습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
클래스라는 건 없습니다</h2>
<ul>
<li>✅ 사용자가 <code>def</code>를 통해 정의한 것은 클래스가 아니라 객체입니다. 이를 <code>origin object</code>라고 합니다.</li>
<li>✅ origin 객체는 2가지로 분류합니다.<ul>
<li>1) 하위요소(sub)를 사용할 수 있는 <code>complete object</code> 완전객체.</li>
<li>2) 극히 제한된 일부 요소(sub)만 사용할 수 있는 <code>incomplete object</code> 불완전객체</li>
</ul>
</li>
<li>✅ 완전객체는 origin 객체이면서도 일반적인 객체처럼 사용이 가능한 것을 말합니다.</li>
<li>✅ 완전객체를 protected 생성자로 만들면 싱글톤이 됩니다.</li>
<li>✅ <code>def</code> 시 소괄호를 사용해서 객체완전자를 정의하면 그 origin 객체는 완전객체가 됩니다.</li>
</ul>
<div class="fragment"><div class="line"># def &lt;식별자&gt; `(` &lt;arguments&gt; `)`</div>
<div class="line">#    &lt;defBlock&gt;</div>
<div class="line">def school # 완전객체입니다.</div>
<div class="line">    student person[]</div>
<div class="line">    enroll(person&#39;) void</div>
<div class="line">        student.add(person)</div>
<div class="line"> </div>
<div class="line">def person(1, &quot;default&quot;) # 객체완전자 사용해서 완전객체 로 되었습니다.</div>
<div class="line">    age int</div>
<div class="line">    name str</div>
<div class="line">    ctor(newAge int, name str)</div>
<div class="line">        age = newAge</div>
<div class="line">        me.name = name</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    # school은 완전객체이기 때문에 바로 사용가능합니다.</div>
<div class="line">    school.enroll(person(12, &quot;Charles&quot;))</div>
<div class="line">    print(person.name) # &quot;default&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 불완전객체는 극히 제한된 일부 하위요소(함수, 프로퍼티)만 사용이 가능합니다.</li>
<li>☐ 불완전객체로 선언하려면 객체명을 대문자로 시작합니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    name str</div>
<div class="line"># print(Person.name) # 에러! 불완전객체를 바로 사용할 수 없습니다.</div>
<div class="line">print(Person().name) # &quot;&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 정의할당문을 통해서 새로운 프로퍼티를 만들고, 그곳으로 불완전객체에 대한 참조를 옮길 수 있습니다.</li>
<li>☐ 하지만 그 프로퍼티또한 불완전객체일 뿐입니다. 그러니 물론 프로퍼티 정의시 이름을 대문자로 시작합니다.</li>
</ul>
<div class="fragment"><div class="line">def ComplexLongNameBigCompanyParser</div>
<div class="line">    ctor(): ret</div>
<div class="line">    parse()</div>
<div class="line">        ....</div>
<div class="line"> </div>
<div class="line">ShortParser := ComplexLongNameBigCompanyParser</div>
<div class="line"># ShortParser의 이름이 대문자로 시작해야 합니다.</div>
<div class="line"># ShortParser는 이제 ComplexLongNameBigCompanyParser에 대한 참조를 갖습니다.</div>
<div class="line"># 즉, 인터프리터는 이 둘을 같은 객체라고 생각할 겁니다.</div>
</div><!-- fragment --><ul>
<li>✅ 불완전객체는 모두 origin 객체 입니다.</li>
<li>☐ Origin객체는 할당을 할 수 없습니다.</li>
<li>☐ 만들어진 불완전프로퍼티 또한 불완전객체와 같은 규칙을 따릅니다.</li>
<li>✅ origin 객체여야만 객체를 생성할 수 있는게 아닙니다. 모든 객체는 객체를 생성할 수 있습니다.</li>
<li>✅ origin 객체여야만 타입을 표현하는 건 아닙니다. 모든 객체는 타입으로 표현될 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def person()</div>
<div class="line">    name := &quot;default&quot;</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p1 person</div>
<div class="line">    p1.name = &quot;Chales&quot;</div>
<div class="line">    print(p1.name) # &quot;Chales&quot;</div>
<div class="line"> </div>
<div class="line">    p2 p1 # p2 := p1() 과 같은 코드입니다.</div>
<div class="line">          # p1()은 p1객체를 복제하라는 의미가 아닙니다.</div>
<div class="line">    print(p2.name) # &quot;default&quot;</div>
<div class="line">    print(person.name) # &quot;default&quot;</div>
<div class="line"> </div>
<div class="line">    p3 := p1(p1) # 이게 바로 p1객체를 복제하라는 의미죠.</div>
<div class="line">    print(p3.name) # &quot;Chales&quot;</div>
<div class="line"> </div>
<div class="line">    nestedFunc(p p1) str</div>
<div class="line">        # origin 객체는 타입으로 사용할 수 있습니다.</div>
<div class="line">        # 그러니 당연히 p1도 타입으로 쓸 수 있어야 합니다.</div>
<div class="line">        p.name # 표현식 기반 언어이므로, 블록문의 마지막 라인이 자동으로 반환됩니다.</div>
<div class="line"> </div>
<div class="line">outerFunc(p p1) str</div>
<div class="line"># 에러! p1은 어디까지나 main() 안에서 정의되었으니 밖에서는 모릅니다.</div>
<div class="line">    p.name</div>
</div><!-- fragment --><ul>
<li>✅ 이처럼 Byeol 언어는 클래스란 개념이 없습니다.</li>
<li>✅ origin 객체란, pack 안에 소속되어 시스템에 Global 하게 알려진 객체 하나에 불과합니다.</li>
<li>✅ 그러니 클래스라는 개념은 잊어버리세요.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
스타일로 Attribute 정의</h2>
<ul>
<li>✅ attribute / constraint를 byeol 언어에서는 스타일로 대체해서 표현합니다.</li>
<li>✅ 예를들어, 식별자이름 앞에 <code>_</code> 를 붙이면 <code>protected</code> 접근제한자를 의미합니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    name := &quot;Diana&quot;</div>
<div class="line">    _age := 38</div>
<div class="line">p Person</div>
<div class="line">print(p.name)</div>
<div class="line">print(p.age) # 에러. 숙녀에게 나이 묻는 거 아닙니다.</div>
</div><!-- fragment --><ul>
<li>✅ 대문자로만 적으면 상수입니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">  NAME := &quot;Chales&quot;</div>
<div class="line">p Person</div>
<div class="line">print(p.NAME)</div>
<div class="line">p.NAME = &quot;doraemong&quot; # 에러. NAME의 값은 한번 적으면, 변경될 수 없습니다.</div>
</div><!-- fragment --><ul>
<li>✅ origin 객체명을 소문자로 시작하면 완전객체 입니다.</li>
<li>✅ 소문자로 시작하고, 객체완전자를 적지않으면 알아서 기본생성자를 통한 객체완전자로 인식합니다.</li>
</ul>
<div class="fragment"><div class="line"># 이제 왜 앞선 예제들이 가끔씩 소문자로 시작했는지 아시겠죠?</div>
<div class="line">def Person</div>
<div class="line"># 객체명이 소문자로 시작한다는 것은, 이 객체의 개발자는 이것을 일반객체처럼 다루길 원한다는 뜻입니다.</div>
<div class="line"># 뒤에 `()` 객체완전자가 있는 것처럼 처리합니다.</div>
<div class="line">    name := &quot;&quot;</div>
<div class="line">    ctor()</div>
<div class="line">        name = &quot;default&quot;</div>
<div class="line"> </div>
<div class="line">print(person.name) # &quot;default&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
타입 추론</h2>
<ul>
<li>✅ 변수를 정의할 때, 함수에 인자를 넘길 때 타입을 생략하면 값을 통해 유추합니다.</li>
</ul>
<div class="fragment"><div class="line">space := 42 # int</div>
<div class="line">spaces := {2, 35.5} # flt</div>
<div class="line">spaces2 := {3, 6.34, &quot;wow&quot;} # 에러! flt -&gt; string은 implicit 캐스팅을 지원하지 않습니다.</div>
</div><!-- fragment --><ul>
<li>☐ 람다의 반환형/param타입도 추론 마찬가지 입니다.</li>
</ul>
<div class="fragment"><div class="line">onClick(btn Button) int</div>
<div class="line"> </div>
<div class="line">click(btn Button, onclick onClick) int</div>
<div class="line">    btn.setState(CLICKED)</div>
<div class="line">    onclick(btn)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    btn Button</div>
<div class="line">    click(btn, (btn): 22) # 파라메터 타입 `Button`와, 반환형 `int`로 추론됩니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
프로퍼티</h2>
<ul>
<li>☐ 프로퍼티를 만들 때 <code>getter</code>와 <code>setter</code>를 지정할 수 있습니다.</li>
<li>☐ <code>getter</code>와 <code>setter</code> 정의할 때 소괄호를 넣지 않습니다.</li>
<li>☐ <code>setter</code>시 외부에서 넣은 값은 <code>rhs</code>에 담겨 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    age int</div>
<div class="line">        get</div>
<div class="line">            ret 22</div>
<div class="line">        set</div>
<div class="line">            print(&quot;$rhs, &quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    print(&quot;${person.age}, &quot;)</div>
<div class="line">    person.age = 33</div>
<div class="line">    print(&quot;${person.age}&quot;)</div>
<div class="line"># 결과: 22, 33, 22</div>
</div><!-- fragment --><ul>
<li>☐ 값을 초기화한 프로퍼티에도 <code>getter</code>, <code>setter</code>를 넣을 수 있습니다.</li>
<li>☐ 초기화한 값은 <code>it</code>에 담겨 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    age := 22</div>
<div class="line">        get: it</div>
<div class="line">        set: it = ++rhs</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    print(&quot;${person.age}, &quot;)</div>
<div class="line">    person.age = 33</div>
<div class="line">    print(&quot;${person.age}&quot;)</div>
<div class="line"># 결과: 22, 34</div>
</div><!-- fragment --><ul>
<li>☐ <code>def</code> 에서만 되는 게 아닙니다. 프로퍼티는 함수에서도 만들 수 있었으므로, 함수에서도 <code>getter</code>, <code>setter</code>를 지정할 수 있습니다.</li>
<li>☐ 프로퍼티에 대한 참조를 함수에 넘길 수는 없습니다.</li>
</ul>
<div class="fragment"><div class="line">main() void</div>
<div class="line">    age := 22</div>
<div class="line">        get: it</div>
<div class="line">        set: it = ++rhs</div>
<div class="line">    foo(age) # 안쪽에서도 age의 get, set이 동작할까요?</div>
<div class="line"> </div>
<div class="line">foo(n int) # age의 get한 값이 n에 들어갈 뿐입니다.</div>
<div class="line">           # n이 main() 함수 안에 우리가 특별하게 만든 age는 아닙니다.</div>
<div class="line">    print(&quot;$n, &quot;)</div>
<div class="line">    n = 33</div>
<div class="line">    print(&quot;$n&quot;)</div>
<div class="line"># 결과: 22, 33</div>
</div><!-- fragment --><ul>
<li>☐ <code>getter</code>, <code>setter</code> 를 생략하면 기본동작으로 실행됩니다.</li>
</ul>
<div class="fragment"><div class="line">age int # 값이 없는 프로퍼티 입니다.</div>
<div class="line">    get: 22</div>
<div class="line">    # 값이 없는데 set이 없습니다. set 호출은 에러입니다.</div>
<div class="line">age = 34 # 에러!</div>
<div class="line"> </div>
<div class="line">age1 := 0 # 오! 값이 있습니다.</div>
<div class="line">    get: it</div>
<div class="line">    # set이 없습니다만, 값은 있습니다. 그럼 값에다가 set하는 기본동작을 대신 실행시켜줍니다.</div>
<div class="line">print(&quot;before=$age1, after=${age1 = 34}&quot;)</div>
<div class="line"> </div>
<div class="line">age2 int # 초기화 구문이 없는데 `get`, `set` 도 없나요?</div>
<div class="line">         # 그럼 이건 기존에 보던 age2 := int() 과 같은 코드입니다.</div>
<div class="line">age2 = 18 # set 잘됩니다.</div>
<div class="line">print(age2) # get도 잘되죠.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md44"></a>
우리는 typedef가 필요 없습니다.</h2>
<ul>
<li>✅ 변수 A가 있을때, 별칭 B를 만들고 싶으면 우리는 <code>B := A</code> 라고 사용합니다.</li>
<li>✅ 타입 A가 있을때, 별칭 B를 만들고 싶으면, 다른 언어에서는 새로운 키워드를 사용해야만 했습니다. 예를들어,</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// C++</span></div>
<div class="line"><span class="keyword">typedef</span> A B;</div>
</div><!-- fragment --><div class="fragment"><div class="line">// kotlin</div>
<div class="line">typealias B = A;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// C#: 똑같진 않지만,</span></div>
<div class="line"><span class="keyword">using</span> B = A;</div>
</div><!-- fragment --><ul>
<li>✅ byeol언어는 클래스가 없습니다. 클래스와 객체를 구분하지 않습니다.</li>
<li>✅ 그러니 <code>typedef</code>를 사용하고 싶다면 <code>B := A</code>를 사용하면 됩니다.</li>
<li>☐ 불완전 객체도 타입으로 사용이 가능합니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
it</h2>
<ul>
<li>✅ 모든 블록문 키워드는 대상이 되는 expr과 블록문으로 구성됩니다.</li>
<li>☐ 그 블록문을 실행할때 대상이 되는 expr의 값이 <code>it</code> 에 담겨있습니다.</li>
<li>☐ <code>it</code>은 참조하는 코드가 있어야 생성됩니다.</li>
</ul>
<div class="fragment"><div class="line">for n in {1, 2, 3}</div>
<div class="line">    if it.size == 3 # it은 container 입니다.</div>
<div class="line">        print(n)</div>
<div class="line"> </div>
<div class="line">if n &gt; 2</div>
<div class="line">    print(it) # it은 `n &gt; 2` 즉 true 입니다.</div>
<div class="line"> </div>
<div class="line">a := foo()</div>
<div class="line">    2, 3, 4: print(it.age) # it은 a의 값입니다.</div>
<div class="line"> </div>
<div class="line">with foo()</div>
<div class="line">    print(it.age) # it은 `foo()` 입니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
기본 타입도 객체</h2>
<ul>
<li>✅ 기본 제공되는 타입들도 객체입니다.</li>
<li>✅ 기본 제공되는 container 들도 객체입니다.</li>
<li>✅ <code>A B</code>는 <code>A := B()</code> 와 같습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md47"></a>
표현식 기반 언어</h2>
<ul>
<li>✅ byeol언어는 표현식기반 언어입니다. 무슨 말이냐면, 대부분의 구문이 값을 반환합니다.</li>
<li>✅ 정의문은 가독성 문제가 발생하므로 표현식이 아닙니다.</li>
<li>✅ <code>ret</code>, <code>break</code> 등 흐름에 영향을 주는 구문또한 표현식이 될 수 없습니다.</li>
</ul>
<div class="fragment"><div class="line">isGood := true</div>
<div class="line">max := if !isGood</div>
<div class="line">    print(&quot;1&quot;)</div>
<div class="line">    print(&quot;2&quot;)</div>
<div class="line">    -1 # 블록문은 마지막 표현식을 반환합니다.</div>
<div class="line">else: print(&quot;3&quot;); 10</div>
<div class="line"># 그래서 max는 int 타입이고, -1 아니면 10의 값을 가지죠.</div>
<div class="line"> </div>
<div class="line">val := for n in 0..max # 반복문은 배열을 반환합니다. val은 int[] 타입입니다.</div>
<div class="line">    n</div>
<div class="line">val.len == 10 # true</div>
<div class="line"> </div>
<div class="line">b := if foo()</div>
<div class="line">    &quot;don&#39;t do this&quot;</div>
<div class="line"># else 가 없으므로 b는 str과 void를 타입중에 하나가 되야합니다.</div>
<div class="line"># 그런데 void 타입은 정의할 수 없으므로 결과적으로 이 구문은 컴파일 에러입니다.</div>
</div><!-- fragment --><ul>
<li>✅ assignment는 expression이 아닙니다. 혼란을 일으키며, 굳이 지원했을때의 장점이 없습니다.</li>
</ul>
<div class="fragment"><div class="line">if a = get() # 에러!</div>
<div class="line">foo(a = get(), food = getFood()) # 에러!</div>
<div class="line"> </div>
<div class="line"># 위의 코드는 다음과 같이 변경되어야 합니다:</div>
<div class="line">a = get()</div>
<div class="line">if a == 0: ....</div>
<div class="line"> </div>
<div class="line">a = get()</div>
<div class="line">food = getFood()</div>
<div class="line">foo(a, food)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
with</h2>
<ul>
<li>✅ <code>with</code>는 byeol언어에서 매우 중요한 위치를 차지하는 기능입니다.</li>
<li>✅ 그렇다고 개념이 복잡하거나 어려운 것은 아닙니다. 지극히 단순합니다.</li>
<li>☐ <code>with</code>는 주어진 정의문 혹은 obj의 scope을 주어진 블록문 내부에서만 최상위 scope으로 추가합니다.</li>
<li>✅ 이것을 확장이라고 표현합니다.</li>
</ul>
<div class="fragment"><div class="line">def Person: age := 22</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p Person</div>
<div class="line">    print(p.age) # 원래 이렇게 해야 하지만,</div>
<div class="line"> </div>
<div class="line">    with p # 이제 p의 obj scope이 최상단 scope으로 추가되므로,</div>
<div class="line">           # p객체가 가진 모든 것들에 바로 접근할 수 있습니다.</div>
<div class="line">        print(age) # p.age를 간단하게 호출 할 수 있습니다.</div>
<div class="line">    # 블록문이 끝나면 p의 obj scope은 해제됩니다.</div>
<div class="line"> </div>
<div class="line">    age := 23</div>
<div class="line">    with p2 Person # 정의문이 올 수 있으므로, 이렇게도 가능합니다.</div>
<div class="line">        print(age) # &quot;23&quot;, 물론 local scope은 항상 우선순위가 obj scope 보다 높습니다.</div>
</div><!-- fragment --><ul>
<li>☐ 블록문을 제공하지 않고도 <code>with</code>를 사용할 수 있습니다.</li>
<li>☐ 이 경우, 해당 시점부터 <code>with</code> 구문을 가지는 블록문에서 벗어날때까지 지속됩니다.</li>
</ul>
<div class="fragment"><div class="line">pack example</div>
<div class="line">age := 23 # example.age 입니다.</div>
<div class="line"> </div>
<div class="line">def Person</div>
<div class="line">    age := 30</div>
<div class="line">    sayHello() void</div>
<div class="line">        print(&quot;I&#39;m kniz and $age yo.\n&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    print(age) # &quot;23&quot;</div>
<div class="line"> </div>
<div class="line">    p Person</div>
<div class="line">    print(p.age) # &quot;30&quot;</div>
<div class="line"> </div>
<div class="line">    with Person() # 꼭 `with p` 처럼 써야하는 건 아닙니다.</div>
<div class="line">                  # 임시객체도 객체입니다. 그러니 당연히 여기에 올 수 있습니다.</div>
<div class="line">                  # 블록문을 넣지 않았으니, with 효과는 이 블록문, 즉 main() 전체에 이 시점부터 지속됩니다.</div>
<div class="line">    print(age) # &quot;30&quot;</div>
<div class="line">    sayHello() # &quot;I&#39;m kniz and 30 yo.&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 블록문 없는 <code>with</code>를 2개 이상 선언할 수 있습니다. inline with 구문이라고 합니다.</li>
<li>✅ 일반 <code>with</code>는 일반 구문을 담을 수 있는 블록문이 있습니다. 그러니 <code>with</code> 자체도 일반 구문입니다.</li>
<li>✅ 반면 inline <code>with</code>는 무언가 값을 내보내는 것이 아닙니다. 따라서 정의문입니다.</li>
<li>☐ 이 inline <code>with</code> 구문 간에 우선순위는 없습니다. 따라서 확장되는 식별자가 겹치지 않도록 조심해야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def ceo</div>
<div class="line">    sayHello() void: print(&quot;work more\n&quot;)</div>
<div class="line"> </div>
<div class="line">def developer</div>
<div class="line">    sayHello() void: print(&quot;want to go my home&quot;)</div>
<div class="line"> </div>
<div class="line">def cat</div>
<div class="line">    meow() void: print(&quot;meow meow&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    with ceo()</div>
<div class="line">    sayHello()</div>
<div class="line"> </div>
<div class="line">    with cat() # 겹치는 식별자가 없습니다.</div>
<div class="line">    meow() # &quot;meow meow&quot;</div>
<div class="line"> </div>
<div class="line">    with developer() # 에러! sayHello() 이름이 겹칩니다.</div>
<div class="line">    # developer의 sayHello()가 ceo의 sayHello()를 덮어쓰지 않습니다.</div>
<div class="line">    # 단순히 에러로 간주될 뿐입니다.</div>
</div><!-- fragment --><ul>
<li>☐ 만약 inline with를 하는 대상의 일부분만을 확장하려면 only를 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">def A</div>
<div class="line">  foo() void: ...</div>
<div class="line">  boo() void: ...</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  a A</div>
<div class="line">  with a only</div>
<div class="line">    foo(void) # a는 foo(), boo() 2개 함수가 있지만 a만 이곳에 확장하고 싶습니다.</div>
<div class="line">  foo() # a.foo()와 같은 코드입니다.</div>
</div><!-- fragment --><ul>
<li>✅ <code>with</code> 는 다른 언어에서도 종종 볼 수 있는 기능입니다.</li>
<li>✅ 하지만 byeol언어는 다른 언어처럼 <code>기능 1개 == 키워드 1개</code>로 보지 않습니다.</li>
<li>✅ 기능마다 키워드를 만들지 말고, 가능하다면 개념을 다 풀어헤쳐서 다시 조립해서 더 간결한 사용법을 만들어야 합니다.</li>
<li>✅ 여러분은 이 <code>with</code> 하나만 파악함으로써, <code>상속</code>, <code>Delegation</code>, <code>import</code>, <code>static</code> 을 모두 사용할 수 있습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
타입 확장으로 활용</h2>
<ul>
<li>☐ 다시한번 말씀드리면, inline <code>with</code>는 정의문입니다.</li>
<li>✅ byeol언어는 문법의 예외를 싫어합니다.</li>
<li>✅ 정의문은 블록정의문에 올 수 있습니다.</li>
<li>✅ <code>def</code> 뒤에는 블록정의문이 나와야 합니다.</li>
<li>☐ 그러니 <code>with</code>를 <code>def</code> 안에서 사용하는 것은 완전히 허용되어야 합니다.</li>
<li>✅ 그러면 과연 <code>def</code> 안에서 <code>with</code>를 쓰면 어떤 의미를 가질까요?</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    age int</div>
<div class="line">    name str</div>
<div class="line"> </div>
<div class="line">def Developer</div>
<div class="line">    with Person() # 이 Person() 임시객체는 이 객체 안에서 유효합니다.</div>
<div class="line">    sayHello() void</div>
<div class="line">        print(&quot;I&#39;m $name and you finally have learned Type Extension :)&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    with Developer()</div>
<div class="line">        age = 27</div>
<div class="line">        name = &quot;kniz&quot;</div>
<div class="line">        sayHello() # &quot;I&#39;m kniz and you finally have learned Type Extension :)&quot;</div>
</div><!-- fragment --><ul>
<li>☐ <code>def</code> 안에서 <code>with</code>는 항상 맨 앞에 나와야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def Developer</div>
<div class="line">    sayHello() void: ...</div>
<div class="line">    with Person # `with` 규칙에 따르면 이 시점부터의 obj scope 보다 우선됩니다.</div>
<div class="line">        sayHello() void # 이렇게 식별자가 겹치면 앞서 정의한 sayHello()를 호출할 방법이 없습니다.</div>
<div class="line">            ....        # 즉 앞서 정의한 sayHello()는 있을 필요가 없는 함수입니다.</div>
<div class="line">                        # 이런걸 사용해야 하는 시나리오는 없어보이고, 이걸 허용하면 혼란만 가중됩니다.</div>
<div class="line">                        # 그래서 `def` 안에서 `with` 는 반드시 첫줄에 입력할 것을 강제합니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md50"></a>
오버라이딩</h2>
<ul>
<li>☐ 오버라이딩을 지원합니다.</li>
<li>☐ 오버라이딩을 한건지, 새로운 함수를 만든건지 걱정이 된다면, 함수명/프로퍼티명 앞에 <code>+</code> 를 붙여보세요. 오버라이딩이 아닐 경우 에러가 발생합니다.</li>
<li>☐ <code>_</code> 기호와 순서는 상관이 없습니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    name str</div>
<div class="line">    sayName() str: name</div>
<div class="line"> </div>
<div class="line">def Developer</div>
<div class="line">    +name := &quot;&quot;</div>
<div class="line">    _+sayName() str: &quot;Miss $name&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
&lt;tt&gt;A::B&lt;/tt&gt; 함수 호출</h2>
<ul>
<li>☐ 확장은 상속과 유사합니다.</li>
</ul>
<div class="fragment"><div class="line">main() void</div>
<div class="line">    b B</div>
<div class="line">    b.boo() # &quot;B::foo()&quot;</div>
<div class="line"> </div>
<div class="line">def A</div>
<div class="line">    boo() void</div>
<div class="line">        foo() # 여기에 왔을때 me obj는 A가 아니라 b 입니다.</div>
<div class="line">              # 그러니 B::foo()가 호출됩니다.</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;foo!&quot;)</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a A</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;B::foo()&quot;)</div>
</div><!-- fragment --><ul>
<li>☐ 하지만 분명히 다릅니다.</li>
</ul>
<div class="fragment"><div class="line">pack example</div>
<div class="line"> </div>
<div class="line">def A</div>
<div class="line">    boo() void</div>
<div class="line">        foo()</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;A::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a A</div>
<div class="line">    boo() void</div>
<div class="line">        a.boo() # 1) 개발자는 무한 재귀를 피하려 했습니다.</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;B::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    B().boo() # A::foo() 일까요 B::foo() 일까요?</div>
</div><!-- fragment --><ul>
<li>☐ <code>1</code>에서 <code>a.boo()</code> 을 했으므로 A의 boo()가 호출됩니다.</li>
<li>☐ 문제는 <code>a.</code> 을 하면서 boo() 함수가 호출되었을때 me obj가 <code>b</code> 에서 <code>a</code>로 교체된 것에 있습니다.</li>
<li>☐ 따라서 boo() 함수 안에서 <code>foo()</code>를 하게 되면 <code>me.foo()</code> 즉, <code>a.foo()</code> 와 같은 호출이 됩니다.</li>
<li>☐ 그러므로 결과는 <code>A::foo()</code> 가 됩니다.</li>
<li>☐ 이렇게 오버라이딩 한 확장한 타입의 원본 함수를 그대로 호출하려면 <code>super</code> 를 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">def A</div>
<div class="line">    boo() void</div>
<div class="line">        foo()</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;A::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a A</div>
<div class="line">    boo() void</div>
<div class="line">        super() # 1) 개발자는 무한 재귀를 피하려 했습니다.</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;B::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    B().boo() # &quot;B::foo()&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 하지만 만약, <code>1</code>에서 원본 함수가 아니라 확장한 타입의 전혀 다른 함수를 호출하고 싶다면 어떨까요?</li>
<li>☐ 이런 상황을 해결하기 위해서 <code>A::B</code> 를 사용합니다.</li>
<li>☐ <code>A::B</code>는 <code>A.B</code>와 마찬가지로 A에 있는 B에 접근합니다. 단, 이 과정에서 obj scope이 변경되지 않습니다.</li>
<li>☐ 단 <code>A</code>는 현재 <code>me</code>가 확장한 타입이어야 합니다.</li>
</ul>
<div class="fragment"><div class="line">pack example</div>
<div class="line"> </div>
<div class="line">def A</div>
<div class="line">    boo() void</div>
<div class="line">        foo()</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;A::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a A</div>
<div class="line">    boo() void</div>
<div class="line">        a::boo() # a에 속한 boo() 함수를 찾아 호출할 뿐, me obj는 유지가 됩니다.</div>
<div class="line">                 # me obj는 `.` 을 찍는 순간 변경되거든요.</div>
<div class="line">    foo() void</div>
<div class="line">        print(&quot;B::foo()&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    B().boo() # &quot;&quot;</div>
<div class="line">    A::foo() # 에러! A는 현재 me인 example과 확장관계가 아닙니다.</div>
<div class="line">    with a A</div>
<div class="line">        a::foo() # &quot;A::foo()&quot;</div>
<div class="line">    a::foo() # 에러! a는 현재 me인 example과 더이상 확장관계가 아닙니다. a.foo()를 하세요.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
다중 확장</h2>
<ul>
<li>☐ 당연히 <code>with</code>를 여러개 할 수 있습니다.</li>
<li>☐ 식별자가 겹칠 경우, override를 하면 해결이 가능합니다.</li>
</ul>
<div class="fragment"><div class="line">def Person</div>
<div class="line">    name := &quot;&quot;</div>
<div class="line">    sayName() str: name</div>
<div class="line">def KeyboardTyper</div>
<div class="line">    name := &quot;&quot;</div>
<div class="line">    typeKey() str: &quot;\n&quot;</div>
<div class="line">def Developer</div>
<div class="line">    with p Person</div>
<div class="line">    with k KeyboardTyper</div>
<div class="line">    # 이대로는 식별자 name 이 겹칩니다.</div>
<div class="line"> </div>
<div class="line">    +name str # name을 override 합니다.</div>
<div class="line">        get: p.name # 기본적으로 composition 관계입니다.</div>
<div class="line">                    # 어느쪽 name인지 지칭하려면 프로퍼티명을 적으면 됩니다.</div>
<div class="line">    # 이제 컴파일 에러는 발생하지 않게 됩니다.</div>
</div><!-- fragment --><ul>
<li>☐ 식별자가 겹칠때마다 override를 하는 것은 바람직한 방향이 아닙니다.</li>
<li>☐ 같은 부모 타입을 가진 객체를 모두 <code>with</code> 하게 되면 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">DDD</a>를 하는 것입니다. 이런 경우 에러를 내보냅니다.</li>
<li>☐ <code>with</code>는 가능하면 1개만 하되, 여러개를 할때는 부모 타입이 겹치지 않는 경우에 사용하길 바랍니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
static으로 활용</h2>
<ul>
<li>☐ 불완전객체는 자신의 하위 요소들을 사용하지 못합니다.</li>
<li>☐ 그런데 안에 완전객체가 중첩객체로 들어가 있으면 어떻게 될까요?</li>
</ul>
<div class="fragment"><div class="line">def Food</div>
<div class="line">    printName() void</div>
<div class="line">        print(&quot;Um... I don&#39;t know&quot;)</div>
<div class="line"> </div>
<div class="line">    def factory</div>
<div class="line">        makePizza() Food</div>
<div class="line">            def Pizza</div>
<div class="line">                with Food</div>
<div class="line">                +printName() void # override 입니다.</div>
<div class="line">                    print(&quot;I&#39;m pizza!&quot;)</div>
<div class="line">            ret Pizza()</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    Food.factory.makePizza().printName() # &quot;I&#39;m pizza!&quot;</div>
<div class="line">    Food.printName() # 에러! 불완전객체의 하위요소를 사용은 안됩니다. 기억하시죠?</div>
</div><!-- fragment --><ul>
<li>☐ 함수/프로퍼티의 실행 가능한가에 대한 표현은 그 함수를 가지고 있는 origin 객체가 불완전이냐 아니냐로 표현됩니다.</li>
<li>☐ 위의 예제에 with를 섞어주면, 다른 언어에서 static이라고 부르는 기능이 됩니다.</li>
</ul>
<div class="fragment"><div class="line">def Food</div>
<div class="line">    printName() void</div>
<div class="line">        print(&quot;Um... I don&#39;t know&quot;)</div>
<div class="line">    with def # 이름없는 def는 기본 완전객체입니다.</div>
<div class="line">        makePizza() Food</div>
<div class="line">            def()</div>
<div class="line">                with Food()</div>
<div class="line">                +printName() void</div>
<div class="line">                    print(&quot;I&#39;m pizza!&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    Food.makePizza() # 완전객체의 메소드이므로 이 메소드는 호출가능한 상태입니다.</div>
<div class="line">    Food.printName() # 에러!</div>
</div><!-- fragment --><ul>
<li>☐ 그러나 함수의 정의된 객체가 완전객체이므로 확장된 불완전객체에서도 바로 사용할 수 있다는 점 때문에, 다음과 같이 헷갈릴 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def a</div>
<div class="line">    foo() void: boo()</div>
<div class="line">    boo() void: print(&quot;a::boo()\n&quot;)</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a</div>
<div class="line">    boo() void: print(&quot;B::boo()\n&quot;)</div>
<div class="line"> </div>
<div class="line">b.foo() # foo()가 정의된 곳은 b가 아니라 a 이므로</div>
<div class="line">        # foo() 함수를 호출 가능하겠다고 생각할지도 모릅니다.</div>
<div class="line">        # 그렇다면 me obj는 B가 아니라 a로 되어야 하는 거겠죠? a의 함수니까요.</div>
<div class="line"># 결과:</div>
<div class="line">#  B()::boo() # 어라? me obj가 a였다면 a::boo() 가 나와야 했는데요?</div>
</div><!-- fragment --><ul>
<li>☐ B는 a로부터 확장한 것이므로 B의 함수이기도 합니다.</li>
<li>☐ 그러니 B객체에 foo()를 호출하면 B가 me obj로 등록되는 게 자연스럽습니다.</li>
<li>☐ 여기까지의 내용을 응용하면 불완전객체를 프로퍼티로 받아 <code>with</code>로 함으로써 static 처럼 사용할 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def A</div>
<div class="line">    age := 5</div>
<div class="line"> </div>
<div class="line">def B</div>
<div class="line">    with a A # A는 불완전객체이지만, A로부터 복제된 a는 완전객체입니다.</div>
<div class="line">print(B.age)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md54"></a>
delegation으로 활용</h2>
<ul>
<li>☐ 아시다시피 프로퍼티는 값을 바꿀 수 있습니다.</li>
<li>☐ 그렇다면 <code>with</code> 한 프로퍼티도 값을 바꿀 수 있어야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    age := 2</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p person</div>
<div class="line">    p.age = 65</div>
<div class="line">    with p</div>
<div class="line"> </div>
<div class="line">    print(age) # &quot;65&quot;</div>
<div class="line">    p = person()</div>
<div class="line">    print(age) # &quot;2&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 이것을 응용하면 다른 언어에서 delegate 키워드로 제공하는 것을 대신할 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def Pet</div>
<div class="line">    name str</div>
<div class="line">    eat() void: print(&quot;I can&#39;t eat&quot;)</div>
<div class="line">    fly() void: print(&quot;I can&#39;t fly&quot;)</div>
<div class="line"> </div>
<div class="line">def dog</div>
<div class="line">    +name := &quot;sadaharu&quot;</div>
<div class="line">    +eat() void: print(&quot;$name loves Liberty&quot;)</div>
<div class="line">    +fly() void: print(&quot;$name can&#39;t fly.. or can I?&quot;)</div>
<div class="line"> </div>
<div class="line">def cat</div>
<div class="line">    +name := &quot;teyandee&quot;</div>
<div class="line">    +eat() void: print(&quot;$name loves Cats Me!&quot;)</div>
<div class="line">    +fly() void: print(&quot;$name can fly for some seconds&quot;)</div>
<div class="line"> </div>
<div class="line">def ProxyPet1</div>
<div class="line">    _realPet Pet</div>
<div class="line"> </div>
<div class="line">    ctor(realPet&#39;): ret</div>
<div class="line">    eat() void: realPet.eat()</div>
<div class="line">    fly() void: realPet.fly()</div>
<div class="line">    # 이렇게 Pet의 모든 함수에 다 delegate 해줘야 할까요?</div>
<div class="line"> </div>
<div class="line">def ProxyPet2</div>
<div class="line">    with realPet Pet</div>
<div class="line">    ctor(@realPet): ret</div>
<div class="line">    # 이제 realPet의 obj scope이 모두 확장됩니다.</div>
<div class="line">    # realPet.eat(), realPet.fly() 가 포함됩니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    with myPet := ProxyPet1(dog)</div>
<div class="line">        eat() # &quot;sadaharu love Liberty&quot;</div>
<div class="line">        myPet = ProxyPet2(cat)</div>
<div class="line">        eat() # &quot;teyandee love Cats Me!&quot;</div>
</div><!-- fragment --><ul>
<li>✅ 물론 일부 함수만 delegate 하고 싶다면 직접 코드를 작성해야 합니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md55"></a>
import</h2>
<ul>
<li>✅ byeol언어는 <code>import</code> 키워드가 없습니다.</li>
<li>✅ 타 언어에서 import의 기능은 2가지 입니다.<ul>
<li>1) Module 의존관계 표현</li>
<li>2) 해당 module의 scope을 현재 파일에 확장</li>
</ul>
</li>
<li>☐ byeol언어에서는 1은 manifest를 통해 해결합니다.</li>
<li>☐ manifest 파일을 작성해서, 어떠한 외부 pack을 가져올 것인지 정의합니다.</li>
<li>✅ mainfest는 byeol 언어를 환경설정 목적으로 특화/경량화한 <code>leaf</code> 언어로 작성됩니다.</li>
<li>✅ <code>leaf</code> 언어는 byeol 언어와 거의 똑같습니다.</li>
<li>☐ import 하려는 pack들의 충돌 문제를 완화할 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line">def manifest</div>
<div class="line">    import fjson@chales.lee:1.2.* as json1</div>
<div class="line">    import gjson@giigle:0.7.* ~ 0.8.5 as json2</div>
</div><!-- fragment --><ul>
<li>☐ import 기능 2은 <code>with</code>나 <code>:=</code>를 사용합니다.</li>
</ul>
<div class="fragment"><div class="line">with openai # 이제 openai pack의 모든 sub가 이 파일에 확장됩니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p openai.Parser</div>
<div class="line">    openai.parseText(p)</div>
<div class="line"> </div>
<div class="line">    # 위와 같은 코드 입니다:</div>
<div class="line">    p Parser</div>
<div class="line">    parseText(p)</div>
</div><!-- fragment --><ul>
<li>☐ 하나의 객체만 import 하고 싶다면 <code>:=</code> 를 사용하면 됩니다.</li>
</ul>
<div class="fragment"><div class="line"># import os.openai 하고 싶다면:</div>
<div class="line">openai := os.openai</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    openai.doSomething()</div>
</div><!-- fragment --><ul>
<li>☐ 2개 이상의 여러개의 일부만 import를 하고 싶다면 <code>with only</code>를 응용합니다.</li>
</ul>
<div class="fragment"><div class="line"># 아래를 하고 싶다면:</div>
<div class="line">#  import os.openai.Parser</div>
<div class="line">#  import os.openai.parseText</div>
<div class="line">#  import os.openai.generator</div>
<div class="line">with os.openai only</div>
<div class="line">    Parser</div>
<div class="line">    parseText</div>
<div class="line">    generator</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    p Parser</div>
<div class="line">    parseText(p, &quot;rawStringwow!&quot;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md56"></a>
err</h2>
<ul>
<li>✅ byeol언어에 에러는 개념적으로 2가지로 분류됩니다.<ul>
<li>1) 사전에 에러가 발생할 수 있다고 고지한 에러</li>
<li>2) 고지하지 않고 발생한 에러. 익셉션이라고 합니다.</li>
</ul>
</li>
<li>✅ 익셉션을 포함하여 모든 에러는 Err 객체로부터 확장입니다.</li>
<li>✅ Err객체는 msg, callstack등 기본적인 API를 가지고 있습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md57"></a>
errorable type</h2>
<ul>
<li>☐ 사전에 에러가 발생할 수 있다고 고지하면, 좀 더 완만한 처리가 가능합니다.</li>
<li>☐ 에러는 <code>?</code> 로 표현됩니다. 즉 타입에 에러가 발생할 수 있다는 <code>?</code> 를 붙이면, 미리 에러가 발생할 수 있다고 고지할 수 있습니다.</li>
<li>☐ 이를 ErrorableType이라고 합니다.</li>
<li>☐ 참고로, null 도 err를 확장한 객체에 불과합니다.</li>
</ul>
<div class="fragment"><div class="line">getElem(key str) int? # int일 수도 있고 에러(? 기호) 일 수도 있습니다.</div>
<div class="line">    if key == &quot;&quot;: ret outOfBoundErr</div>
<div class="line">    ret map[key]</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    elem int? := null</div>
<div class="line">    elem = getElem(&quot;pizza&quot;) # elem은 int? 타입입니다.</div>
<div class="line">        is null: elem = -1</div>
<div class="line">        is outOfBoundErr: elem = -1</div>
<div class="line">    # err였을 경우 elem에는 -1이 들어갑니다.</div>
</div><!-- fragment --><ul>
<li>☐ ErrorableType은 결과적으로 처리를 지연시키는 효과를 가집니다.</li>
</ul>
<div class="fragment"><div class="line">getElem(key str) int? # int일 수도 있고 에러(? 기호) 일 수도 있습니다.</div>
<div class="line">    if key == &quot;&quot;: ret outOfBoundErr</div>
<div class="line">    ret map[key]</div>
<div class="line"> </div>
<div class="line">foo() void? # void?라... 이상한가요? 그런데 말이 되는 타입입니다.</div>
<div class="line">    elem int? := null</div>
<div class="line">    elem = getElem(&quot;pizza&quot;) # elem은 int? 타입입니다.</div>
<div class="line">        is err: ret it # 에러가 나기만 했다면 에러로 반환합니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    if foo() is err</div>
<div class="line">        print(&quot;error!&quot;) # getElem에서 발생한 에러가 이시점까지 지연되었습니다.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md58"></a>
safe-navigation</h2>
<ul>
<li>☐ <code>?.</code> 를 사용하면, 에러일때만 함수를 호출할 수 있습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md59"></a>
exception이란?</h2>
<ul>
<li>✅ 같은 에러라도 고지하지 않은 상태에서 갑자기 에러가 반환하면, 이를 익셉션이라고 합니다.</li>
<li>☐ 한 줄의 구문을 처리하는 도중에 익셉션이 발생하면, 나머지 처리를 모두 건너뛰고 바로 한 라인의 최종 결과가 됩니다.</li>
<li>☐ 외부에서 익셉션에 대한 유일한 대처방법은 <code>pattern matching</code>을 사용하는 겁니다.</li>
<li>☐ 일반적인 언어와 달리 try, catch가 없습니다. 기능이 부족하다는 관점이 아니라, 불필요한 개념을 압축한 것이라고 생각해주세요.</li>
<li>☐ 블록문에 대한 예외처리를 할 수 없습니다. 한줄마다 해야 합니다.</li>
</ul>
<div class="fragment"><div class="line">arr := getArrayFrom(...) # 얼마나 size가 되는지 모릅니다.</div>
<div class="line">print(arr[3]) # 그래도 일단 접근해보자!</div>
<div class="line">              # 만약 size가 3 이하일 경우, array 객체로부터 outOfBoundErr가 발생합니다.</div>
<div class="line">              # outOfBoundErr는 print() 호출등을 모두 건너뛰고 바로 이 `print(arr[3])`</div>
<div class="line">              # 라인의 최종 결과물이 됩니다.</div>
<div class="line">    is outOfBoundErr</div>
<div class="line">        print(it.msg) # it은 outOfBoundErr 객체입니다.</div>
<div class="line">        ret</div>
<div class="line">doSomethingWhenNoError()</div>
</div><!-- fragment --><ul>
<li>✅ 익셉션이 처리되지 못하면, 그 시점부터 callstack이 남겨집니다.</li>
<li>☐ 만약 정의할당 혹은 할당 연산 도중에 익셉션이 발생했다면, 예외처리시 <code>ret</code>를 하거나 정상적인 값으로 채워야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def arr</div>
<div class="line">    get(n int) int # 반환형은 errorable type이 아닙니다.</div>
<div class="line">        if n == 3: ret outOfBoundErr # 그런데 갑자기 err를 반환합니다. 즉 익셉션입니다.</div>
<div class="line">        if n &gt; 4: ret null</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    val := arr.get(3) # val의 타입은 함수의 반환형으로 추론되어야 합니다.</div>
<div class="line">                      # 그러니 int?가 아니라 int 입니다.</div>
<div class="line">        is outOfBoundErr # 익셉션에 대한 예외처리를 시작합니다.</div>
<div class="line">            # val에는 int타입인데도 err가 들어가 있는 상태입니다.</div>
<div class="line">            val = -1 # 그러니 다시 int 타입으로 채워넣지 않으면 에러입니다.</div>
<div class="line">        is null</div>
<div class="line">            # 이번에는 함수를 종료했습니다.</div>
<div class="line">            ret</div>
</div><!-- fragment --><ul>
<li>☐ 만약 local scope에 속하지 않은 프로퍼티를 할당연산 도중에 exception의 예외처리를 하면, 반드시 이 프로퍼티의 값을 채워야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    age int</div>
<div class="line">    foo() void</div>
<div class="line">        age = arr().get(3) # 안에서 outOfBoundErr가 exception이 발생합니다.</div>
<div class="line">            is err</div>
<div class="line">                age = -1 # age는 지역변수가 아닙니다.</div>
<div class="line">                         # 따라서 바로 ret를 해버리면 age에는 여전히 exception이 담겨있게 됩니다.</div>
<div class="line">                         # 그래서 age를 적절한 int의 값으로 채우지않으면 컴파일 에러가 발생합니다.</div>
<div class="line">                ret</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
abstract</h2>
<ul>
<li>☐ 프로퍼티나 함수를 abstract로 선언할 수 있습니다.</li>
<li>☐ 프로퍼티나 함수를 abstract로 선언하면 해당 식별자를 가진 객체는 자동으로 abstract로 정의됩니다.</li>
<li>☐ abstract 객체를 확장한 객체는 모든 abstract 요소를 오버라이딩해야 객체로 생성할 수 있습니다.</li>
<li>✅ abstract 함수는 body를 명시하지 않으면 됩니다.</li>
</ul>
<div class="fragment"><div class="line">add(a int, b int) int # 이 함수는 abstract 합니다. 이 함수를 바로 호출 할 수 없습니다.</div>
<div class="line">foo(cl add) int</div>
<div class="line">  ret cl() # 타입으로 사용가능합니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  foo((a, b): a + b)</div>
</div><!-- fragment --><ul>
<li>[?] abstract 프로퍼티는 2가지 방법으로 정의합니다.</li>
<li>[?] 첫번째 방법은 <code>get; set;</code> 으로 get과 set의 구현부를 비워주는 겁니다.</li>
<li>[?] 프로퍼티를 정의하고 <code>get</code>, <code>set</code>을 정의한다는 것은, 이 프로퍼티의 get, set 이 발생할때 값을 내보내는 대신, 개발자가 정의할 적절한 동작의 결과를 대신 내보내겠다는 의미일 것입니다.</li>
<li>[?] 바로 그 초기값이 없는 프로퍼티를 만들어 놓고 <code>get</code>, <code>set</code>을 생략해버리면 인터프리터 입장에서 그 기본 동작으로, 어떤 것도 대신 해줄 수 없습니다. 즉 호출시 컴파일 에러로 처리하는 게 최선입니다.</li>
<li>[?] 그러니 <code>get</code>, <code>set</code>을 정의할 뿐 구현부를 비워놓으면 <code>get</code>도 <code>set</code> 도 불가능한, abstract 한 프로퍼티가 됩니다.</li>
</ul>
<div class="fragment"><div class="line">def Base</div>
<div class="line">    age int</div>
<div class="line">        get; set; # 초기값이 없는데 getter, setter를 지정한다는 건, 사용자가 이 프로퍼티에 대한 get과 set을</div>
<div class="line">                  # 채우겠다는 뜻 일겁니다.</div>
<div class="line">                  # 그런데 정작 구현부가 없습니다. 아무런 동작을 채우지 않았으므로, 이 프로퍼티를 사용하지</div>
<div class="line">                  # 못하게 됩니다. 즉 사용하지 못하지만, interface 로써의 프로퍼티가 존재하는 셈이고,</div>
<div class="line">                  # 우리는 이걸 abstract 라고 표현합니다.</div>
</div><!-- fragment --><ul>
<li>[?] 두번째 방법은 abstract 타입으로 정의하는 겁니다.</li>
</ul>
<div class="fragment"><div class="line">def Base # abstract를 가지고 있으니 불완전객체로 정의해야 했습니다.</div>
<div class="line">    fly() void # abstract 함수입니다.</div>
<div class="line"> </div>
<div class="line">def Derived</div>
<div class="line">    b Base # abstract 타입으로 프로퍼티를 만들었고, 초기값도 넣지 않았습니다.</div>
<div class="line">           # 그렇다고 errorable type (Base?) 도 아닙니다. Base? 였다면 null이라도 대신 넣어줄 수 있습니다.</div>
<div class="line">           # 즉 b는 자연스럽게 abstract 프로퍼티가 됩니다.</div>
</div><!-- fragment --><ul>
<li>☐ abstract 객체로부터 객체를 생성하고 싶다면 반드시 abstract 요소를 모두 오버라이딩으로 채워야 합니다.</li>
</ul>
<div class="fragment"><div class="line">def Base</div>
<div class="line">    age int: get;set # abstract 프로퍼티</div>
<div class="line">    fly() void # abstract 함수</div>
<div class="line"> </div>
<div class="line">def derived</div>
<div class="line">    with Base # abstract 타입인 Base로부터 확장했습니다. Base의 abstract 요소인 age, fly()를 모두 채워야 합니다.</div>
<div class="line">    +age := 1</div>
<div class="line">    +fly() void: print(&quot;fly!\n&quot;)</div>
<div class="line">    # 오버라이딩으로 채웠습니다. derived는 더이상 abstract 객체가 아닙니다.</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  b Base := derived()</div>
<div class="line">  print(b.age) # &quot;0&quot;</div>
</div><!-- fragment --><ul>
<li>☐ abstract 타입으로 프로퍼티를 만들었어도 생성자에서 채우면 abstract가 아닙니다.</li>
</ul>
<div class="fragment"><div class="line">def Base # abstract 객체 입니다.</div>
<div class="line">    fly() void # abstract 함수입니다.</div>
<div class="line"> </div>
<div class="line">def Derived</div>
<div class="line">    _b Base # abstract 타입으로 프로퍼티를 만들었으니 Derived는 abstract 객체가 됩니다.</div>
<div class="line">    ctor(newB Base)</div>
<div class="line">        b = newB # 그런데 생성자에서 abstract 한 프로퍼티에 구체값을 채워줬습니다.</div>
<div class="line"># 더이상 Derived는 abstract 하지 않습니다.</div>
</div><!-- fragment --><ul>
<li>☐ 인터프리터는 생성자에서 abstract 프로퍼티를 할당연산으로 채워넣었는가 아닌가를 지능적으로 판단합니다.</li>
<li>☐ 다음은 그 조건들 입니다.<ul>
<li>1) 생성자 안에서 오버라이딩 되지 않은 모든 abstract 프로퍼티를 생성자에서 채워넣어야 abstract 객체가 아니게 됩니다.</li>
<li>2) 생성자 안에서 <code>if</code>, <code>Pattern Matching</code>을 사용한 경우, 어떠한 경로로 분기하더라도 abstract 프로퍼티를 모두 채워넣어야 합니다.</li>
<li>3) 분기 도중 <code>ret</code> 을 하는 경우, ret 되는 시점에서 모든 abstract 프로퍼티에 채워넣어져 있어야 합니다.</li>
<li>4) 모든 생성자가 위 조건을 만족해야 합니다.</li>
<li>5) 분기문에서의 조건은 고려하지 않습니다. 즉 <code>if true</code> 같이 절대로 <code>else</code> 분기하지 않는다고 하더라도, 인터프리터는 이를 고려하지 않습니다.</li>
</ul>
</li>
<li>☐ abstract 한 불완전객체인지, 구체타입이지만 개발자가 원하지 않아서 불완전객체인지를 키워드로 구별할 방법은 없습니다.</li>
<li>☐ 인터프리터는 코드를 보고 abstract 요소가 있는지 구분하고 파악하고 있습니다.</li>
<li>☐ 확장한 객체의 abstract 요소를 모두 오버라이딩하지 않고 객체를 생성하려고 시도하면 에러로 어떠어떠한 abstract 요소를 채우지 않았다고 알려줍니다.</li>
<li>✅ byeol언어는 모든 언어들의 편의 기능을 제공하는 것에는 관심이 없습니다.</li>
<li>✅ byeol언어는 불편하지는 않으면서, 어떻게 하면 종래의 개념과 문법을 간결하게 풀어낼 수 있을지에 더 관심이 있습니다.</li>
<li>✅ 그래서 byeol언어는 다른 언어들에 있는 몇가지 문법/개념을 일부러 제공하지 않습니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md61"></a>
함수타입 대신 메소드을 사용</h2>
<ul>
<li>✅ byeol언어는 함수타입을 제공하지 않습니다.</li>
<li>✅ 함수에 대한 정의 자체가 함수에 대한 타입입니다.</li>
</ul>
<div class="fragment"><div class="line">def Person # 우리는 객체를 정의했고,</div>
<div class="line">  name str</div>
<div class="line">p Person # 정의했으니 타입으로 쓸 수 있습니다.</div>
<div class="line"> </div>
<div class="line"># 그렇다면,</div>
<div class="line">foo(n int) int: ret n # 함수를 정의했으니,</div>
<div class="line">dispatch(listener foo) int # 함수를 타입으로 쓰는게 맞지 않을까요?</div>
<div class="line">  ret listener(3)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  print(dispatch((n): n + 1)) # &quot;4&quot;</div>
</div><!-- fragment --><ul>
<li>☐ 함수 이름만 가지고 구분이 되지 않으면 signature를 적어야 합니다.</li>
</ul>
<div class="fragment"><div class="line">foo(n int) int: ret 0</div>
<div class="line">foo(n flt) flt: ret 0.1</div>
<div class="line">dispatch(listener foo(n int)) int</div>
<div class="line">  ret listener(3)</div>
</div><!-- fragment --><ul>
<li>✅ 하지만 그보다는 이름을 바꿉시다.</li>
</ul>
<div class="fragment"><div class="line">OnEvent(n int): int</div>
<div class="line">dispatch(listener OnEvent) int</div>
<div class="line">  ret listener(3)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
제네릭</h2>
<ul>
<li>✅ origin 객체를 정의할때 이름 뒤에 &lt;타입인자목록&gt; 을 추가함으로써 제네릭 객체를 정의할 수 있습니다.</li>
</ul>
<div class="fragment"><div class="line"># def 객체이름&lt;타입인자목록&gt;</div>
<div class="line">#    &lt;정의블록문&gt;</div>
<div class="line">def adder&lt;T, R&gt;()</div>
<div class="line">  add(T a, T b) R -&gt; a + b</div>
<div class="line"> </div>
<div class="line">int1 := adder&lt;int, int&gt;.add(1, 2)</div>
<div class="line">str2 := adder&lt;str, str&gt;.add(&quot;nice&quot;, &quot;guy&quot;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">  print(&quot;$int1 \n&quot;)</div>
<div class="line">  print(str2)</div>
<div class="line"># 결과:</div>
<div class="line">#  3</div>
<div class="line">#  niceguy</div>
</div><!-- fragment --><ul>
<li>✅ 함수에 대한 제네릭은 지원하지 않아요.</li>
<li>✅ Type erasure 같은 불완전한 구현이 아닙니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md63"></a>
enumeration</h2>
<ul>
<li>☐ TODO</li>
</ul>
<h1><a class="anchor" id="autotoc_md64"></a>
끝맺으면서</h1>
<ul>
<li>간결한 언어입니다.</li>
<li>byeol:<ul>
<li>pack, def, in, as, is, for, while, next, break, with, if, else, ret, enum, get, set, end, only</li>
</ul>
</li>
<li>C:<ul>
<li>break, case, const, continue, return, default, do, while, else, enum, extern, for, goto, if,</li>
<li>signed, sizeof, static, struct, switch, typedef, union, unsigned, volatile, while</li>
</ul>
</li>
<li>python:<ul>
<li>await, else, import, pass, break, except, in, raise, class, finally, is, return, and, continue,</li>
<li>for, lambda, try, as, def, from, nonlocal, while, assert, del, global, not, with, async, elif,</li>
<li>if, or, yield </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
