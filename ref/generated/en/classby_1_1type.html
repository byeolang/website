<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: by::type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classby_1_1type.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classby_1_1type-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">by::type Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__meta.html">Meta</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Core class for runtime type information in byeol language.  
 <a href="classby_1_1type.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="meta_2type_2type_8hpp_source.html">type.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for by::type:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classby_1_1type.png" usemap="#by::type_map" alt=""/>
  <map id="by::type_map" name="by::type_map">
<area href="classby_1_1ttype_base.html" alt="by::ttypeBase&lt; T, tmetaTypeDef&lt; T, tifHasMetaTypeDef&lt; T &gt;::is &gt;::is &gt;" shape="rect" coords="0,56,413,80"/>
<area href="classby_1_1ntype.html" title="represents native c++ type system for byeol language" alt="by::ntype" shape="rect" coords="634,56,1047,80"/>
<area href="classby_1_1ttype_base_3_01void_00_01type_01_4.html" alt="by::ttypeBase&lt; void, type &gt;" shape="rect" coords="1057,56,1470,80"/>
<area href="classby_1_1ttype.html" title="Template type wrapper providing entry point for meta information." alt="by::ttype&lt; T &gt;" shape="rect" coords="0,112,413,136"/>
<area href="classby_1_1expr_1_1expr_type.html" title="Type information for expression nodes" alt="by::expr::exprType" shape="rect" coords="423,112,836,136"/>
<area href="classby_1_1mgd_type.html" title="Managed type for byeol objects." alt="by::mgdType" shape="rect" coords="846,112,1259,136"/>
<area href="classby_1_1func_type.html" title="Managed type for function objects in byeol language." alt="by::funcType" shape="rect" coords="846,168,1259,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e116c6818fe73d3e95dd0837ead65dd"><td class="memItemLeft" align="right" valign="top">virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a8e116c6818fe73d3e95dd0837ead65dd">operator==</a> (const me &amp;rhs) const</td></tr>
<tr class="memdesc:a8e116c6818fe73d3e95dd0837ead65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two type objects represent the same type.  <a href="classby_1_1type.html#a8e116c6818fe73d3e95dd0837ead65dd">More...</a><br /></td></tr>
<tr class="separator:a8e116c6818fe73d3e95dd0837ead65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888af33523fd29be58e6e7022771d72"><td class="memItemLeft" align="right" valign="top"><a id="ad888af33523fd29be58e6e7022771d72" name="ad888af33523fd29be58e6e7022771d72"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const me &amp;rhs) const</td></tr>
<tr class="separator:ad888af33523fd29be58e6e7022771d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c4d080fe332d8de1e8a9a50e95c32"><td class="memItemLeft" align="right" valign="top"><a id="a6a5c4d080fe332d8de1e8a9a50e95c32" name="a6a5c4d080fe332d8de1e8a9a50e95c32"></a>
virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isTemplate</b> () const =0</td></tr>
<tr class="separator:a6a5c4d080fe332d8de1e8a9a50e95c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115db8266aea12d23d4e608cff26ff9"><td class="memItemLeft" align="right" valign="top"><a id="a3115db8266aea12d23d4e608cff26ff9" name="a3115db8266aea12d23d4e608cff26ff9"></a>
virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isAbstract</b> () const =0</td></tr>
<tr class="separator:a3115db8266aea12d23d4e608cff26ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99bf858b97b4d2ffa1ba065bded31d1"><td class="memItemLeft" align="right" valign="top"><a id="ad99bf858b97b4d2ffa1ba065bded31d1" name="ad99bf858b97b4d2ffa1ba065bded31d1"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> () const</td></tr>
<tr class="separator:ad99bf858b97b4d2ffa1ba065bded31d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ada2d17adf7691a294b682f4e340aeb"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a0ada2d17adf7691a294b682f4e340aeb">make</a> () const =0</td></tr>
<tr class="memdesc:a0ada2d17adf7691a294b682f4e340aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an instance to be refered this type.  <a href="classby_1_1type.html#a0ada2d17adf7691a294b682f4e340aeb">More...</a><br /></td></tr>
<tr class="separator:a0ada2d17adf7691a294b682f4e340aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df468378fd698375f58c2bf56784a44"><td class="memTemplParams" colspan="2"><a id="a9df468378fd698375f58c2bf56784a44" name="a9df468378fd698375f58c2bf56784a44"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9df468378fd698375f58c2bf56784a44"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeAs</b> () const</td></tr>
<tr class="separator:a9df468378fd698375f58c2bf56784a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ec109b0b7977e5b3b25c33937f0f55"><td class="memItemLeft" align="right" valign="top"><a id="a54ec109b0b7977e5b3b25c33937f0f55" name="a54ec109b0b7977e5b3b25c33937f0f55"></a>
virtual ncnt&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const =0</td></tr>
<tr class="separator:a54ec109b0b7977e5b3b25c33937f0f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656d9a54739f8457195da12567e4410a"><td class="memItemLeft" align="right" valign="top">virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init</a> ()</td></tr>
<tr class="memdesc:a656d9a54739f8457195da12567e4410a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes type metadata and constructs class hierarchy.  <a href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">More...</a><br /></td></tr>
<tr class="separator:a656d9a54739f8457195da12567e4410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aea9d43b8048d1f7634bd32b2986539"><td class="memItemLeft" align="right" valign="top"><a id="a6aea9d43b8048d1f7634bd32b2986539" name="a6aea9d43b8048d1f7634bd32b2986539"></a>
virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><b>rel</b> ()</td></tr>
<tr class="separator:a6aea9d43b8048d1f7634bd32b2986539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8401aa7c0cbdc5256216d717a3e9e83d"><td class="memItemLeft" align="right" valign="top"><a id="a8401aa7c0cbdc5256216d717a3e9e83d" name="a8401aa7c0cbdc5256216d717a3e9e83d"></a>
virtual const <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSuper</b> () const =0</td></tr>
<tr class="separator:a8401aa7c0cbdc5256216d717a3e9e83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd1bbbf76fd5b8f696fd28724b8dadf"><td class="memItemLeft" align="right" valign="top"><a id="aadd1bbbf76fd5b8f696fd28724b8dadf" name="aadd1bbbf76fd5b8f696fd28724b8dadf"></a>
virtual const nbool &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>isInit</b> () const =0</td></tr>
<tr class="separator:aadd1bbbf76fd5b8f696fd28724b8dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c802ba295c8b05a322a118d2e16a7f"><td class="memItemLeft" align="right" valign="top">const types &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a38c802ba295c8b05a322a118d2e16a7f">getLeafs</a> () const</td></tr>
<tr class="memdesc:a38c802ba295c8b05a322a118d2e16a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all most derived classes (leaf nodes) from this class.  <a href="classby_1_1type.html#a38c802ba295c8b05a322a118d2e16a7f">More...</a><br /></td></tr>
<tr class="separator:a38c802ba295c8b05a322a118d2e16a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285bdea7b4e52f39bcbc7c0476acdcc6"><td class="memItemLeft" align="right" valign="top"><a id="a285bdea7b4e52f39bcbc7c0476acdcc6" name="a285bdea7b4e52f39bcbc7c0476acdcc6"></a>
const types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubs</b> () const</td></tr>
<tr class="separator:a285bdea7b4e52f39bcbc7c0476acdcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58b5a57bda6648e641863309a31a030"><td class="memItemLeft" align="right" valign="top"><a id="ac58b5a57bda6648e641863309a31a030" name="ac58b5a57bda6648e641863309a31a030"></a>
const types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSupers</b> () const</td></tr>
<tr class="separator:ac58b5a57bda6648e641863309a31a030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ce436da22fc488bf6865cdd1b9ad3"><td class="memItemLeft" align="right" valign="top">virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#ab88ce436da22fc488bf6865cdd1b9ad3">isSuper</a> (const <a class="el" href="classby_1_1type.html">type</a> &amp;it) const</td></tr>
<tr class="memdesc:ab88ce436da22fc488bf6865cdd1b9ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this type is a super class of the given type.  <a href="classby_1_1type.html#ab88ce436da22fc488bf6865cdd1b9ad3">More...</a><br /></td></tr>
<tr class="separator:ab88ce436da22fc488bf6865cdd1b9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5861c7640f1061ce4990771f289503d"><td class="memItemLeft" align="right" valign="top"><a id="ad5861c7640f1061ce4990771f289503d" name="ad5861c7640f1061ce4990771f289503d"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:ad5861c7640f1061ce4990771f289503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebe80b68992e499b73596e5f584dc39"><td class="memTemplParams" colspan="2"><a id="a4ebe80b68992e499b73596e5f584dc39" name="a4ebe80b68992e499b73596e5f584dc39"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ebe80b68992e499b73596e5f584dc39"><td class="memTemplItemLeft" align="right" valign="top">nbool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSuper</b> () const</td></tr>
<tr class="separator:a4ebe80b68992e499b73596e5f584dc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7511efc747aeb12a6b3fc2e2971eb31f"><td class="memItemLeft" align="right" valign="top">nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a7511efc747aeb12a6b3fc2e2971eb31f">isSub</a> (const <a class="el" href="classby_1_1type.html">type</a> &amp;it) const</td></tr>
<tr class="memdesc:a7511efc747aeb12a6b3fc2e2971eb31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this type is a sub class of the given type.  <a href="classby_1_1type.html#a7511efc747aeb12a6b3fc2e2971eb31f">More...</a><br /></td></tr>
<tr class="separator:a7511efc747aeb12a6b3fc2e2971eb31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a9d2698988f989482c16eedb21341"><td class="memItemLeft" align="right" valign="top"><a id="ad69a9d2698988f989482c16eedb21341" name="ad69a9d2698988f989482c16eedb21341"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:ad69a9d2698988f989482c16eedb21341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memTemplParams" colspan="2"><a id="aa5dc9f2bc7369d5f877c18dd1f5817f8" name="aa5dc9f2bc7369d5f877c18dd1f5817f8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memTemplItemLeft" align="right" valign="top">nbool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSub</b> () const</td></tr>
<tr class="separator:aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f76be2976586efd88e5f13b22474a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a03f76be2976586efd88e5f13b22474a5">getStatic</a> () const BY_CONST_FUNC(_getStatic()) virtual const nchar *getMetaTypeName() const</td></tr>
<tr class="memdesc:a03f76be2976586efd88e5f13b22474a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get meta type name for efficient type checking.  <a href="classby_1_1type.html#a03f76be2976586efd88e5f13b22474a5">More...</a><br /></td></tr>
<tr class="separator:a03f76be2976586efd88e5f13b22474a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa25d13f72a4e5bcd95dd9cd9e3f4f192"><td class="memItemLeft" align="right" valign="top"><a id="aa25d13f72a4e5bcd95dd9cd9e3f4f192" name="aa25d13f72a4e5bcd95dd9cd9e3f4f192"></a>
virtual types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getSubs</b> ()=0</td></tr>
<tr class="separator:aa25d13f72a4e5bcd95dd9cd9e3f4f192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a5feac948fd26c73fbef32a760bc8"><td class="memItemLeft" align="right" valign="top"><a id="a978a5feac948fd26c73fbef32a760bc8" name="a978a5feac948fd26c73fbef32a760bc8"></a>
virtual types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getSupers</b> ()=0</td></tr>
<tr class="separator:a978a5feac948fd26c73fbef32a760bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebc5bef57dadbc91b0d8e5809cea50"><td class="memItemLeft" align="right" valign="top"><a id="a90ebc5bef57dadbc91b0d8e5809cea50" name="a90ebc5bef57dadbc91b0d8e5809cea50"></a>
virtual <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getStatic</b> () const =0</td></tr>
<tr class="separator:a90ebc5bef57dadbc91b0d8e5809cea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa428c957e61ce218d377e395174cd2a"><td class="memItemLeft" align="right" valign="top"><a id="afa428c957e61ce218d377e395174cd2a" name="afa428c957e61ce218d377e395174cd2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setInit</b> (nbool newState)</td></tr>
<tr class="separator:afa428c957e61ce218d377e395174cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229cdbfb48168e0090f4c022a71f4a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1type.html#a8229cdbfb48168e0090f4c022a71f4a4">_onAddSubClass</a> (const me &amp;subClass)</td></tr>
<tr class="memdesc:a8229cdbfb48168e0090f4c022a71f4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook method called when a new subclass is registered with this type.  <a href="classby_1_1type.html#a8229cdbfb48168e0090f4c022a71f4a4">More...</a><br /></td></tr>
<tr class="separator:a8229cdbfb48168e0090f4c022a71f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a46a899de5d4cc2a60bf9867c5e3a7"><td class="memItemLeft" align="right" valign="top"><a id="a84a46a899de5d4cc2a60bf9867c5e3a7" name="a84a46a899de5d4cc2a60bf9867c5e3a7"></a>
virtual types **&#160;</td><td class="memItemRight" valign="bottom"><b>_onGetLeafs</b> () const =0</td></tr>
<tr class="separator:a84a46a899de5d4cc2a60bf9867c5e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa355f7b7fe931edc5fb899a51352aac9"><td class="memItemLeft" align="right" valign="top"><a id="aa355f7b7fe931edc5fb899a51352aac9" name="aa355f7b7fe931edc5fb899a51352aac9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setLeafs</b> (types *newLeafs) const</td></tr>
<tr class="separator:aa355f7b7fe931edc5fb899a51352aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e01bb05c48c7eae5b7f8f951f684fb2"><td class="memItemLeft" align="right" valign="top"><a id="a7e01bb05c48c7eae5b7f8f951f684fb2" name="a7e01bb05c48c7eae5b7f8f951f684fb2"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getNativeName</b> () const</td></tr>
<tr class="separator:a7e01bb05c48c7eae5b7f8f951f684fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Core class for runtime type information in byeol language. </p>
<p >The central class of the meta module. Provides fundamental type information APIs.</p>
<h1><a class="anchor" id="Basic"></a>
type identification</h1>
<ul>
<li>isTemplate(): Returns whether this is a template class</li>
<li>isAbstract(): Returns whether this is an abstract class</li>
<li>getName(): Returns class name (demangled)</li>
</ul>
<h1><a class="anchor" id="Class"></a>
hierarchy information</h1>
<ul>
<li>getSupers(): Returns list of super classes, with direct parent at the end</li>
<li>getSubs(): Returns list of sub classes, with closest descendants first</li>
<li>isSuper(const type&amp; rhs): Checks if this is a super class of rhs</li>
<li>isSub(const type&amp; rhs): Checks if this is a sub class of rhs</li>
</ul>
<p >Performance note: <a class="el" href="classby_1_1type.html#ab88ce436da22fc488bf6865cdd1b9ad3" title="Checks if this type is a super class of the given type.">isSuper()</a> and <a class="el" href="classby_1_1type.html#a7511efc747aeb12a6b3fc2e2971eb31f" title="Checks if this type is a sub class of the given type.">isSub()</a> are more efficient than dynamic_cast. While dynamic_cast typically loops through vtables, the meta module uses a tier algorithm that compares tier values and char* addresses for O(1) type checking.</p>
<h1><a class="anchor" id="Instance"></a>
creation</h1>
<ul>
<li><a class="el" href="classby_1_1type.html#a0ada2d17adf7691a294b682f4e340aeb" title="create an instance to be refered this type.">make()</a>: Creates instance using default constructor. Returns nullptr if no default constructor exists.</li>
</ul>
<h1><a class="anchor" id="Meta"></a>
type information management</h1>
<ul>
<li><a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">init()</a>: Initializes type information</li>
<li>rel(): Releases type information</li>
</ul>
<p >These are typically handled automatically via BY_INIT_META macro and rarely need direct invocation.</p>
<h1><a class="anchor" id="How"></a>
meta information is generated</h1>
<p >Type information like isTemplate(), isAbstract(), and getName() is filled by ttypeBase&lt;T&gt; through metaprogramming. The purpose of <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">type::init()</a> is to construct the class hierarchy.</p>
<p >The hierarchy is built using the constraint that "all classes must define super
as a typedef". With super defined for all classes, ttype&lt;super&gt;().<a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">init()</a> can be called, enabling recursive class hierarchy construction:</p>
<div class="fragment"><div class="line">nbool <a class="code hl_function" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">type::init</a>() {</div>
<div class="line">    <span class="keywordflow">if</span>(_isInit) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    _isInit = <span class="keyword">true</span>; <span class="comment">// Executes only once</span></div>
<div class="line"> </div>
<div class="line">    type&amp; super = (type&amp;) getSuper();</div>
<div class="line">    super.<a class="code hl_function" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init</a>(); <span class="comment">// Recursively calls parent&#39;s init</span></div>
<div class="line">                  <span class="comment">// Eventually reaches adam, which has no parent</span></div>
<div class="line"> </div>
<div class="line">    types&amp; mySupers = getSupers();</div>
<div class="line">    mySupers = super.getSupers();</div>
<div class="line">    mySupers.push_back(&amp;super);</div>
<div class="line">}</div>
<div class="ttc" id="aclassby_1_1type_html_a656d9a54739f8457195da12567e4410a"><div class="ttname"><a href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">by::type::init</a></div><div class="ttdeci">virtual nbool init()</div><div class="ttdoc">Initializes type metadata and constructs class hierarchy.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Automatic"></a>
meta information generation</h1>
<p >Type objects are initialized via <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">init()</a> calls, but manually calling <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">init()</a> for every class would be inefficient. The BY_INIT_META macro solves this by using BY_INITIATOR to execute <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy.">init()</a> before main() via static object initialization with lambda functions.</p>
<p >The constraint is that each class declaration must include BY_INIT_META(MyClass). These meta DSL-style macros are executed through the BY macro convention, and core module adds additional meta DSL macros, so use BY(CLASS()) or BY(ADT()) instead of calling BY_INIT_META directly.</p>
<h1><a class="anchor" id="Adding"></a>
custom meta information</h1>
<p >While type provides substantial type information, language implementations like byeol may need additional information like parameters or return types. You might think to inherit from type, but since the user entry point must always be ttype&lt;T&gt;, and you cannot modify ttype&lt;T&gt; code from modules depending on meta, inheritance isn't possible. Instead, inject custom meta types.</p>
<p >The core code is in ttypeBase&lt;T&gt;: </p><div class="fragment"><div class="line">template &lt;typename T, typename S = typename tmetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line"><span class="keyword">class </span>ttypeBase: <span class="keyword">public</span> S { }</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, nbool hasMeta = tifHasMetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line"><span class="keyword">struct </span>tmetaTypeDef { <span class="keyword">using</span> is = type; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>tmetaTypeDef&lt;T, true&gt; { <span class="keyword">using</span> is = <span class="keyword">typename</span> T::metaType; };</div>
</div><!-- fragment --><p ><a class="el" href="structby_1_1tmeta_type_def.html" title="Meta type definition selector.">tmetaTypeDef</a> returns T::metaType if it exists, otherwise returns type. ttype inherits from <a class="el" href="classby_1_1ttype_base.html" title="Base class for template type metadata.">ttypeBase</a>, which inherits from tmetaTypeDef&lt;T&gt;::is. When calling ttype&lt;T&gt;, if class T defines <code>typedef metaType MyType</code>, the ttype&lt;T&gt; object will be based on MyType.</p>
<p >This feature is actually used in the core module to inject ntype. See <a class="el" href="classby_1_1ntype.html">ntype</a> for details. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8229cdbfb48168e0090f4c022a71f4a4" name="a8229cdbfb48168e0090f4c022a71f4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8229cdbfb48168e0090f4c022a71f4a4">&#9670;&nbsp;</a></span>_onAddSubClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void by::type::_onAddSubClass </td>
          <td>(</td>
          <td class="paramtype">const me &amp;&#160;</td>
          <td class="paramname"><em>subClass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook method called when a new subclass is registered with this type. </p>
<p >Derived type classes can override this method to perform custom actions (e.g., updating internal structures or caches) whenever a new <code>subClass</code> is added to its hierarchy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subClass</td><td>The new subclass being added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38c802ba295c8b05a322a118d2e16a7f" name="a38c802ba295c8b05a322a118d2e16a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c802ba295c8b05a322a118d2e16a7f">&#9670;&nbsp;</a></span>getLeafs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const types &amp; by::type::getLeafs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all most derived classes (leaf nodes) from this class. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of type pointers representing all leaf classes in hierarchy </dd></dl>

</div>
</div>
<a id="a03f76be2976586efd88e5f13b22474a5" name="a03f76be2976586efd88e5f13b22474a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f76be2976586efd88e5f13b22474a5">&#9670;&nbsp;</a></span>getStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classby_1_1type.html">type</a> &amp; by::type::getStatic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get meta type name for efficient type checking. </p>
<p >This returns metaTypename. metaTypename can be used like 'dynamic_cast&lt;yourType&gt;'. as you may know, c++'s dynamic_cast is slow. because normally compilers tries to loop in order to figure out which type is fit to given your type parameter. 'meta' library, however, uses 'tier' algorithm and it's O(1), so it's faster.</p>
<p >you can use your own metaType to represent more data on type class. for instance, 'core' module uses 'ntype' custom type class. but in that case, when you compare custom type class, you must compare extended data to 'rhs' variable to base type class, 'type'.</p>
<p >so how can you know that 'type' is actually instance of your derived custom type class in 'tier' algorithm? please don't think about 'dynamic_cast'. it'll vanish our effectiveness to use 'tier' algorithm. that's why I make 'getMetaTypeName()' func.</p>
<dl class="section return"><dt>Returns</dt><dd>static literal c-style string for meta type name. so you are able to use c-style casting if address of 'rhs' variables's getMetaTypeName() isn just same to yours. <div class="fragment"><div class="line">yourType&amp; a = ....;</div>
<div class="line">type&amp; rhs = ....;</div>
<div class="line"><span class="keywordflow">if</span>(a.getMetaTypeName() != rhs.getMetaTypeName()) <span class="keywordflow">return</span>;</div>
<div class="line">yourType&amp; rhsCasted = (yourType&amp;) rhs;</div>
<div class="line"> </div>
<div class="line">...now you can <span class="keywordflow">do</span> something on yourType<span class="stringliteral">&#39;s data...</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a656d9a54739f8457195da12567e4410a" name="a656d9a54739f8457195da12567e4410a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656d9a54739f8457195da12567e4410a">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nbool by::type::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes type metadata and constructs class hierarchy. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if already initialized </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Recursively initializes super class hierarchy. Automatically called via BY_INIT_META macro before main(). Sets up super/sub relationships. </dd></dl>

</div>
</div>
<a id="a7511efc747aeb12a6b3fc2e2971eb31f" name="a7511efc747aeb12a6b3fc2e2971eb31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7511efc747aeb12a6b3fc2e2971eb31f">&#9670;&nbsp;</a></span>isSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nbool by::type::isSub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this type is a sub class of the given type. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a sub class of it, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses O(1) tier algorithm. Implemented as it.isSuper(*this). </dd></dl>

</div>
</div>
<a id="ab88ce436da22fc488bf6865cdd1b9ad3" name="ab88ce436da22fc488bf6865cdd1b9ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ce436da22fc488bf6865cdd1b9ad3">&#9670;&nbsp;</a></span>isSuper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nbool by::type::isSuper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this type is a super class of the given type. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a super class of it, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses O(1) tier algorithm comparing tier values, much faster than dynamic_cast which typically loops through vtables. </dd></dl>

</div>
</div>
<a id="a0ada2d17adf7691a294b682f4e340aeb" name="a0ada2d17adf7691a294b682f4e340aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ada2d17adf7691a294b682f4e340aeb">&#9670;&nbsp;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void * by::type::make </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an instance to be refered this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>available when the type defines a ctor without any params. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>return an address of new instance, however, if ctor without any params isn't defined, then returns null. </dd></dl>

<p>Implemented in <a class="el" href="classby_1_1mgd_type.html#aef1673945bda18fb8287deb0905871a1">by::mgdType</a>, and <a class="el" href="classby_1_1ttype_base_3_01void_00_01type_01_4.html#ac30f3b021276b3d284b2ff975da7588c">by::ttypeBase&lt; void, type &gt;</a>.</p>

</div>
</div>
<a id="a8e116c6818fe73d3e95dd0837ead65dd" name="a8e116c6818fe73d3e95dd0837ead65dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e116c6818fe73d3e95dd0837ead65dd">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nbool by::type::operator== </td>
          <td>(</td>
          <td class="paramtype">const me &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two type objects represent the same type. </p>
<p >This comparison typically checks if the underlying type information (e.g., name, template status) is identical. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other type object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both type objects represent the same type, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/byeol/byeol/module/meta/type/<a class="el" href="meta_2type_2type_8hpp_source.html">type.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
