<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: /home/runner/work/byeol/byeol/module/indep/macro/to.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('to_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">to.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;indep/macro/overload.hpp&quot;</code><br />
<code>#include &quot;<a class="el" href="type_trait_8hpp_source.html">indep/helper/typeTrait.hpp</a>&quot;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="to_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab66a6cdf25aca4c8eeb667e884fc905a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="to_8hpp.html#ab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(fn)</td></tr>
<tr class="separator:ab66a6cdf25aca4c8eeb667e884fc905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7cb366086cbf84f34273eedec949ed8a"><td class="memTemplParams" colspan="2"><a id="a7cb366086cbf84f34273eedec949ed8a" name="a7cb366086cbf84f34273eedec949ed8a"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a7cb366086cbf84f34273eedec949ed8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>by::operator-&gt;*</b> (T &amp;t, F &amp;&amp;f)</td></tr>
<tr class="separator:a7cb366086cbf84f34273eedec949ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58cf68222c94f75b48e1e0053e8f746"><td class="memTemplParams" colspan="2"><a id="ac58cf68222c94f75b48e1e0053e8f746" name="ac58cf68222c94f75b48e1e0053e8f746"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac58cf68222c94f75b48e1e0053e8f746"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>by::operator-&gt;*</b> (const T &amp;t, F &amp;&amp;f)</td></tr>
<tr class="separator:ac58cf68222c94f75b48e1e0053e8f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a504750e4d9e34be4f1208829cacb7c"><td class="memTemplParams" colspan="2"><a id="a3a504750e4d9e34be4f1208829cacb7c" name="a3a504750e4d9e34be4f1208829cacb7c"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3a504750e4d9e34be4f1208829cacb7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>by::operator-&gt;*</b> (T &amp;&amp;t, F &amp;&amp;f)</td></tr>
<tr class="separator:a3a504750e4d9e34be4f1208829cacb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6468caea428438e57be9e81bc5e287"><td class="memTemplParams" colspan="2"><a id="a0d6468caea428438e57be9e81bc5e287" name="a0d6468caea428438e57be9e81bc5e287"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0d6468caea428438e57be9e81bc5e287"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>by::operator-&gt;*</b> (T *t, F &amp;&amp;f)</td></tr>
<tr class="separator:a0d6468caea428438e57be9e81bc5e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43304d42b1ec18644730761873659046"><td class="memTemplParams" colspan="2"><a id="a43304d42b1ec18644730761873659046" name="a43304d42b1ec18644730761873659046"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a43304d42b1ec18644730761873659046"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>by::operator-&gt;*</b> (const T *t, F &amp;&amp;f)</td></tr>
<tr class="separator:a43304d42b1ec18644730761873659046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Safe navigation macro (TO) implementation for byeol language </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab66a6cdf25aca4c8eeb667e884fc905a" name="ab66a6cdf25aca4c8eeb667e884fc905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66a6cdf25aca4c8eeb667e884fc905a">&#9670;&nbsp;</a></span>TO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    -&gt;*[&amp;](<span class="keyword">auto</span>&amp;&amp; __p) -&gt; <span class="keyword">decltype</span>(__p.fn) { \</div>
<div class="line">        return __p.fn;                       \</div>
<div class="line">    }</div>
</div><!-- fragment --><p ><code>to</code> is safe navigation feature of c++: <code>TO</code> supports the safe navigation features of modern languages very intuitively and naturally. the basic usage is <code>&lt;expression&gt; <a class="el" href="to_8hpp.html#ab66a6cdf25aca4c8eeb667e884fc905a">TO(yourAccessor())</a></code>. let's explain with an example first before explain further.</p>
<p >usage: let's assume that we have following classes. </p><pre class="fragment">struct Resource {
    Pallete* getPallete(); // this can return nullptr.
};
struct Pallete {
    Canvas* getCanvas(); // this can return nullptr.
};
struct Canvas {
    Brush&amp; getBrush(int type); // this can't return nullptr.
};
</pre><p> as-is: in language spec of c++, there is no sort of safe navigation thing, so we've to do like this. </p><pre class="fragment">int getBrushColorCode(Resource r) {
    auto* pallete = r.getPallete();
    if(!pallete) {
        log("pallete is null");
        return -1;
    }

    auto* canvas = pallete-&gt;getCanvas();
    if(!canvas) {
        log("canvas is null");
        return -1;
    }

    Brush&amp; brush = canvas-&gt;getBrush(BrushType.SYSTEM);

    return brush.getColorCode();
}
</pre><p> of course, this example illustrates a rather extreme train wreck pattern, and is a design that should be avoided, but situations where you need to access a pointer to a certain number of pointers occur frequently, and if you don't always check in advance whether the pointer is valid every time you dereference it, UB will occur.</p>
<p >to be: with safe navigation, whether you will receive nullptr or not is determined after the dereference chain of all pointers is finished. so the resulting code can become very concise. </p><pre class="fragment">int getBrushColorCode(Resource r) {
    int* code = r TO(getPallete()) TO(getCanvas())
    TO(getBrush(BrushType.SYSTEM)) TO(getColorCode()); if(!code) {
        log("code is null")
        return -1;
    }

    return *code;
}
</pre><p> note: as you can see, it looks easy to use, but there are a few things that you should be aware of. </p><pre class="fragment">1. the previously mentioned `&lt;expression&gt;` does not simply mean pointers and
references,
   but also includes classes that satisfy the following conditions.

    a. a class that defines operator-&gt;().
    b. a class that defines operator*().
    c. a class that defines operator bool().

   you may have noticed that the classes that satisfy the above conditions are
   usually smart pointers like `unique_ptr`. the byeol repository provides separate
   smart pointers and classes that replace std::optional&lt;T&gt; for API consistency and
   safe type checking.
    e.g. tstr&lt;T&gt;, tweak&lt;T&gt;, binder, tmay&lt;T&gt;, tres&lt;T&gt; are included here.

   the TO() macro is designed to work properly even if the return value of the
   function is a value or reference to the above class. it works even if it exists
   in the middle of safe navigation chain. for example,

        struct Resource {
            Pallete* getPallete(); // this can return nullptr.
        };
        struct Pallete {
            Canvas&amp; getCanvas(); // this *never* returns nullptr.
        };
        struct Canvas {
            tstr&lt;Brush&gt; getBrush(int type); // this is not pointer, but
            pointer-like-variable.
        };

        int getBrushColorCode(Resource r) {
            // however you can do exactly same like above example.
            int* code = r TO(getPallete()) TO(getCanvas())
            TO(getBrush(BrushType.SYSTEM)) TO(getColorCode())

            // but you may notice that you don't have to put `TO` for reference
            type. so, int* code = r TO(getPallete().getCanvas())
            TO(getBrush(BrushType.SYSTEM)) TO(getColorCode());

            if(!code) return -1;
            return code;
        }

2. if nullptr returned during the chain, the final result value becomes the nullptr
of last type of
   the chain.
   if it is T*, it will be nullptr, but if it is T, i.e. a function that returns by
   value, the return value will be T{}.

3. don't recommend you to put a reference in `TO()`
   references are always non-null, so you can access them directly.

4. it is not recommended for any function to return a pointer type to a
pointer-like-variable.
   pointer-like-variable is a sufficiently lightweight class. You can return it by
   value, or if you don't like that, return it by reference.

5. it goes very well with OR macro.
   please check the usage of OR macro in advance. If you also use WHEN macro, the
   code will become way more concise.

   int getBrushColorMode(Resource r) {
       // this uses OR macro. so final type of the chain is `int&amp;`.
       // but `int&amp;` can be copied into new variable `int`.
       int code = r TO(getPallete()) TO(getCanvas().getBrush(BrushType.SYSTEM))
       TO(getColorCode())
                       OR.err("code is null").ret(-1)
       return code;
   }
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
