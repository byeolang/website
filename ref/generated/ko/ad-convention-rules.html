<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: Byeol 코딩 규칙</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('ad-convention-rules.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Byeol 코딩 규칙</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2byeol_2byeol_2doc_2ref_2ko_2ad-convention-rules"></a> 이 문서는 Byeol 프로젝트의 코딩 표준과 규칙을 정의합니다. 모든 기여자는 코드 일관성과 품질을 유지하기 위해 이 규칙을 따라야 합니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md114"></a>
시작하기 전에</h1>
<p>일단, 간단히 byeol 코드 snippet으로 스타일을 한번 살펴보죠.</p>
<div class="fragment"><div class="line">str me::eval(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    BY_I_SCOPE(<span class="stringliteral">&quot;func %s(%s)@%s&quot;</span>, getSrc(), getParams(), (<span class="keywordtype">void</span>*) <span class="keyword">this</span>);</div>
<div class="line">    WHEN(!thread::get().isInteractable())</div>
<div class="line">        .err(<span class="stringliteral">&quot;thread isn&#39;t interactable&quot;</span>).ret(nerr::newErr(errCode::THERE_IS_NO_FRAMES_IN_THREAD));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// s is from heap space. but freed by _outFrame() of this class.</span></div>
<div class="line">    tstr&lt;scope&gt; s = _evalArgs(a) OR.ret(str());</div>
<div class="line">    node&amp; meObj = a.getMe() OR.err(<span class="stringliteral">&quot;meObj == null&quot;</span>).ret(str());</div>
<div class="line">    <span class="keywordflow">return</span> _interactFrame(meObj, *s, thread::get().getEx().len() - 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>코드의 독해를 떠나서 스타일만 보셨을 때 어떠셨나요? 아마 포인터와 -&gt; 화살표 연산자, STL등 표준라이브러리, unique_ptr이나 snake case, 중괄호 등에 익숙하셨을텐데 이 코드에서는 <b>일반적인 C++ 컨벤션과 많이 다르다</b>는 느낌을 받으셨을 겁니다. 여기에는 제 개인적인 스타일 취향도 있지만, 분명 의도가 있습니다.</p>
<h2><a class="anchor" id="autotoc_md115"></a>
왜 일반적인 C++ 컨벤션과 다른가?</h2>
<p>Byeol 프로젝트의 C++ 코딩 규칙은 일반적인 C++ 컨벤션(예: Google C++ Style Guide, LLVM Coding Standards)과 <b>의도적으로 다릅니다</b>. <b>Byeol 언어의 핵심 철학을 C++ 구현체에도 그대로 적용</b>하기 위한 선택이에요.</p>
<h2><a class="anchor" id="autotoc_md116"></a>
Byeol 언어의 핵심 철학을 요약하면</h2>
<p>Byeol 언어는 간결함을 최우선 가치로 두고 설계되었습니다. 불필요한 복잡성을 제거하고 핵심적인 기능만 남겨, 코드를 읽는 사람이 의도를 빠르게 파악할 수 있도록 합니다. 이와 함께 일관성 또한 중요한 원칙입니다. 한 곳에서 동작하는 방식은 다른 모든 곳에서도 동일하게 동작해야 하며, 이를 통해 학습 곡선을 낮추고 예측 가능한 코드를 작성할 수 있습니다.</p>
<p>또한 Byeol은 작은 개념들을 조합하여 복잡한 기능을 만드는 조합성을 강조합니다. 하나의 기능을 위한 전용 문법을 만들기보다는, 기존의 간단한 개념들을 엮어서 표현할 수 있도록 설계되었습니다. 특히 Byeol에는 클래스라는 개념이 없고, 모든 객체 자체가 타입입니다. 이는 객체와 클래스의 구분을 없애 더 직관적인 프로그래밍을 가능하게 합니다.</p>
<p>마지막으로 Byeol은 작은 장난감처럼 친숙하게 느껴지면서도, 실제로는 완전한 언어 기능을 제공하는 것을 목표로 합니다. 처음 접하는 사람도 쉽게 시작할 수 있지만, 깊이 파고들면 필요한 모든 것을 할 수 있는 언어를 지향합니다.</p>
<h2><a class="anchor" id="autotoc_md117"></a>
C++ 코드에 반영된 철학</h2>
<p>이러한 Byeol의 설계 철학은 C++ 코드 스타일에도 크게 반영되어 있습니다. 예를 들어 byeol 언어 컨벤션을 최대한 동일하게 가져가기 위해 변수명은 모두 <code>camelCase</code>로 되어 있으며 함수명도 <code>len()</code>, <code>get()</code>, <code>make()</code>처럼 짧지만 의미가 명확한 이름을 선호합니다.</p>
<p>byeol 언어는 클래스가 없고, 객체가 타입을 대신한다는 면에서, 클래스와 변수가 예외 없이 동일한 <code>camelCase</code>를 따라야 한다는 네이밍 규칙이 반영되어 있습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// 일반적인 C++: PascalCase 클래스 + 장황한 이름</span></div>
<div class="line"><span class="keyword">class </span>UserManager {</div>
<div class="line">    std::string getUserNameWithValidation() { <span class="comment">/* ... */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Byeol C++: camelCase, 간결한 이름</span></div>
<div class="line"><span class="keyword">class </span>userManager {</div>
<div class="line">    str getName() { <span class="keywordflow">return</span> _name; }</div>
<div class="line">    <span class="keywordtype">int</span> len() { <span class="keywordflow">return</span> _name.length(); }</div>
<div class="line">};</div>
</div><!-- fragment --><p>이처럼 C++ 코드를 작성하면서도 Byeol 언어의 철학을 일관되게 유지함으로써, 언어 사용자가 구현체 코드를 볼 때도 같은 사고방식으로 접근할 수 있도록 했습니다.</p>
<p>혹시 관심이 있다면 byeol 언어의 설계 철학에 대한 자세한 내용은 <a href="https://byeol.io/guide/generated/ko/design-philosophy.html">디자인 철학 문서</a>를 참조하세요.</p>
<h2><a class="anchor" id="autotoc_md118"></a>
코딩 스타일은 clang-format으로 자동 적용</h2>
<p>이 문서에 명시된 코딩 스타일은 clang-format을 통해 자동으로 적용되고 검증됩니다. 커밋을 제출하면 CI가 자동으로 <code>builder.py format</code> 명령을 실행하여 프로젝트 루트의 <code>.clang-format</code> 파일에 정의된 규칙대로 코드가 작성되었는지 확인합니다. 만약 스타일 위반이 발견되면 빌드가 실패하므로, 커밋 전에 로컬에서 미리 포맷을 적용해두면 좋아요.</p>
<p>로컬에서 포맷을 적용하려면 프로젝트 루트에서 다음 명령을 실행하면 됩니다:</p>
<blockquote class="doxtable">
<p>&zwj;./build/builder.py format </p>
</blockquote>
<p>이를 통해 CI에서 스타일 위반으로 빌드가 실패하는 상황을 미리 방지할 수 있어요.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md120"></a>
네이밍 규칙</h1>
<h2><a class="anchor" id="autotoc_md121"></a>
클래스와 변수: camelCase</h2>
<p>클래스명과 변수명은 항상 소문자로 시작하는 <code>camelCase</code>를 사용합니다.</p>
<h3><a class="anchor" id="autotoc_md122"></a>
✅ 올바른 예제</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>userManager { <span class="comment">/* ... */</span> };  <span class="comment">// 클래스명</span></div>
<div class="line"><span class="keywordtype">int</span> myAge = 25;                   <span class="comment">// 변수명</span></div>
<div class="line">std::string userName;             <span class="comment">// 변수명</span></div>
<div class="line"><span class="keywordtype">bool</span> isValid;                     <span class="comment">// 변수명</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md123"></a>
❌ 잘못된 예제</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>UserManager { };     <span class="comment">// 틀림! (PascalCase 사용 금지)</span></div>
<div class="line"><span class="keyword">class </span>user_manager { };    <span class="comment">// 틀림! (snake_case 사용 금지)</span></div>
<div class="line"><span class="keywordtype">int</span> my_age;                <span class="comment">// 틀림! (snake_case 사용 금지)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md124"></a>
매크로: UPPER_SNAKE_CASE</h2>
<p>매크로와 <code>#define</code> 상수는 항상 <code>UPPER_SNAKE_CASE</code>를 사용합니다.</p>
<h3><a class="anchor" id="autotoc_md125"></a>
✅ 올바른 예제</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAX_BUFFER_SIZE 1024          </span><span class="comment">// 상수</span></div>
<div class="line"><span class="preprocessor">#define IS_DEBUG_MODE 1               </span><span class="comment">// 조건부 컴파일</span></div>
<div class="line"><span class="preprocessor">#define SQUARE(x) ((x) * (x))         </span><span class="comment">// 함수형 매크로</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md126"></a>
❌ 잘못된 예제</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define maxBufferSize 1024     </span><span class="comment">// 틀림! (camelCase 사용 금지)</span></div>
<div class="line"><span class="preprocessor">#define MaxBufferSize 1024     </span><span class="comment">// 틀림! (PascalCase 사용 금지)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md127"></a>
non public accessor를 위한 언더스코어 접두사</h2>
<p>private, protected 접근제한자를 가진 멤버 변수나 함수는 언더스코어(<code>_</code>)로 시작합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예제</span></div>
<div class="line"><span class="keyword">class </span>userManager {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string getName() { <span class="keywordflow">return</span> _name; }</div>
<div class="line">    <span class="keywordtype">void</span> setAge(<span class="keywordtype">int</span> age) { _age = age; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string _name;</div>
<div class="line">    <span class="keywordtype">int</span> _age;</div>
<div class="line">    <span class="keywordtype">bool</span> _isActive;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 예제</span></div>
<div class="line"><span class="keyword">class </span>userManager {</div>
<div class="line">    std::string name;   <span class="comment">// 틀림! 멤버 변수는 _로 시작</span></div>
<div class="line">    <span class="keywordtype">int</span> age;            <span class="comment">// 틀림!</span></div>
<div class="line">    <span class="keywordtype">bool</span> isActive;      <span class="comment">// 틀림!</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md128"></a>
클래스 접두사</h2>
<p>특정 목적을 가진 클래스에는 접두사를 사용하여 그 의미를 명확히 합니다.</p>
<ul>
<li><b>t</b>: 템플릿 기반 클래스 (예: <code>tstr</code>, <code>tmay</code>, <code>tres</code>, <code>ttype</code>)<ul>
<li>C++ 표준 라이브러리의 <code>std::unique_ptr</code>과 같은 역할을 하는 커스텀 스마트 포인터나 유틸리티 클래스에 사용됩니다.</li>
</ul>
</li>
<li><b>n</b>: Native의 약자로, C++ 런타임용 클래스임을 명시할 때 사용합니다. (예: <code>nmap</code>, <code>narr</code>, <code>nbool</code>)<ul>
<li>Byeol 언어에도 동일한 이름의 클래스(<code>map</code>, <code>arr</code> 등)가 존재할 경우, C++ 구현체(Native)와 Byeol 런타임 객체를 구분하기 위해 사용됩니다.</li>
<li>예: <code>nmap</code>은 C++ 런타임에서 동작하는 맵(Native Map)이며, <code>map</code>은 Byeol 런타임에서 사용되는 맵 객체입니다.</li>
<li><code>t</code> 접두사와 결합하여 <code>tnarr</code>(Template Native Array)와 같이 사용될 수도 있습니다.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md129"></a>
Enum 네이밍</h2>
<p>Enum 타입 이름은 <code>camelCase</code>를 사용하며, Enum 값은 <code>UPPER_SNAKE_CASE</code>를 사용합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예제</span></div>
<div class="line"><span class="keyword">enum</span> priorType {</div>
<div class="line">    EXACT_MATCH = 0,</div>
<div class="line">    NUMERIC_MATCH = 1,</div>
<div class="line">    NO_MATCH</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 예제</span></div>
<div class="line"><span class="keyword">enum</span> PriorType {      <span class="comment">// 틀림! PascalCase 금지</span></div>
<div class="line">    ExactMatch = 0,   <span class="comment">// 틀림! PascalCase 금지</span></div>
<div class="line">    numeric_match     <span class="comment">// 틀림! lower_snake_case 금지</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md130"></a>
인터페이스 네이밍</h2>
<p>순수 가상 함수를 포함하는 인터페이스 성격의 클래스는 <code>-able</code> 접미사를 사용하는 것을 권장합니다. 별도의 <code>I</code> 접두사는 사용하지 않습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예제</span></div>
<div class="line"><span class="keyword">class </span>interactable { <span class="keyword">virtual</span> <span class="keywordtype">void</span> interact() = 0; };</div>
<div class="line"><span class="keyword">class </span>clonable { <span class="keyword">virtual</span> <span class="keywordtype">object</span>* clone() = 0; };</div>
<div class="line"><span class="keyword">class </span>validable { <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isValid() <span class="keyword">const</span> = 0; };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 예제</span></div>
<div class="line"><span class="keyword">class </span>IInteractable { };  <span class="comment">// 틀림! I 접두사 금지</span></div>
<div class="line"><span class="keyword">class </span>interactInterface { }; <span class="comment">// 틀림! 불필요하게 김</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md131"></a>
템플릿 구체화 네이밍</h2>
<p><code>t</code> 접두사가 붙은 템플릿 클래스를 <code>typedef</code>나 <code>using</code>으로 구체화할 때는 <code>t</code> 접두사를 제거하여 사용합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// 템플릿 정의</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>tpriorities { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 구체화 (t 제거)</span></div>
<div class="line"><span class="keyword">typedef</span> tpriorities&lt;node&gt; priorities;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 사용</span></div>
<div class="line">priorities myPriorities;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md132"></a>
기본 타입 사용</h2>
<p>C++ 기본 타입(<code>int</code>, <code>bool</code>, <code>char</code> 등) 대신 <code>by</code> 네임스페이스에 정의된 <code>n</code> 접두사 타입(<code>nint</code>, <code>nbool</code>, <code>nchar</code> 등)을 사용하는 것을 권장합니다. 이는 플랫폼 간의 일관성을 보장하기 위함입니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예제</span></div>
<div class="line">nint count = 0;</div>
<div class="line">nbool isValid = <span class="keyword">true</span>;</div>
<div class="line">nidx index = -1;  <span class="comment">// nint의 typedef</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ⚠️ 비권장</span></div>
<div class="line"><span class="keywordtype">int</span> count = 0;</div>
<div class="line"><span class="keywordtype">bool</span> isValid = <span class="keyword">true</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
파일 명명 규칙</h2>
<p>헤더 파일과 소스 파일의 이름은 **해당 파일이 정의하는 메인 클래스의 이름과 대소문자까지 정확히 일치**해야 합니다.</p>
<ul>
<li>클래스 <code>node</code> -&gt; 파일 <code><a class="el" href="node_8hpp.html">node.hpp</a></code>, <code>node.cpp</code></li>
<li>클래스 <code>stringUtil</code> -&gt; 파일 <code>stringUtil.hpp</code>, <code>stringUtil.cpp</code></li>
<li>클래스 <code>tpriorities</code> -&gt; 파일 <code><a class="el" href="tpriorities_8hpp.html">tpriorities.hpp</a></code></li>
</ul>
<p>파일 이름에 <code>_</code>나 <code>-</code>를 사용하지 않고 <code>camelCase</code>를 유지합니다.</p>
<h2><a class="anchor" id="autotoc_md134"></a>
네이밍 철학</h2>
<p>간결하지만 의미가 명확한 이름을 선호합니다.</p>
<h3><a class="anchor" id="autotoc_md135"></a>
✅ 올바른 예제</h3>
<div class="fragment"><div class="line"><span class="comment">// 간결하고 명확한 이름</span></div>
<div class="line"><span class="keyword">class </span>node { };              <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keyword">class </span>visitor { };           <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">int</span> get();                   <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">void</span> make();                 <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">bool</span> eval();                 <span class="comment">// ⭐ 좋음</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 약어도 의미가 명확하고, 자주 통용되는 단어면 OK</span></div>
<div class="line"><span class="keyword">class </span>ast { };               <span class="comment">// Abstract Syntax Tree - 좋음</span></div>
<div class="line"><span class="keywordtype">int</span> len = str.len();         <span class="comment">// len - 좋음</span></div>
<div class="line"><span class="keywordtype">void</span> init();                 <span class="comment">// initialize - 좋음</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md136"></a>
❌ 불필요하게 긴 예제</h3>
<div class="fragment"><div class="line"><span class="comment">// 너무 장황함 - 피할 것</span></div>
<div class="line"><span class="keyword">class </span>abstractSyntaxTreeNode { };        <span class="comment">// 너무 김! ast 또는 astNode 사용</span></div>
<div class="line"><span class="keywordtype">int</span> getUserNameLengthValue();            <span class="comment">// 너무 김! getUserNameLen() 충분</span></div>
<div class="line"><span class="keywordtype">void</span> processAndValidateUserInput();      <span class="comment">// 너무 김! 두 함수로 분리</span></div>
<div class="line"><span class="keywordtype">bool</span> checkIfUserIsValid();               <span class="comment">// 너무 김! isUserValid() 충분</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// vs 간결한 버전</span></div>
<div class="line"><span class="keyword">class </span>astNode { };                       <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">int</span> getUserNameLen();                    <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">void</span> processInput();                     <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">void</span> validateInput();                    <span class="comment">// ⭐ 좋음</span></div>
<div class="line"><span class="keywordtype">bool</span> isUserValid();                      <span class="comment">// ⭐ 좋음</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md137"></a>
일반적인 네이밍 가이드</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> isValid;              <span class="comment">// Boolean - is, has, can 등으로 시작</span></div>
<div class="line"><span class="keywordtype">int</span> getAge();              <span class="comment">// Getter - get + 명사</span></div>
<div class="line"><span class="keywordtype">void</span> setAge(<span class="keywordtype">int</span> age);      <span class="comment">// Setter - set + 명사</span></div>
<div class="line"><span class="keywordtype">void</span> parse();              <span class="comment">// 동작 함수 - 동사로 시작</span></div>
<div class="line">std::vector&lt;user&gt; users;   <span class="comment">// 컬렉션 - 복수형</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md138"></a>
간단하고 직관적인 단어 선호</h2>
<p>복잡하거나 어려운 단어보다는 직관적이고 쉬운 단어를 선호합니다. 누구나 쉽게 이해할 수 있는 일상적인 단어를 사용하면 코드의 가독성이 높아집니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 좋은 예 - 간단하고 직관적</span></div>
<div class="line"><span class="keywordtype">void</span> make();           <span class="comment">// generate보다 선호</span></div>
<div class="line"><span class="keywordtype">void</span> add(user u);      <span class="comment">// enroll보다 선호</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 나쁜 예 - 불필요하게 복잡</span></div>
<div class="line"><span class="keywordtype">void</span> generate();       <span class="comment">// make가 더 직관적</span></div>
<div class="line"><span class="keywordtype">void</span> enroll(user u);   <span class="comment">// add가 더 간단</span></div>
<div class="line"><span class="keywordtype">void</span> commence();       <span class="comment">// start가 더 쉬움</span></div>
<div class="line"><span class="keywordtype">void</span> terminate();      <span class="comment">// stop이 더 직관적</span></div>
</div><!-- fragment --><p>실제 코드 사례:</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ Byeol 프로젝트 실제 사용 예</span></div>
<div class="line"><span class="keyword">class </span>nodeFactory {</div>
<div class="line">    node* make();              <span class="comment">// 노드 생성</span></div>
<div class="line">    <span class="keywordtype">void</span> add(node* n);         <span class="comment">// 노드 추가</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>visitor {</div>
<div class="line">    <span class="keywordtype">void</span> visit(node&amp; n);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md139"></a>
자주 사용하는 동사</h2>
<p>함수명에는 프로젝트에서 자주 사용되는 동사들을 우선적으로 사용합니다. 같은 의미를 가진 동사를 특별한 이유 없이 혼용하면 안 됩니다.</p>
<p><b>자주 사용되는 동사 목록</b>:</p><ul>
<li><b>add</b> - 원소 추가</li>
<li><b>del</b> - 원소 삭제</li>
<li><b>get</b> - 값 가져오기</li>
<li><b>set</b> - 값 설정</li>
<li><b>make</b> - 객체 생성</li>
<li><b>init</b> - 초기화</li>
<li><b>rel</b> - 해제/정리 (release)</li>
<li><b>eval</b> - 평가/실행</li>
<li><b>sub</b> - 하위 요소 접근</li>
<li><b>bind</b> - 바인딩</li>
<li><b>clone</b> - 복제</li>
<li><b>len</b> - 길이 반환</li>
<li><b>singleton</b> - 싱글톤 접근</li>
<li><b>work</b> - 작업 수행</li>
</ul>
<p><b>접두사 패턴</b>:</p><ul>
<li><b>is</b> + 형용사 - Boolean 술어 (예: <code>isValid()</code>, <code>isEnd()</code>, <code>isNul()</code>)</li>
<li><b>has</b> + 명사 - 존재 여부 확인 (예: <code>has()</code>, <code>hasError()</code>)</li>
<li><b>can</b> + 동사 - 가능 여부 확인 (예: <code>canBind()</code>, <code>canMarshal()</code>)</li>
<li><b>on</b> + 동작 - 이벤트 핸들러 (예: <code>onVisit()</code>, <code>onScan()</code>, <code>onGet()</code>)</li>
<li><b>as</b> + 타입 - 타입 캐스팅 (예: <code>asInt()</code>, <code>asStr()</code>, <code>asBool()</code>)</li>
<li><b>to</b> + 타입 - 타입 변환 (예: <code>toStr()</code>, <code>toMgd()</code>, <code>toNative()</code>)</li>
</ul>
<p>예를 들어 원소를 추가하는 함수는 <code>add()</code> 또는 <code>addElem()</code>을 사용하고, <code>insert</code>, <code>push</code>, <code>append</code> 등을 임의로 섞어 쓰지 않습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예 - 일관된 동사 사용</span></div>
<div class="line"><span class="keyword">class </span>container {</div>
<div class="line">    <span class="keywordtype">void</span> add(<span class="keywordtype">int</span> value);       <span class="comment">// 원소 추가</span></div>
<div class="line">    <span class="keywordtype">void</span> del(<span class="keywordtype">int</span> index);       <span class="comment">// 원소 삭제</span></div>
<div class="line">    <span class="keywordtype">int</span> get(<span class="keywordtype">int</span> index);        <span class="comment">// 값 가져오기</span></div>
<div class="line">    <span class="keywordtype">void</span> set(<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> value);  <span class="comment">// 값 설정</span></div>
<div class="line">    <span class="keywordtype">int</span> len();                 <span class="comment">// 길이 반환</span></div>
<div class="line">    container* clone();        <span class="comment">// 복제</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 예 - 동의어 혼용</span></div>
<div class="line"><span class="keyword">class </span>container {</div>
<div class="line">    <span class="keywordtype">void</span> add(<span class="keywordtype">int</span> value);       <span class="comment">// 추가</span></div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> value);    <span class="comment">// 추가 (혼란!)</span></div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keywordtype">int</span> value);      <span class="comment">// 추가 (혼란!)</span></div>
<div class="line">    <span class="keywordtype">void</span> append(<span class="keywordtype">int</span> value);    <span class="comment">// 추가 (혼란!)</span></div>
<div class="line">    <span class="comment">// → 모두 add로 통일하거나, 명확한 의미 차이가 있어야 함</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>단, 명확한 의미 차이가 있으면 다른 동사 사용 가능합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 의미 차이가 명확한 경우</span></div>
<div class="line"><span class="keyword">class </span>list {</div>
<div class="line">    <span class="keywordtype">void</span> add(<span class="keywordtype">int</span> value);           <span class="comment">// 끝에 추가</span></div>
<div class="line">    <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> value);  <span class="comment">// 특정 위치에 삽입 (의미 차이 명확)</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>stack {</div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keywordtype">int</span> value);          <span class="comment">// 스택의 전통적인 인터페이스</span></div>
<div class="line">    <span class="keywordtype">int</span> pop();                     <span class="comment">// 스택의 전통적인 인터페이스</span></div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md141"></a>
코드 스타일</h1>
<h2><a class="anchor" id="autotoc_md142"></a>
줄 길이와 들여쓰기</h2>
<h3><a class="anchor" id="autotoc_md143"></a>
줄 길이 제한</h3>
<p>가독성을 위해 가능한 100 컬럼 이내로 작성하되, 부득이한 경우 120 컬럼까지 허용됩니다.</p><ul>
<li><b>Soft Cap (권장)</b>: 100 컬럼 이내</li>
<li><b>Hard Cap (강제)</b>: 120 컬럼 이내 (clang-format 강제)</li>
</ul>
<div class="fragment"><div class="line">// ✅ 좋은 예 - 100 컬럼 이내 (권장)</div>
<div class="line">/**</div>
<div class="line"> * @brief 사용자 정보를 검증하고 데이터베이스에 저장합니다</div>
<div class="line"> * @param user 검증할 사용자 객체</div>
<div class="line"> * @return 성공 시 true, 실패 시 false</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">// ⚠️ 허용되지만 비권장 - 120 컬럼 이내</div>
<div class="line">/** </div>
<div class="line"> * @brief 사용자 정보를 검증하고 유효한 경우 데이터베이스에 저장하며 저장 후 로그를 남기고 캐시를 업데이트합니다</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">// ❌ 나쁜 예 - 120 컬럼 초과 (clang-format 오류)</div>
<div class="line">/**</div>
<div class="line"> * @brief 이 함수는 사용자 정보를 검증하고 유효한 경우 데이터베이스에 저장하며 저장 후 로그를 남기고 캐시를 업데이트하며 이메일 알림을 전송합니다</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">// ✅ 개선 - 여러 줄로 분리</div>
<div class="line">/**</div>
<div class="line"> * @brief 사용자 정보를 검증하고 데이터베이스에 저장합니다</div>
<div class="line"> * @details 검증 성공 시 데이터베이스에 저장하고,</div>
<div class="line"> * 저장 후 로그를 남기며 캐시를 업데이트합니다.</div>
<div class="line"> */</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md144"></a>
들여쓰기: 4 스페이스</h3>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 들여쓰기</span></div>
<div class="line"><span class="keyword">class </span>myClass {</div>
<div class="line">    <span class="keywordtype">void</span> myMethod() {</div>
<div class="line">        <span class="keywordflow">if</span>(condition) {</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">                processItem(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 탭 사용 금지</span></div>
<div class="line"><span class="keyword">class </span>myClass {</div>
<div class="line">→   <span class="keywordtype">void</span> myMethod() {  <span class="comment">// 탭 사용 - 틀림!</span></div>
<div class="line">→   →   process();</div>
<div class="line">→   }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md145"></a>
중괄호 스타일: 같은 줄에 배치</h3>
<p>중괄호 <code>{</code>는 선언과 같은 줄에 배치합니다 (K&amp;R style).</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 스타일 - 같은 줄</span></div>
<div class="line"><span class="keywordtype">void</span> myFunction() {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>myClass {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> method() {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(condition) {</div>
<div class="line">    doSomething();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 스타일 - 다음 줄</span></div>
<div class="line"><span class="keywordtype">void</span> myFunction()</div>
<div class="line">{  <span class="comment">// 틀림!</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>myClass</div>
<div class="line">{  <span class="comment">// 틀림!</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md146"></a>
포인터/참조 정렬: 왼쪽 정렬</h3>
<p><code>*</code>와 <code>&amp;</code>는 타입 쪽(왼쪽)에 붙입니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 스타일</span></div>
<div class="line"><span class="keywordtype">int</span>* ptr;</div>
<div class="line"><span class="keyword">const</span> std::string&amp; name;</div>
<div class="line">node* getNode();</div>
<div class="line"><span class="keywordtype">void</span> process(<span class="keyword">const</span> obj&amp; o);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 스타일</span></div>
<div class="line"><span class="keywordtype">int</span> *ptr;          <span class="comment">// 틀림!</span></div>
<div class="line"><span class="keywordtype">int</span> * ptr;         <span class="comment">// 틀림!</span></div>
<div class="line"><span class="keyword">const</span> std::string &amp;name;  <span class="comment">// 틀림!</span></div>
<div class="line">node *getNode();   <span class="comment">// 틀림!</span></div>
</div><!-- fragment --><p><b>여러 변수 선언 시 주의</b>:</p>
<div class="fragment"><div class="line"><span class="comment">// ⚠️ 주의: 한 줄에 여러 포인터 선언 시 각각 * 필요</span></div>
<div class="line"><span class="keywordtype">int</span>* a, *b, *c;  <span class="comment">// a, b, c 모두 포인터</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 권장: 명확성을 위해 각각 선언</span></div>
<div class="line"><span class="keywordtype">int</span>* a;</div>
<div class="line"><span class="keywordtype">int</span>* b;</div>
<div class="line"><span class="keywordtype">int</span>* c;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md147"></a>
괄호 앞 공백: 공백 없음</h3>
<p>함수 호출, 조건문 등의 괄호 <code>(</code> 앞에 공백을 넣지 않습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 스타일</span></div>
<div class="line"><span class="keywordflow">if</span>(condition) { }</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) { }</div>
<div class="line"><span class="keywordflow">while</span>(running) { }</div>
<div class="line">myFunction(arg1, arg2);</div>
<div class="line"><span class="keyword">sizeof</span>(int);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 스타일</span></div>
<div class="line"><span class="keywordflow">if</span> (condition) { }      <span class="comment">// 틀림!</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; ...) { }  <span class="comment">// 틀림!</span></div>
<div class="line">myFunction (arg1, arg2);  <span class="comment">// 틀림!</span></div>
<div class="line"><span class="keyword">sizeof</span> (int);            <span class="comment">// 틀림!</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md148"></a>
네임스페이스 들여쓰기: 들여쓰기 적용</h3>
<p>네임스페이스 내부 코드도 들여쓰기를 적용합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 스타일</span></div>
<div class="line"><span class="keyword">namespace </span>by {</div>
<div class="line">    <span class="keyword">class </span>node {</div>
<div class="line">        <span class="keywordtype">void</span> eval();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> helper() {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}  <span class="comment">// namespace by</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 스타일</span></div>
<div class="line"><span class="keyword">namespace </span>by {</div>
<div class="line"><span class="keyword">class </span>node {  <span class="comment">// 틀림! 들여쓰기 없음</span></div>
<div class="line">    <span class="keywordtype">void</span> eval();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> helper() {  <span class="comment">// 틀림! 들여쓰기 없음</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md149"></a>
짧은 함수/블록: 한 줄 허용</h3>
<p>간단한 함수나 블록은 한 줄로 작성할 수 있습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 한 줄 함수 (getter/setter 등)</span></div>
<div class="line"><span class="keywordtype">int</span> getAge() { <span class="keywordflow">return</span> _age; }</div>
<div class="line"><span class="keywordtype">void</span> setAge(<span class="keywordtype">int</span> age) { _age = age; }</div>
<div class="line"><span class="keywordtype">bool</span> isEmpty() { <span class="keywordflow">return</span> _size == 0; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 짧은 if문</span></div>
<div class="line"><span class="keywordflow">if</span>(ptr) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">if</span>(x &lt; 0) x = 0;</div>
<div class="line"><span class="keywordflow">if</span>(!isValid()) { logError(); <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 여러 구문을 가진 블록문은 한줄로 하지 말것.</span></div>
<div class="line">{ <span class="keywordtype">int</span> tmp = a; a = b; b = tmp; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 복잡한 로직은 여러 줄로</span></div>
<div class="line"><span class="keywordtype">int</span> calculate() {  <span class="comment">// 한 줄로 하지 말 것</span></div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) result += i;</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md150"></a>
1줄 블록문: 중괄호 생략</h3>
<p>블록문 본문이 1줄일 경우, 중괄호를 절대로 적지 않습니다. 블록문 표현식과 본문이 합쳐서 충분히 짧다면 한 줄에 작성할 수 있습니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예 - 1줄이면 중괄호 없음</span></div>
<div class="line"><span class="keywordflow">if</span>(condition)</div>
<div class="line">    doSomething();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++)</div>
<div class="line">    process(i);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(isRunning)</div>
<div class="line">    update();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 충분히 짧으면 한 줄로</span></div>
<div class="line"><span class="keywordflow">if</span>(ptr) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">if</span>(x &lt; 0) x = 0;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) process(i);</div>
<div class="line"><span class="keywordflow">while</span>(hasNext()) advance();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 잘못된 예 - 1줄인데 중괄호 사용</span></div>
<div class="line"><span class="keywordflow">if</span>(condition) {</div>
<div class="line">    doSomething();  <span class="comment">// 틀림! 중괄호 제거해야 함</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    process(i);     <span class="comment">// 틀림! 중괄호 제거해야 함</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 2줄 이상이면 중괄호 필요</span></div>
<div class="line"><span class="keywordflow">if</span>(condition) {</div>
<div class="line">    doSomething();</div>
<div class="line">    doAnotherThing();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    process(i);</div>
<div class="line">    log(i);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md151"></a>
접근 제어자 순서</h3>
<p>클래스 내부에서는 함수를 먼저, 변수를 나중에 배치합니다. 생성자와 연산자, 변수는 접근 제어자를 서술하여 단락을 구분합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 올바른 예제</span></div>
<div class="line"><span class="keyword">class </span>myClass {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 생성자</span></div>
<div class="line">    myClass();</div>
<div class="line">    myClass(<span class="keywordtype">int</span> value);</div>
<div class="line">    ~myClass();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 연산자</span></div>
<div class="line">    myClass&amp; operator=(<span class="keyword">const</span> myClass&amp; other);</div>
<div class="line">    <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> myClass&amp; other) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 일반 public 함수</span></div>
<div class="line">    <span class="keywordtype">void</span> process();</div>
<div class="line">    <span class="keywordtype">int</span> getValue() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> setValue(<span class="keywordtype">int</span> v);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// protected 함수</span></div>
<div class="line">    <span class="keywordtype">void</span> onInitialize();</div>
<div class="line">    <span class="keywordtype">void</span> onDestroy();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// private 함수</span></div>
<div class="line">    <span class="keywordtype">void</span> init();</div>
<div class="line">    <span class="keywordtype">void</span> cleanup();</div>
<div class="line">    <span class="keywordtype">bool</span> validate();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// 멤버 변수는 마지막에</span></div>
<div class="line">    <span class="keywordtype">int</span> _value;</div>
<div class="line">    std::string _name;</div>
<div class="line">    <span class="keywordtype">bool</span> _isValid;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md152"></a>
Early-Return Pattern 선호</h3>
<p>중첩된 조건문보다 early-return 패턴을 선호합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ❌ 나쁜 예 - 중첩된 조건문</span></div>
<div class="line">str evalGeneric(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    std::string key = makeKey(a);</div>
<div class="line">    <span class="keywordflow">if</span>(!key.empty()) {</div>
<div class="line">        <span class="keywordflow">if</span>(!isSelfMaking(key)) {</div>
<div class="line">            <span class="comment">// 실제 처리 로직</span></div>
<div class="line">            <span class="keywordflow">if</span>(!_cache.count(key)) makeGeneric(key, a);</div>
<div class="line">            <span class="keywordflow">return</span> _cache[key];</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            logError(<span class="stringliteral">&quot;error: you tried to clone self generic object.&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        logError(<span class="stringliteral">&quot;key is empty&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 좋은 예 - Early-Return 적용</span></div>
<div class="line">str evalGeneric(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    std::string key = makeKey(a);</div>
<div class="line">    <span class="keywordflow">if</span>(key.empty()) {</div>
<div class="line">        logError(<span class="stringliteral">&quot;key is empty&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(isSelfMaking(key)) {</div>
<div class="line">        logError(<span class="stringliteral">&quot;error: you tried to clone self generic object.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 실제 처리 로직</span></div>
<div class="line">    <span class="keywordflow">if</span>(!_cache.count(key)) makeGeneric(key, a);</div>
<div class="line">    <span class="keywordflow">return</span> _cache[key];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 더 좋은 예 - WHEN 매크로 사용</span></div>
<div class="line">str evalGeneric(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    std::string key = makeKey(a);</div>
<div class="line">    WHEN(key.empty()).err(<span class="stringliteral">&quot;key is empty&quot;</span>).ret(tstr&lt;obj&gt;());</div>
<div class="line">    WHEN(isSelfMaking(key)).err(<span class="stringliteral">&quot;error: you tried to clone self generic object.&quot;</span>).ret(tstr&lt;obj&gt;());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 실제 처리 로직</span></div>
<div class="line">    <span class="keywordflow">if</span>(!_cache.count(key)) makeGeneric(key, a);</div>
<div class="line">    <span class="keywordflow">return</span> _cache[key];</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md153"></a>
TO 매크로 사용</h3>
<p>TO는 safe navigation을 C++에 구현한 것입니다. 이를 사용하여 간결한 코드를 작성하는 것이 매우 권장됩니다.</p>
<div class="fragment"><div class="line"><span class="comment">// 일반적인 코드 - 매번 null 체크 필요</span></div>
<div class="line"><span class="keywordtype">int</span> getBrushColorCode(Resource r) {</div>
<div class="line">    <span class="keyword">auto</span>* pallete = r.getPallete();</div>
<div class="line">    <span class="keywordflow">if</span>(!pallete) {</div>
<div class="line">        log(<span class="stringliteral">&quot;pallete is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>* canvas = pallete-&gt;getCanvas();</div>
<div class="line">    <span class="keywordflow">if</span>(!canvas) {</div>
<div class="line">        log(<span class="stringliteral">&quot;canvas is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Brush* brush = canvas-&gt;getBrush(BrushType.SYSTEM);</div>
<div class="line">    <span class="keywordflow">if</span>(!brush) {</div>
<div class="line">        log(<span class="stringliteral">&quot;brush is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> brush-&gt;getColorCode();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ TO 매크로 사용 - 체이닝으로 간결하게</span></div>
<div class="line"><span class="keywordtype">int</span> getBrushColorCode(Resource r) {</div>
<div class="line">    <span class="keywordtype">int</span>* code = r <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getPallete()) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getCanvas())</div>
<div class="line">                  <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getBrush(BrushType.SYSTEM)) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getColorCode());</div>
<div class="line">    if(!code) {</div>
<div class="line">        log(<span class="stringliteral">&quot;code is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> *code;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__indep_html_gab66a6cdf25aca4c8eeb667e884fc905a"><div class="ttname"><a href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a></div><div class="ttdeci">#define TO(fn)</div><div class="ttdef"><b>Definition</b> to.hpp:175</div></div>
</div><!-- fragment --><p><code>WHEN</code>, <code>TO</code>등 매크로에 대한 자세한 내용은 <a class="el" href="ae-architecture-overview.html">아키텍쳐와 설계</a> 문서를 참조하세요.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
구현 파일 (.cpp) 규칙</h2>
<h3><a class="anchor" id="autotoc_md155"></a>
me와 super 사용</h3>
<p>구현 파일에서는 클래스 이름 반복을 피하기 위해 <code>me</code>와 <code>super</code> typedef를 적극 활용합니다.</p>
<ul>
<li><b>me</b>: 현재 클래스 (<code>this</code>의 타입)</li>
<li><b>super</b>: 부모 클래스</li>
</ul>
<p>이를 위해 구현 파일 상단에 <code>BY_DEF_ME</code> 매크로를 사용해야 합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// myClass.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>by {</div>
<div class="line">    BY_DEF_ME(myClass)  <span class="comment">// typedef myClass me; 정의</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 클래스 이름 대신 me 사용</span></div>
<div class="line">    me::myClass() {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> me::init() {</div>
<div class="line">        super::init();  <span class="comment">// 부모 클래스의 init 호출</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md156"></a>
익명 네임스페이스</h3>
<p>파일 내부에서만 사용되는 헬퍼 함수나 상수는 <code>static</code> 대신 <b>익명 네임스페이스</b>(<code>namespace { ... }</code>)를 사용합니다.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">    <span class="comment">// 이 파일 안에서만 접근 가능</span></div>
<div class="line">    <span class="keyword">constexpr</span> ncnt MAX_RETRY = 3;</div>
<div class="line"> </div>
<div class="line">    std::string _makeTag(<span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;[&quot;</span> + name + <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> me::process() {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md157"></a>
기타 코딩 관습</h2>
<h3><a class="anchor" id="autotoc_md158"></a>
auto 사용</h3>
<p><code>auto</code>는 타입이 명확하거나 너무 길어질 때 사용합니다. 단, 포인터의 경우 <code>auto*</code>를 명시하여 포인터임을 드러내는 것을 권장합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 권장</span></div>
<div class="line"><span class="keyword">auto</span>* obj = <span class="keyword">new</span> myClass();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; item : container) { ... }</div>
<div class="line"><span class="keyword">auto</span> it = map.find(key);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ⚠️ 비권장 (타입이 모호함)</span></div>
<div class="line"><span class="keyword">auto</span> val = getValue();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md159"></a>
nullptr 사용</h3>
<p>포인터 초기화나 null 체크 시 <code>0</code>이나 <code>NULL</code> 대신 C++11 표준인 <code>nullptr</code>을 사용합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 권장</span></div>
<div class="line">node* ptr = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keywordflow">if</span>(ptr == <span class="keyword">nullptr</span>) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 금지</span></div>
<div class="line">node* ptr = 0;</div>
<div class="line">node* ptr = NULL;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md160"></a>
로컬 상수 네이밍</h3>
<p>함수 내부의 <code>constexpr</code> 상수라도 <code>UPPER_SNAKE_CASE</code>를 사용합니다.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> calculate() {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> MAX_BUFFER = 1024; <span class="comment">// ✅ 올바름</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> maxBuffer = 1024;      <span class="comment">// ❌ 틀림 (상수는 대문자)</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md162"></a>
문서화 표준</h1>
<h2><a class="anchor" id="autotoc_md163"></a>
Doxygen 주석 기본 규칙</h2>
<h3><a class="anchor" id="autotoc_md164"></a>
/** 스타일만 사용</h3>
<div class="fragment"><div class="line">// ✅ 올바른 스타일</div>
<div class="line">/**</div>
<div class="line"> * @brief 파일을 읽습니다</div>
<div class="line"> * @param path 파일 경로</div>
<div class="line"> * @return 파일 내용</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">// ❌ 금지된 스타일</div>
<div class="line">/// @brief 파일을 읽습니다</div>
<div class="line">/// @param path 파일 경로</div>
<div class="line">/// @return 파일 내용</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md165"></a>
@ 접두사 사용</h3>
<div class="fragment"><div class="line">// ✅ 올바른 예</div>
<div class="line">/**</div>
<div class="line"> * @brief 사용자를 생성합니다</div>
<div class="line"> * @param name 사용자 이름</div>
<div class="line"> * @return 생성된 사용자 포인터</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">// ❌ 잘못된 예 - \ 사용 금지</div>
<div class="line">/**</div>
<div class="line"> * \brief 사용자를 생성합니다   // 틀림!</div>
<div class="line"> * \param name 사용자 이름       // 틀림!</div>
<div class="line"> */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md166"></a>
파일 주석</h2>
<h3><a class="anchor" id="autotoc_md167"></a>
@file 태그</h3>
<p>모든 헤더 파일 최상단에 <code>@file</code>을 추가합니다. 클래스가 없고 <code>#define</code>이나 <code>typedef</code>만 있는 경우에만 파일 설명을 추가합니다.</p>
<div class="fragment"><div class="line">// 예제 1: 클래스가 있는 헤더 - 설명 불필요</div>
<div class="line">/** @file */</div>
<div class="line"> </div>
<div class="line">#pragma once</div>
<div class="line">#include &quot;base.h&quot;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * @ingroup core</div>
<div class="line"> * @brief AST 노드를 표현하는 클래스</div>
<div class="line"> */</div>
<div class="line">class astNode {</div>
<div class="line">    // ...</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">// 예제 2: 매크로만 있는 헤더 - 설명 필요</div>
<div class="line">/**</div>
<div class="line"> * @file</div>
<div class="line"> * 문자열 조작을 위한 유틸리티 매크로</div>
<div class="line"> *</div>
<div class="line"> * 문자열 연결, 변환, 포매팅 등의 기능을 제공하는</div>
<div class="line"> * 매크로 모음입니다.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">#pragma once</div>
<div class="line"> </div>
<div class="line">#define STR_CONCAT(a, b) a##b</div>
<div class="line">#define STR_TO_UPPER(s) /* ... */</div>
<div class="line">#define STR_FORMAT(fmt, ...) /* ... */</div>
</div><!-- fragment --><div class="fragment"><div class="line">// 예제 3: typedef만 있는 헤더 - 설명 필요</div>
<div class="line">/**</div>
<div class="line"> * @file</div>
<div class="line"> * 타입 별칭 정의</div>
<div class="line"> *</div>
<div class="line"> * 프로젝트 전반에서 사용되는 공통 타입 별칭을 정의합니다.</div>
<div class="line"> */</div>
<div class="line"> </div>
<div class="line">#pragma once</div>
<div class="line"> </div>
<div class="line">typedef unsigned int uint;</div>
<div class="line">typedef unsigned long ulong;</div>
<div class="line">typedef std::shared_ptr&lt;node&gt; nodePtr;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md168"></a>
클래스 주석</h2>
<p>클래스 주석에는 <code>@ingroup</code> (모듈 그룹), <code>@brief</code> (간단한 설명), <code>@details</code> (상세 설명) 태그를 포함합니다.</p>
<h3><a class="anchor" id="autotoc_md169"></a>
예제 1: 간단한 클래스</h3>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * @ingroup core</div>
<div class="line"> * @brief AST 노드의 기본 클래스</div>
<div class="line"> * @details 모든 AST 노드가 상속받는 베이스 클래스입니다.</div>
<div class="line"> * 노드 순회, 타입 체킹 등의 기본 기능을 제공합니다.</div>
<div class="line"> */</div>
<div class="line">class astNode {</div>
<div class="line">public:</div>
<div class="line">    virtual ~astNode() = default;</div>
<div class="line">    virtual void accept(visitor&amp; v) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md170"></a>
예제 2: 복잡한 클래스 - 여러 단락</h3>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * @ingroup memlite</div>
<div class="line"> * @brief 메모리 풀 관리자</div>
<div class="line"> * @details 고성능 메모리 할당을 위한 풀 기반 메모리 관리자입니다.</div>
<div class="line"> *</div>
<div class="line"> * 이 클래스는 고정 크기 메모리 블록을 미리 할당하고 재사용하여</div>
<div class="line"> * 빈번한 메모리 할당/해제의 오버헤드를 줄입니다.</div>
<div class="line"> *</div>
<div class="line"> * 각 풀은 특정 크기의 객체를 관리하며, 요청된 크기에 따라</div>
<div class="line"> * 적절한 풀을 자동으로 선택합니다. 스레드 안전성은 보장되지 않으므로</div>
<div class="line"> * 다중 스레드 환경에서는 외부 동기화가 필요합니다.</div>
<div class="line"> */</div>
<div class="line">class memoryPool {</div>
<div class="line">public:</div>
<div class="line">    void* allocate(size_t size);</div>
<div class="line">    void deallocate(void* ptr);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md171"></a>
함수 주석</h2>
<p>함수 주석에는 <code>@brief</code> (간단한 설명), <code>@param</code> (매개변수 설명), <code>@return</code> (반환값 설명) 태그를 필요에 따라 포함합니다.</p>
<div class="fragment"><div class="line">// 예제 1: 간단한 함수 - @param 생략 가능</div>
<div class="line">/** </div>
<div class="line"> * @brief 사용자 이름을 반환합니다</div>
<div class="line"> */</div>
<div class="line">std::string getName() const {</div>
<div class="line">    return _name;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// 예제 2: @param과 @return이 필요한 경우</div>
<div class="line">/**</div>
<div class="line"> * @brief 사용자를 생성하고 검증합니다</div>
<div class="line"> * @param username 사용자 이름 (3-20자의 영숫자)</div>
<div class="line"> * @param email 이메일 주소 (게스트는 nullptr 가능)</div>
<div class="line"> * @param age 나이 (0-150 범위)</div>
<div class="line"> * @return 성공 시 사용자 포인터, 실패 시 nullptr</div>
<div class="line"> */</div>
<div class="line">user* createUser(const std::string&amp; username, const char* email, int age);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md172"></a>
code 블록 사용</h2>
<p>복잡한 API나 사용법이 명확하지 않은 경우 예제 코드 제공해야 합니다.</p>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * @brief 설정 파일을 로드하고 파서를 초기화합니다</div>
<div class="line"> * @details 복잡한 초기화 순서가 필요하므로 아래 예제를 참고하세요</div>
<div class="line"> * @code</div>
<div class="line"> *  configLoader loader;</div>
<div class="line"> *  if(loader.load(&quot;config.stela&quot;)) {</div>
<div class="line"> *      parser p;</div>
<div class="line"> *      p.setConfig(loader.getConfig());</div>
<div class="line"> *      p.init();</div>
<div class="line"> *      auto ast = p.parse(&quot;main.by&quot;);</div>
<div class="line"> *  }</div>
<div class="line"> * @endcode</div>
<div class="line"> */</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md173"></a>
ref로 다른 코드 참조</h2>
<div class="fragment"><div class="line">/**</div>
<div class="line"> * @brief @ref parser 를 사용하여 파일을 파싱합니다</div>
<div class="line"> * @param p @ref parser 인스턴스</div>
<div class="line"> * @return 파싱된 @ref astNode</div>
<div class="line"> */</div>
<div class="line">astNode* parseWithParser(parser&amp; p);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md174"></a>
개발 노트는 Doxygen 밖에</h2>
<div class="fragment"><div class="line">// ✅ 올바른 예</div>
<div class="line">// TODO: 에러 핸들링 추가 필요</div>
<div class="line">// FIXME: 메모리 누수 존재</div>
<div class="line">// HACK: 임시 해결책, 나중에 리팩토링 필요</div>
<div class="line">/**</div>
<div class="line"> * @brief 파일을 읽습니다</div>
<div class="line"> * @param path 파일 경로</div>
<div class="line"> * @return 파일 내용</div>
<div class="line"> */</div>
<div class="line">std::string readFile(const std::string&amp; path);</div>
<div class="line"> </div>
<div class="line">// ❌ 잘못된 예</div>
<div class="line">/**</div>
<div class="line"> * @brief 파일을 읽습니다</div>
<div class="line"> * TODO: 에러 핸들링 추가 필요        // 틀림!</div>
<div class="line"> * FIXME: 메모리 누수 존재            // 틀림!</div>
<div class="line"> * @param path 파일 경로</div>
<div class="line"> * @return 파일 내용</div>
<div class="line"> */</div>
<div class="line">std::string readFile(const std::string&amp; path);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md175"></a>
자명한 코드에는 주석 금지</h2>
<div class="fragment"><div class="line">// ❌ 나쁜 예 - 불필요한 주석</div>
<div class="line">/** @brief 이름을 가져옵니다 */</div>
<div class="line">std::string getName() { return _name; }  // 너무 당연함!</div>
<div class="line"> </div>
<div class="line">/** @brief 나이를 설정합니다 */</div>
<div class="line">void setAge(int age) { _age = age; }     // 너무 당연함!</div>
<div class="line"> </div>
<div class="line">/** @brief i를 1 증가시킵니다 */</div>
<div class="line">i++;                                      // 너무 당연함!</div>
<div class="line"> </div>
<div class="line">// ✅ 좋은 예 - 주석 없음 (자명함)</div>
<div class="line">std::string getName() { return _name; }</div>
<div class="line">void setAge(int age) { _age = age; }</div>
<div class="line">i++;</div>
</div><!-- fragment --><div class="fragment"><div class="line">// ✅ 좋은 예 - 주석이 필요한 경우</div>
<div class="line">/**</div>
<div class="line"> * @brief 캐시를 고려하여 값을 가져옵니다</div>
<div class="line"> * @details 캐시에 값이 있으면 캐시에서, 없으면 DB에서 조회하고</div>
<div class="line"> * 결과를 캐시에 저장합니다. TTL은 5분입니다.</div>
<div class="line"> * @return 사용자 이름</div>
<div class="line"> */</div>
<div class="line">std::string getName() {</div>
<div class="line">    if(_cache.has(&quot;name&quot;))</div>
<div class="line">        return _cache.get(&quot;name&quot;);</div>
<div class="line"> </div>
<div class="line">    auto name = _db.query(&quot;SELECT name FROM users WHERE id=?&quot;, _id);</div>
<div class="line">    _cache.set(&quot;name&quot;, name, 300);  // 5분 TTL</div>
<div class="line">    return name;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md177"></a>
헤더 파일 포함</h1>
<p>헤더 파일을 포함할 때는 가능한 전방 선언(forward declaration)을 사용하여 불필요한 의존성을 줄이는 것을 권장합니다. 포인터나 참조로만 사용하는 타입은 전방 선언만으로 충분합니다.</p>
<div class="fragment"><div class="line"><span class="comment">// ✅ 전방 선언 사용</span></div>
<div class="line"><span class="comment">// file: moduleA.h</span></div>
<div class="line"><span class="keyword">class </span>moduleB;  <span class="comment">// 전방 선언</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>moduleA {</div>
<div class="line">    moduleB* _b;  <span class="comment">// 포인터만 사용하므로 전방 선언으로 충분</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ 불필요한 include</span></div>
<div class="line"><span class="comment">// file: moduleA.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;moduleB.h&quot;</span>  <span class="comment">// 포인터만 사용하는데 include - 비권장</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>moduleA {</div>
<div class="line">    moduleB* _b;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<p><b>다음 문서</b>: <a class="el" href="ae-architecture-overview.html">아키텍쳐와 설계</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
