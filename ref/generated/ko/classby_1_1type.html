<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: by::type 클래스 참조</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classby_1_1type.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 멤버 함수</a> &#124;
<a href="#pro-methods">Protected 멤버 함수</a> &#124;
<a href="classby_1_1type-members.html">모든 멤버 목록</a>  </div>
  <div class="headertitle"><div class="title">by::type 클래스 참조<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__meta.html">Meta</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Core class for runtime type information in byeol language  
 <a href="#details">더 자세히 ...</a></p>

<p><code>#include &lt;<a class="el" href="meta_2type_2type_8hpp_source.html">type.hpp</a>&gt;</code></p>
<div class="dynheader">
by::type에 대한 상속 다이어그램 : </div>
<div class="dyncontent">
 <div class="center">
  <img src="classby_1_1type.png" usemap="#by::type_map" alt=""/>
  <map id="by::type_map" name="by::type_map">
<area href="classby_1_1ttype_base.html" alt="by::ttypeBase&lt; T, tmetaTypeDef&lt; T, tifHasMetaTypeDef&lt; T &gt;::is &gt;::is &gt;" shape="rect" coords="0,56,413,80"/>
<area href="classby_1_1ntype.html" title="represents native c++ type system for byeol language" alt="by::ntype" shape="rect" coords="634,56,1047,80"/>
<area href="classby_1_1ttype_base_3_01void_00_01type_01_4.html" alt="by::ttypeBase&lt; void, type &gt;" shape="rect" coords="1057,56,1470,80"/>
<area href="classby_1_1ttype.html" title="Template type wrapper providing entry point for meta information" alt="by::ttype&lt; T &gt;" shape="rect" coords="0,112,413,136"/>
<area href="classby_1_1expr_1_1expr_type.html" title="Type information for expression nodes" alt="by::expr::exprType" shape="rect" coords="423,112,836,136"/>
<area href="classby_1_1mgd_type.html" title="Managed type for byeol objects" alt="by::mgdType" shape="rect" coords="846,112,1259,136"/>
<area href="classby_1_1func_type.html" title="Managed type for function objects in byeol language." alt="by::funcType" shape="rect" coords="846,168,1259,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 멤버 함수</h2></td></tr>
<tr class="memitem:a8e116c6818fe73d3e95dd0837ead65dd" id="r_a8e116c6818fe73d3e95dd0837ead65dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e116c6818fe73d3e95dd0837ead65dd">operator==</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;rhs) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:a8e116c6818fe73d3e95dd0837ead65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two type objects represent the same type.  <br /></td></tr>
<tr class="separator:a8e116c6818fe73d3e95dd0837ead65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888af33523fd29be58e6e7022771d72" id="r_ad888af33523fd29be58e6e7022771d72"><td class="memItemLeft" align="right" valign="top"><a id="ad888af33523fd29be58e6e7022771d72" name="ad888af33523fd29be58e6e7022771d72"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;rhs) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ad888af33523fd29be58e6e7022771d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c4d080fe332d8de1e8a9a50e95c32" id="r_a6a5c4d080fe332d8de1e8a9a50e95c32"><td class="memItemLeft" align="right" valign="top"><a id="a6a5c4d080fe332d8de1e8a9a50e95c32" name="a6a5c4d080fe332d8de1e8a9a50e95c32"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isTemplate</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a6a5c4d080fe332d8de1e8a9a50e95c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115db8266aea12d23d4e608cff26ff9" id="r_a3115db8266aea12d23d4e608cff26ff9"><td class="memItemLeft" align="right" valign="top"><a id="a3115db8266aea12d23d4e608cff26ff9" name="a3115db8266aea12d23d4e608cff26ff9"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isAbstract</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a3115db8266aea12d23d4e608cff26ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99bf858b97b4d2ffa1ba065bded31d1" id="r_ad99bf858b97b4d2ffa1ba065bded31d1"><td class="memItemLeft" align="right" valign="top"><a id="ad99bf858b97b4d2ffa1ba065bded31d1" name="ad99bf858b97b4d2ffa1ba065bded31d1"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getName</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ad99bf858b97b4d2ffa1ba065bded31d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ada2d17adf7691a294b682f4e340aeb" id="r_a0ada2d17adf7691a294b682f4e340aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ada2d17adf7691a294b682f4e340aeb">make</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="memdesc:a0ada2d17adf7691a294b682f4e340aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an instance to be refered this type.  <br /></td></tr>
<tr class="separator:a0ada2d17adf7691a294b682f4e340aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df468378fd698375f58c2bf56784a44" id="r_a9df468378fd698375f58c2bf56784a44"><td class="memTemplParams" colspan="2"><a id="a9df468378fd698375f58c2bf56784a44" name="a9df468378fd698375f58c2bf56784a44"></a>
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9df468378fd698375f58c2bf56784a44"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeAs</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a9df468378fd698375f58c2bf56784a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ec109b0b7977e5b3b25c33937f0f55" id="r_a54ec109b0b7977e5b3b25c33937f0f55"><td class="memItemLeft" align="right" valign="top"><a id="a54ec109b0b7977e5b3b25c33937f0f55" name="a54ec109b0b7977e5b3b25c33937f0f55"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">ncnt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a54ec109b0b7977e5b3b25c33937f0f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656d9a54739f8457195da12567e4410a" id="r_a656d9a54739f8457195da12567e4410a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a656d9a54739f8457195da12567e4410a">init</a> ()</td></tr>
<tr class="memdesc:a656d9a54739f8457195da12567e4410a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes type metadata and constructs class hierarchy  <br /></td></tr>
<tr class="separator:a656d9a54739f8457195da12567e4410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aea9d43b8048d1f7634bd32b2986539" id="r_a6aea9d43b8048d1f7634bd32b2986539"><td class="memItemLeft" align="right" valign="top"><a id="a6aea9d43b8048d1f7634bd32b2986539" name="a6aea9d43b8048d1f7634bd32b2986539"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rel</b> ()</td></tr>
<tr class="separator:a6aea9d43b8048d1f7634bd32b2986539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8401aa7c0cbdc5256216d717a3e9e83d" id="r_a8401aa7c0cbdc5256216d717a3e9e83d"><td class="memItemLeft" align="right" valign="top"><a id="a8401aa7c0cbdc5256216d717a3e9e83d" name="a8401aa7c0cbdc5256216d717a3e9e83d"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSuper</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a8401aa7c0cbdc5256216d717a3e9e83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd1bbbf76fd5b8f696fd28724b8dadf" id="r_aadd1bbbf76fd5b8f696fd28724b8dadf"><td class="memItemLeft" align="right" valign="top"><a id="aadd1bbbf76fd5b8f696fd28724b8dadf" name="aadd1bbbf76fd5b8f696fd28724b8dadf"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>isInit</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:aadd1bbbf76fd5b8f696fd28724b8dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c802ba295c8b05a322a118d2e16a7f" id="r_a38c802ba295c8b05a322a118d2e16a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> types &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38c802ba295c8b05a322a118d2e16a7f">getLeafs</a> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:a38c802ba295c8b05a322a118d2e16a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all most derived classes (leaf nodes) from this class  <br /></td></tr>
<tr class="separator:a38c802ba295c8b05a322a118d2e16a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285bdea7b4e52f39bcbc7c0476acdcc6" id="r_a285bdea7b4e52f39bcbc7c0476acdcc6"><td class="memItemLeft" align="right" valign="top"><a id="a285bdea7b4e52f39bcbc7c0476acdcc6" name="a285bdea7b4e52f39bcbc7c0476acdcc6"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSubs</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a285bdea7b4e52f39bcbc7c0476acdcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58b5a57bda6648e641863309a31a030" id="r_ac58b5a57bda6648e641863309a31a030"><td class="memItemLeft" align="right" valign="top"><a id="ac58b5a57bda6648e641863309a31a030" name="ac58b5a57bda6648e641863309a31a030"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSupers</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ac58b5a57bda6648e641863309a31a030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88ce436da22fc488bf6865cdd1b9ad3" id="r_ab88ce436da22fc488bf6865cdd1b9ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab88ce436da22fc488bf6865cdd1b9ad3">isSuper</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:ab88ce436da22fc488bf6865cdd1b9ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this type is a super class of the given type  <br /></td></tr>
<tr class="separator:ab88ce436da22fc488bf6865cdd1b9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5861c7640f1061ce4990771f289503d" id="r_ad5861c7640f1061ce4990771f289503d"><td class="memItemLeft" align="right" valign="top"><a id="ad5861c7640f1061ce4990771f289503d" name="ad5861c7640f1061ce4990771f289503d"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:ad5861c7640f1061ce4990771f289503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebe80b68992e499b73596e5f584dc39" id="r_a4ebe80b68992e499b73596e5f584dc39"><td class="memTemplParams" colspan="2"><a id="a4ebe80b68992e499b73596e5f584dc39" name="a4ebe80b68992e499b73596e5f584dc39"></a>
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4ebe80b68992e499b73596e5f584dc39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSuper</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a4ebe80b68992e499b73596e5f584dc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7511efc747aeb12a6b3fc2e2971eb31f" id="r_a7511efc747aeb12a6b3fc2e2971eb31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7511efc747aeb12a6b3fc2e2971eb31f">isSub</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:a7511efc747aeb12a6b3fc2e2971eb31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this type is a sub class of the given type  <br /></td></tr>
<tr class="separator:a7511efc747aeb12a6b3fc2e2971eb31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a9d2698988f989482c16eedb21341" id="r_ad69a9d2698988f989482c16eedb21341"><td class="memItemLeft" align="right" valign="top"><a id="ad69a9d2698988f989482c16eedb21341" name="ad69a9d2698988f989482c16eedb21341"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:ad69a9d2698988f989482c16eedb21341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dc9f2bc7369d5f877c18dd1f5817f8" id="r_aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memTemplParams" colspan="2"><a id="aa5dc9f2bc7369d5f877c18dd1f5817f8" name="aa5dc9f2bc7369d5f877c18dd1f5817f8"></a>
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSub</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:aa5dc9f2bc7369d5f877c18dd1f5817f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f76be2976586efd88e5f13b22474a5" id="r_a03f76be2976586efd88e5f13b22474a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f76be2976586efd88e5f13b22474a5">getStatic</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(_getStatic()) <a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">nchar</a> *getMetaTypeName() <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:a03f76be2976586efd88e5f13b22474a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get meta type name for efficient type checking  <br /></td></tr>
<tr class="separator:a03f76be2976586efd88e5f13b22474a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected 멤버 함수</h2></td></tr>
<tr class="memitem:aa25d13f72a4e5bcd95dd9cd9e3f4f192" id="r_aa25d13f72a4e5bcd95dd9cd9e3f4f192"><td class="memItemLeft" align="right" valign="top"><a id="aa25d13f72a4e5bcd95dd9cd9e3f4f192" name="aa25d13f72a4e5bcd95dd9cd9e3f4f192"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getSubs</b> ()=0</td></tr>
<tr class="separator:aa25d13f72a4e5bcd95dd9cd9e3f4f192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a5feac948fd26c73fbef32a760bc8" id="r_a978a5feac948fd26c73fbef32a760bc8"><td class="memItemLeft" align="right" valign="top"><a id="a978a5feac948fd26c73fbef32a760bc8" name="a978a5feac948fd26c73fbef32a760bc8"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> types &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getSupers</b> ()=0</td></tr>
<tr class="separator:a978a5feac948fd26c73fbef32a760bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebc5bef57dadbc91b0d8e5809cea50" id="r_a90ebc5bef57dadbc91b0d8e5809cea50"><td class="memItemLeft" align="right" valign="top"><a id="a90ebc5bef57dadbc91b0d8e5809cea50" name="a90ebc5bef57dadbc91b0d8e5809cea50"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getStatic</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a90ebc5bef57dadbc91b0d8e5809cea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa428c957e61ce218d377e395174cd2a" id="r_afa428c957e61ce218d377e395174cd2a"><td class="memItemLeft" align="right" valign="top"><a id="afa428c957e61ce218d377e395174cd2a" name="afa428c957e61ce218d377e395174cd2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setInit</b> (<a class="el" href="structby_1_1no_wrap.html">nbool</a> <a class="el" href="structby_1_1no_wrap.html">newState</a>)</td></tr>
<tr class="separator:afa428c957e61ce218d377e395174cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229cdbfb48168e0090f4c022a71f4a4" id="r_a8229cdbfb48168e0090f4c022a71f4a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8229cdbfb48168e0090f4c022a71f4a4">_onAddSubClass</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;<a class="el" href="structby_1_1no_wrap.html">subClass</a>)</td></tr>
<tr class="memdesc:a8229cdbfb48168e0090f4c022a71f4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook method called when a new subclass is registered with this type.  <br /></td></tr>
<tr class="separator:a8229cdbfb48168e0090f4c022a71f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a46a899de5d4cc2a60bf9867c5e3a7" id="r_a84a46a899de5d4cc2a60bf9867c5e3a7"><td class="memItemLeft" align="right" valign="top"><a id="a84a46a899de5d4cc2a60bf9867c5e3a7" name="a84a46a899de5d4cc2a60bf9867c5e3a7"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> types **&#160;</td><td class="memItemRight" valign="bottom"><b>_onGetLeafs</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:a84a46a899de5d4cc2a60bf9867c5e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa355f7b7fe931edc5fb899a51352aac9" id="r_aa355f7b7fe931edc5fb899a51352aac9"><td class="memItemLeft" align="right" valign="top"><a id="aa355f7b7fe931edc5fb899a51352aac9" name="aa355f7b7fe931edc5fb899a51352aac9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setLeafs</b> (types *<a class="el" href="structby_1_1no_wrap.html">newLeafs</a>) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:aa355f7b7fe931edc5fb899a51352aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e01bb05c48c7eae5b7f8f951f684fb2" id="r_a7e01bb05c48c7eae5b7f8f951f684fb2"><td class="memItemLeft" align="right" valign="top"><a id="a7e01bb05c48c7eae5b7f8f951f684fb2" name="a7e01bb05c48c7eae5b7f8f951f684fb2"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_getNativeName</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a7e01bb05c48c7eae5b7f8f951f684fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">상세한 설명</h2>
<div class="textblock"><p>Core class for runtime type information in byeol language </p>
<p>The central class of the meta module. Provides fundamental type information APIs.</p>
<h1><a class="anchor" id="basic_type_identification"></a>
Basic type identification</h1>
<ul>
<li>isTemplate(): Returns whether this is a template class</li>
<li>isAbstract(): Returns whether this is an abstract class</li>
<li>getName(): Returns class name (demangled)</li>
</ul>
<h1><a class="anchor" id="class_hierarchy_information"></a>
Class hierarchy information</h1>
<ul>
<li>getSupers(): Returns list of super classes, with direct parent at the end</li>
<li>getSubs(): Returns list of sub classes, with closest descendants first</li>
<li>isSuper(const type&amp; rhs): Checks if this is a super class of rhs</li>
<li>isSub(const type&amp; rhs): Checks if this is a sub class of rhs</li>
</ul>
<p>Performance note: <a class="el" href="#ab88ce436da22fc488bf6865cdd1b9ad3" title="Checks if this type is a super class of the given type">isSuper()</a> and <a class="el" href="#a7511efc747aeb12a6b3fc2e2971eb31f" title="Checks if this type is a sub class of the given type">isSub()</a> are more efficient than dynamic_cast. While dynamic_cast typically loops through vtables, the meta module uses a tier algorithm that compares tier values and char* addresses for O(1) type checking.</p>
<h1><a class="anchor" id="instance_creation"></a>
Instance creation</h1>
<ul>
<li><a class="el" href="#a0ada2d17adf7691a294b682f4e340aeb" title="create an instance to be refered this type.">make()</a>: Creates instance using default constructor. Returns nullptr if no default constructor exists.</li>
</ul>
<h1><a class="anchor" id="meta_type_information_management"></a>
Meta type information management</h1>
<ul>
<li><a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">init()</a>: Initializes type information</li>
<li>rel(): Releases type information</li>
</ul>
<p>These are typically handled automatically via BY_INIT_META macro and rarely need direct invocation.</p>
<h1><a class="anchor" id="how_meta_information_is_generated"></a>
How meta information is generated</h1>
<p>Type information like isTemplate(), isAbstract(), and getName() is filled by ttypeBase&lt;T&gt; through metaprogramming. The purpose of <a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">type::init()</a> is to construct the class hierarchy.</p>
<p>The hierarchy is built using the constraint that "all classes must define super
as a typedef". With super defined for all classes, ttype&lt;super&gt;().<a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">init()</a> can be called, enabling recursive class hierarchy construction:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">nbool</a> <a class="code hl_function" href="#a656d9a54739f8457195da12567e4410a">type::init</a>() {</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code hl_struct" href="structby_1_1no_wrap.html">_isInit</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">_isInit</a> = <span class="keyword">true</span>; <span class="comment">// Executes only once</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classby_1_1type.html">type</a>&amp; super = (<a class="code hl_class" href="classby_1_1type.html">type</a>&amp;) getSuper();</div>
<div class="line">    super.<a class="code hl_function" href="#a656d9a54739f8457195da12567e4410a">init</a>(); <span class="comment">// Recursively calls parent&#39;s init</span></div>
<div class="line">                  <span class="comment">// Eventually reaches adam, which has no parent</span></div>
<div class="line"> </div>
<div class="line">    types&amp; <a class="code hl_struct" href="structby_1_1no_wrap.html">mySupers</a> = getSupers();</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">mySupers</a> = super.getSupers();</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">mySupers</a>.push_back(&amp;super);</div>
<div class="line">}</div>
<div class="ttc" id="aclassby_1_1type_html"><div class="ttname"><a href="classby_1_1type.html">by::type</a></div><div class="ttdoc">Core class for runtime type information in byeol language</div><div class="ttdef"><b>Definition</b> type.hpp:100</div></div>
<div class="ttc" id="aclassby_1_1type_html_a656d9a54739f8457195da12567e4410a"><div class="ttname"><a href="#a656d9a54739f8457195da12567e4410a">by::type::init</a></div><div class="ttdeci">virtual nbool init()</div><div class="ttdoc">Initializes type metadata and constructs class hierarchy</div></div>
<div class="ttc" id="astructby_1_1no_wrap_html"><div class="ttname"><a href="structby_1_1no_wrap.html">by::noWrap</a></div><div class="ttdoc">Rich logging support with polymorphic type conversion</div><div class="ttdef"><b>Definition</b> richLog.hpp:34</div></div>
</div><!-- fragment --><h1><a class="anchor" id="automatic_meta_information_generation"></a>
Automatic meta information generation</h1>
<p>Type objects are initialized via <a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">init()</a> calls, but manually calling <a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">init()</a> for every class would be inefficient. The BY_INIT_META macro solves this by using BY_INITIATOR to execute <a class="el" href="#a656d9a54739f8457195da12567e4410a" title="Initializes type metadata and constructs class hierarchy">init()</a> before main() via static object initialization with lambda functions.</p>
<p>The constraint is that each class declaration must include BY_INIT_META(MyClass). These meta DSL-style macros are executed through the BY macro convention, and core module adds additional meta DSL macros, so use BY(CLASS()) or BY(ADT()) instead of calling BY_INIT_META directly.</p>
<h1><a class="anchor" id="adding_custom_meta_information"></a>
Adding custom meta information</h1>
<p>While type provides substantial type information, language implementations like byeol may need additional information like parameters or return types. You might think to inherit from type, but since the user entry point must always be ttype&lt;T&gt;, and you cannot modify ttype&lt;T&gt; code from modules depending on meta, inheritance isn't possible. Instead, inject custom meta types.</p>
<p>The core code is in ttypeBase&lt;T&gt;: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">template &lt;typename T, typename S = typename tmetaTypeDef&lt;T&gt;::is</a>&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classby_1_1ttype_base.html">ttypeBase</a>: <span class="keyword">public</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">S</a> { }</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">template &lt;typename T, nbool hasMeta = tifHasMetaTypeDef&lt;T&gt;::is</a>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structby_1_1tmeta_type_def.html">tmetaTypeDef</a> { <span class="keyword">using </span>is = <a class="code hl_class" href="classby_1_1type.html">type</a>; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>tmetaTypeDef&lt;T, true&gt; { <span class="keyword">using </span>is = <span class="keyword">typename</span> T::metaType; };</div>
<div class="ttc" id="aclassby_1_1ttype_base_html"><div class="ttname"><a href="classby_1_1ttype_base.html">by::ttypeBase</a></div><div class="ttdoc">Base class for template type metadata</div><div class="ttdef"><b>Definition</b> ttypeBase.hpp:19</div></div>
<div class="ttc" id="astructby_1_1tmeta_type_def_html"><div class="ttname"><a href="structby_1_1tmeta_type_def.html">by::tmetaTypeDef</a></div><div class="ttdoc">Meta type definition selector</div><div class="ttdef"><b>Definition</b> rtti.hpp:164</div></div>
</div><!-- fragment --><p><a class="el" href="structby_1_1tmeta_type_def.html" title="Meta type definition selector">tmetaTypeDef</a> returns T::metaType if it exists, otherwise returns type. ttype inherits from <a class="el" href="classby_1_1ttype_base.html" title="Base class for template type metadata">ttypeBase</a>, which inherits from tmetaTypeDef&lt;T&gt;::is. When calling ttype&lt;T&gt;, if class T defines <code>typedef metaType MyType</code>, the ttype&lt;T&gt; object will be based on MyType.</p>
<p>This feature is actually used in the core module to inject ntype. See <a class="el" href="classby_1_1ntype.html">ntype</a> for details. </p>
</div><h2 class="groupheader">멤버 함수 문서화</h2>
<a id="a8229cdbfb48168e0090f4c022a71f4a4" name="a8229cdbfb48168e0090f4c022a71f4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8229cdbfb48168e0090f4c022a71f4a4">&#9670;&#160;</a></span>_onAddSubClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> void by::type::_onAddSubClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;</td>          <td class="paramname"><span class="paramname"><em>subClass</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook method called when a new subclass is registered with this type. </p>
<p>Derived type classes can override this method to perform custom actions (e.g., updating internal structures or caches) whenever a new <code>subClass</code> is added to its hierarchy. </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">subClass</td><td>The new subclass being added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38c802ba295c8b05a322a118d2e16a7f" name="a38c802ba295c8b05a322a118d2e16a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c802ba295c8b05a322a118d2e16a7f">&#9670;&#160;</a></span>getLeafs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">const</a> types &amp; by::type::getLeafs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all most derived classes (leaf nodes) from this class </p>
<dl class="section return"><dt>반환값</dt><dd>Vector of type pointers representing all leaf classes in hierarchy </dd></dl>

</div>
</div>
<a id="a03f76be2976586efd88e5f13b22474a5" name="a03f76be2976586efd88e5f13b22474a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f76be2976586efd88e5f13b22474a5">&#9670;&#160;</a></span>getStatic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp; by::type::getStatic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get meta type name for efficient type checking </p>
<p>This returns metaTypename. metaTypename can be used like 'dynamic_cast&lt;yourType&gt;'. as you may know, c++'s dynamic_cast is slow. because normally compilers tries to loop in order to figure out which type is fit to given your type parameter. 'meta' library, however, uses 'tier' algorithm and it's O(1), so it's faster.</p>
<p>you can use your own metaType to represent more data on type class. for instance, 'core' module uses 'ntype' custom type class. but in that case, when you compare custom type class, you must compare extended data to 'rhs' variable to base type class, 'type'.</p>
<p>so how can you know that 'type' is actually instance of your derived custom type class in 'tier' algorithm? please don't think about 'dynamic_cast'. it'll vanish our effectiveness to use 'tier' algorithm. that's why I make 'getMetaTypeName()' func.</p>
<dl class="section return"><dt>반환값</dt><dd>static literal c-style string for meta type name. so you are able to use c-style casting if address of 'rhs' variables's getMetaTypeName() isn just same to yours. <div class="fragment"><div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">yourType</a>&amp; <a class="code hl_struct" href="structby_1_1no_wrap.html">a</a> = ....;</div>
<div class="line"><a class="code hl_class" href="classby_1_1type.html">type</a>&amp; rhs = ....;</div>
<div class="line"><span class="keywordflow">if</span>(<a class="code hl_struct" href="structby_1_1no_wrap.html">a</a>.getMetaTypeName() != rhs.getMetaTypeName()) <span class="keywordflow">return</span>;</div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">yourType</a>&amp; <a class="code hl_struct" href="structby_1_1no_wrap.html">rhsCasted</a> = (<a class="code hl_struct" href="structby_1_1no_wrap.html">yourType</a>&amp;) rhs;</div>
<div class="line"> </div>
<div class="line">...now <a class="code hl_struct" href="structby_1_1no_wrap.html">you</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">can</a> <span class="keywordflow">do</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">something</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">on</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">yourType</a><span class="stringliteral">&#39;s data...</span></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a656d9a54739f8457195da12567e4410a" name="a656d9a54739f8457195da12567e4410a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656d9a54739f8457195da12567e4410a">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a> by::type::init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes type metadata and constructs class hierarchy </p>
<dl class="section return"><dt>반환값</dt><dd>true on success, false if already initialized </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Recursively initializes super class hierarchy. Automatically called via BY_INIT_META macro before main(). Sets up super/sub relationships. </dd></dl>

</div>
</div>
<a id="a7511efc747aeb12a6b3fc2e2971eb31f" name="a7511efc747aeb12a6b3fc2e2971eb31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7511efc747aeb12a6b3fc2e2971eb31f">&#9670;&#160;</a></span>isSub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::type::isSub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this type is a sub class of the given type </p>
<dl class="section return"><dt>반환값</dt><dd>true if this is a sub class of it, false otherwise </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Uses O(1) tier algorithm. Implemented as it.isSuper(*this). </dd></dl>

</div>
</div>
<a id="ab88ce436da22fc488bf6865cdd1b9ad3" name="ab88ce436da22fc488bf6865cdd1b9ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88ce436da22fc488bf6865cdd1b9ad3">&#9670;&#160;</a></span>isSuper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a> by::type::isSuper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this type is a super class of the given type </p>
<dl class="section return"><dt>반환값</dt><dd>true if this is a super class of it, false otherwise </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Uses O(1) tier algorithm comparing tier values, much faster than dynamic_cast which typically loops through vtables. </dd></dl>

</div>
</div>
<a id="a0ada2d17adf7691a294b682f4e340aeb" name="a0ada2d17adf7691a294b682f4e340aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ada2d17adf7691a294b682f4e340aeb">&#9670;&#160;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> void * by::type::make </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an instance to be refered this type. </p>
<dl class="section remark"><dt>Remarks</dt><dd>available when the type defines a ctor without any params. </dd></dl>
<dl class="section return"><dt>반환값</dt><dd>return an address of new instance, however, if ctor without any params isn't defined, then returns null. </dd></dl>

<p><a class="el" href="classby_1_1mgd_type.html#aef1673945bda18fb8287deb0905871a1">by::mgdType</a>, <a class="el" href="classby_1_1ttype_base_3_01void_00_01type_01_4.html#ac30f3b021276b3d284b2ff975da7588c">by::ttypeBase&lt; void, type &gt;</a>에서 구현되었습니다.</p>

</div>
</div>
<a id="a8e116c6818fe73d3e95dd0837ead65dd" name="a8e116c6818fe73d3e95dd0837ead65dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e116c6818fe73d3e95dd0837ead65dd">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a> by::type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two type objects represent the same type. </p>
<p>This comparison typically checks if the underlying type information (e.g., name, template status) is identical. </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other type object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>반환값</dt><dd>true if both type objects represent the same type, false otherwise. </dd></dl>

</div>
</div>
<hr/>이 클래스에 대한 문서화 페이지는 다음의 파일로부터 생성되었습니다.:<ul>
<li>/home/runner/work/byeol/byeol/module/meta/type/<a class="el" href="meta_2type_2type_8hpp_source.html">type.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
