<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: stela 모듈 - 경량 설정 언어</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'검색','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ah-architecture-stela.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">stela 모듈 - 경량 설정 언어 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__home_runner_work_byeol_byeol_doc_ref_ko_ah_architecture_stela"></a> <a class="el" href="group__stela.html">Stela</a> 모듈은 byeol 언어의 경량화된 버전으로, manifest나 옵션과 같은 특수 목적용 언어입니다. 트리 구조로 설정 데이터를 표현하며, <a class="el" href="group__core.html">Core</a> 모듈의 <a class="el" href="classby_1_1node.html">node</a> 와 유사한 구조를 가집니다.</p>
<p ><b>참고</b>: <a class="el" href="group__stela.html">Stela</a> 언어는 byeol 언어보다 덜 복잡하므로, **<a class="el" href="group__core.html">Core</a> 모듈의 byeol 파서를 보기 전에 <a class="el" href="group__stela.html">Stela</a> 파서 코드를 먼저 살펴볼 것을 권장합니다**. 파서의 기본 구조와 동작 방식을 이해하는데 더 적합해요.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md178"></a>
stela 언어의 기본 기능</h1>
<h2><a class="anchor" id="autotoc_md179"></a>
stela 클래스</h2>
<p ><a class="el" href="classby_1_1stela.html">stela</a> 클래스는 <a class="el" href="group__stela.html">Stela</a> 모듈의 가장 기본 단위가 되는 클래스로, 다음의 기능을 제공합니다:</p>
<ol type="1">
<li><b>타입 변환 API</b>: asInt(), asChar(), asStr(), asBool() 등 기본 타입으로 변환을 시도합니다.</li>
<li><b>값이 있는 경우</b>: <a class="el" href="classby_1_1val_stela.html">valStela</a> 의 API가 실행되며, 적절한 값으로 변환됩니다. 예를들어 <code>verStela(22)</code>의 경우 <code>asStr()</code>을 하면 <code>std::string("22")</code>가 반환됩니다.</li>
<li><b>값이 없는 경우</b>: <a class="el" href="classby_1_1nul_stela.html">nulStela</a> 로 표현됩니다. 이 경우 어떠한 타입변환 시도에도 기본값(빈 문자열 혹은 0)이 반환됩니다.</li>
<li><b>버전 타입</b>: major, minor, patch 버전을 가지고 있으며, 범위로도 표현이 가능합니다.</li>
<li><b>트리 구조</b>: <a class="el" href="classby_1_1stela.html">stela</a> 는 또다른 <a class="el" href="classby_1_1stela.html">stela</a> 를 자식으로 둘 수 있습니다. 각 <a class="el" href="classby_1_1stela.html">stela</a> 객체마다 이름이 존재하므로, 자식을 찾을 때는 이름으로 검색하거나 순회합니다. 주어진 이름에 맞는 자식이 없는 경우 <a class="el" href="classby_1_1nul_stela.html">nulStela</a> 가 반환됩니다.</li>
</ol>
<p ><b>사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const std::string script = R&quot;SRC(</div>
<div class="line">    def man</div>
<div class="line">        dummy := 5</div>
<div class="line">        name := &quot;dark souls&quot;</div>
<div class="line">        ver := 1.0.8</div>
<div class="line">)SRC&quot;;</div>
<div class="line"> </div>
<div class="line">root = stelaParser().parse(script);</div>
<div class="line">ASSERT_TRUE(root);</div>
<div class="line"> </div>
<div class="line">stela&amp; man = root-&gt;sub(&quot;man&quot;);</div>
<div class="line">stela&amp; name = man[&quot;name&quot;];</div>
<div class="line">ASSERT_TRUE(name);</div>
<div class="line"> </div>
<div class="line">ASSERT_STREQ(name.asStr().c_str(), &quot;dark souls&quot;);</div>
<div class="line"> </div>
<div class="line">verStela&amp; ver = man[&quot;ver&quot;].cast&lt;verStela&gt;() OR_ASSERT(ver);</div>
<div class="line">ASSERT_STREQ(ver.asStr().c_str(), &quot;1.0.8&quot;);</div>
<div class="line">ASSERT_EQ(ver.asMajor(), 1);</div>
<div class="line">ASSERT_EQ(ver.asMinor(), 0);</div>
<div class="line">ASSERT_EQ(ver.asFix(), 8);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md180"></a>
nulStela 클래스 - Null Object 패턴</h2>
<p ><a class="el" href="classby_1_1nul_stela.html">nulStela</a> 는 <a class="el" href="classby_1_1stela.html">stela</a> 로 자식 객체를 가져올 때 보통 이름으로 가져오는데, 해당 이름을 가진 자식 객체가 없을 경우 대신 반환됩니다.</p>
<p ><a class="el" href="classby_1_1nul_stela.html">nulStela</a> 는 <b>null object 패턴</b>을 구현한 것으로, 해당 객체에 대해 값 변환을 요청할 경우 항상 해당 타입의 기본값이 반환됩니다. <a class="el" href="classby_1_1stela.html">stela</a> 객체가 <a class="el" href="classby_1_1nul_stela.html">nulStela</a> 인지 확인하려면 <code>isExist()</code> 혹은 <code>operator bool()</code>이 false인지 확인하면 됩니다.</p>
<p ><b>사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">stela&amp; config = root-&gt;sub(&quot;config&quot;);</div>
<div class="line">stela&amp; device = config[&quot;device&quot;];</div>
<div class="line">stela&amp; notExist = config[&quot;notExistKey&quot;];  // nulStela 반환</div>
<div class="line"> </div>
<div class="line">// Null Object 패턴으로 안전하게 처리</div>
<div class="line">if(notExist) {  // operator bool() - false 반환</div>
<div class="line">    // 이 블록은 실행되지 않음</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// 또는</div>
<div class="line">if(!notExist.isExist()) {  // true</div>
<div class="line">    std::cout &lt;&lt; &quot;Key does not exist&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// 값 변환 시도 - 기본값 반환</div>
<div class="line">std::string str = notExist.asStr();  // &quot;&quot; (빈 문자열)</div>
<div class="line">int val = notExist.asInt();          // 0</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md181"></a>
valStela 클래스 - Scalar 값 표현</h2>
<p ><a class="el" href="classby_1_1val_stela.html">valStela</a> 는 <a class="el" href="classby_1_1nul_stela.html">nulStela</a> 와 달리 int, float, string 등 <b>scalar 타입</b>을 가지고 있는 <a class="el" href="classby_1_1stela.html">stela</a> 입니다. 내부적으로는 기본 문자열로 값을 가지고 있는 상태이며, <code>asInt()</code>와 같은 타입변환 요청에 따라서 적절한 타입으로 변경할 수 있습니다.</p>
<p >만약 타입변환에 실패한다면, 예외가 발생하니 주의하세요.</p>
<h2><a class="anchor" id="autotoc_md182"></a>
verStela 클래스 - 버전 타입</h2>
<p ><a class="el" href="classby_1_1ver_stela.html">verStela</a> 는 <a class="el" href="classby_1_1val_stela.html">valStela</a> 와 비슷하게 <b>version</b>이라는 타입의 값을 가지고 있는 <a class="el" href="classby_1_1stela.html">stela</a> 입니다.</p>
<p ><b>version 타입</b></p>
<p ><a class="el" href="classby_1_1stela.html">stela</a> 언어는 byeol 언어의 경량화된 언어로, manifest나 옵션과 같은 특수 목적용 언어입니다. version 타입은 <code>major.minor.fix</code>의 3가지 변수를 가지고 있으며 범위 표현 또한 가능한 타입입니다.</p>
<p ><b>사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const std::string script = R&quot;SRC(</div>
<div class="line">    def package</div>
<div class="line">        name := &quot;mylib&quot;</div>
<div class="line">        version := 2.1.5</div>
<div class="line">        minVersion := 1.0.0</div>
<div class="line">        maxVersion := 3.0.0</div>
<div class="line">)SRC&quot;;</div>
<div class="line"> </div>
<div class="line">stela&amp; root = stelaParser().parse(script);</div>
<div class="line">stela&amp; pkg = root-&gt;sub(&quot;package&quot;);</div>
<div class="line"> </div>
<div class="line">// 버전 정보 추출</div>
<div class="line">verStela&amp; ver = pkg[&quot;version&quot;].cast&lt;verStela&gt;();</div>
<div class="line">ASSERT_EQ(ver.asMajor(), 2);</div>
<div class="line">ASSERT_EQ(ver.asMinor(), 1);</div>
<div class="line">ASSERT_EQ(ver.asFix(), 5);</div>
<div class="line">ASSERT_STREQ(ver.asStr().c_str(), &quot;2.1.5&quot;);</div>
<div class="line"> </div>
<div class="line">// 버전 범위 체크 (범위 표현 가능)</div>
<div class="line">verStela&amp; minVer = pkg[&quot;minVersion&quot;].cast&lt;verStela&gt;();</div>
<div class="line">verStela&amp; maxVer = pkg[&quot;maxVersion&quot;].cast&lt;verStela&gt;();</div>
<div class="line">// 1.0.0 &lt;= 2.1.5 &lt;= 3.0.0 범위 확인 가능</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md184"></a>
stela 파서 구조</h1>
<h2><a class="anchor" id="autotoc_md185"></a>
stelaParser 클래스 - 파싱 진입점</h2>
<p ><a class="el" href="classby_1_1stela_parser.html">stelaParser</a> 클래스는 stela 파싱 컴포넌트의 진입점 역할을 합니다. <code>parse()</code> 나 <code>parseFromFile()</code>을 통해서 스크립트를 지정하면 파싱된 결과가 <a class="el" href="classby_1_1stela.html">stela</a> 구조로 반환됩니다.</p>
<p ><b>byeol 파서와 유사한 구조</b></p>
<p ><a class="el" href="group__stela.html">Stela</a> 언어 자체가 byeol의 특화된 언어이므로 파서 또한 byeol 언어의 파서를 기반으로 하고 있습니다. byeol 파서 대비 덜 복잡하여 파서의 기본 동작을 이해하기 좋습니다.</p>
<p ><b>scanner - bison - stelaParser 구조</b></p>
<p >flex와 bison을 사용하고 있으며 flex는 lowscanner로, bison은 lowparser로 각각 명명합니다. 이 lowlevel scanner, parser는 parser 컴포넌트 안에만 존재하는 것으로 외부에서는 일절 노출 되지 않습니다.</p>
<p ><a class="el" href="classby_1_1stela_parser.html#a99b018f229e9ba106315b0fcda3ae9d5">parse()</a> 가 실행되면 lowscanner를 실행시키고, lowscanner는 토큰을 뜯어서 lowparser에게 넘기고, lowparser는 받은 토큰에 대해 rule이 match 되면 그 이벤트를 다시 <a class="el" href="classby_1_1stela_parser.html">stelaParser</a> 에게 넘깁니다.</p>
<p >그러므로 <a class="el" href="classby_1_1stela_parser.html">stelaParser</a> 의 <b><code>on</code>으로 시작하는 함수들</b>은 그러한 이벤트를 handling 하는 함수로, 실제로 어떻게 node를 생성해서 ast를 구축하는지를 정의합니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md187"></a>
Indentation 처리</h1>
<h2><a class="anchor" id="autotoc_md188"></a>
indentation rule</h2>
<p >stela 언어는 byeol 언어와 마찬가지로 <b>offside rule</b>을 적용하므로, indentation에 매우 민감합니다. 일반적인 언어와 달리, 개행직후로 몇개의 공백이 있는가를 count 할 수 있어야 하며, indentation이 확정되어 해당 코드라인이 어느 scope에 속한 것인지가 확정되면 이후로는 공백을 무시해야 합니다.</p>
<p >다음 byeol 언어의 예제를 보고, 이 문제에 대해 더 생각해봅시다:</p>
<div class="fragment"><div class="line">@style: language-byeol verified</div>
<div class="line">def A</div>
<div class="line">    foo(val int) void</div>
<div class="line">        if val &gt; 0</div>
<div class="line">          if val &lt; 5</div>
<div class="line">                  print(&quot;0 &lt; val &lt; 5&quot;)</div>
<div class="line">        print(&quot;end of func&quot;)  // 이 라인의 indentation 판단이 중요</div>
</div><!-- fragment --><p >파서가 <code>print("0 &lt; val &lt; 5")</code>를 파싱하고 나서 다음 줄인 <code>print("end of func")</code>를 파싱할때 앞에 공백이 몇개 있는지 세야 합니다. 그리고 지금까지 각 scope별 공백 갯수와 비교해서 해당 코드라인이 어느 scope에 속한 것인지를 판단해야 합니다.</p>
<p >위 예제를 보면, 우리는 직관적으로 <code>print("end of func")</code>이 <code>if val &gt; 0</code>과 같은 공백을 갖고 있다는 점에서, foo() 본문 바로 안에 속한 코드라는 걸 알 수 있습니다.</p>
<p >그렇다는 건, 이 시점에서 <code>if val &gt; 0</code> 안쪽의 scope와 <code>if val &lt; 5</code> 안쪽의 scope 2개 모두 종료되었으므로 lowscanner는 lowparser가 <code>print("end of func")</code>를 인식하기 전에 scope의 종료를 의미하는 <b><code>DEDENT</code> 토큰을 2개 먼저 인식</b> 할 수 있도록 만들어야 합니다.</p>
<p >예를들어 다음의 stela 코드를 파싱한다고 합시다:</p>
<div class="fragment"><div class="line">@style: language-byeol verified</div>
<div class="line">def config</div>
<div class="line">    def device</div>
<div class="line">      name := &quot;my device&quot;</div>
<div class="line">      // 현재 파싱 위치</div>
</div><!-- fragment --><p >만약 마지막 위치에서 파서가 파싱중일때, parser의 indents 객체는 </p><blockquote class="doxtable">
<p >[0, 4, 6] </p>
</blockquote>
<p>으로 내부 배열 값이 구성되어 있습니다. 각각은 scope이 몇 번의 공백으로 구분되고 있는지를 나타냅니다. 즉 가장 바깥의 scope의 공백의 수는 0 이 되며, 가장 안쪽의 scope인 device의 scope임을 증명하는 공백의 수는 </p><blockquote class="doxtable">
<p >smartDedent[smartDedent.len() - 1] = 6 </p>
</blockquote>
<p>으로 개행 직후 6개의 공백이 나와야 한다는 걸 의미합니다.</p>
<h2><a class="anchor" id="autotoc_md189"></a>
tokenDispatcher</h2>
<p >flex는 yyin 이라는 별도로 지정된 stream을 통해서 글자를 가져와 token으로 정의합니다. 위의 예제를 보다시피, 파싱 도중에 토큰을 추가한다는 것은 이 stream에 특정 문자를 추가하는 것을 의미합니다.</p>
<p >기본적으로 이런 경우는 unput을 사용하나, 여러개를 unput 하거나 뒤가 아니라 앞에 push 하는 경우 등에 유연하게 대응하기 위해, stelaLowscanner는 내부적으로 <a class="el" href="classby_1_1stela_token_dispatcher.html">stelaTokenDispatcher</a> 를 사용합니다.</p>
<p ><b>unput()과 tokenDispatcher의 차이점</b></p>
<p ><code>unput()</code>과 <a class="el" href="classby_1_1token_dispatcher.html">tokenDispatcher</a> 는 <b>근본적으로 다른 동작 방식</b>을 가지고 있습니다. <code>unput()</code>은 <b>스트림 자체에 문자를 추가</b>하는 반면, <a class="el" href="classby_1_1token_dispatcher.html">tokenDispatcher</a> 는 <b>렉서를 건너뛰고 이미 결정된 토큰을 강제로 반환</b>합니다.</p>
<p >이 차이는 매우 중요한데요, <code>unput()</code>은 문자 단위로 작동하여 렉서가 다시 토큰을 분석하게 하지만, <a class="el" href="classby_1_1token_dispatcher.html">tokenDispatcher</a> 는 토큰 단위로 작동하여 렉서의 분석 과정을 완전히 우회하거든요. 예시를 한번 보죠.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">auto&amp; disp = PS.getDispatcher();</div>
<div class="line"> </div>
<div class="line">// 개별 문자를 토큰으로 추가</div>
<div class="line">disp.add(&#39;n&#39;);</div>
<div class="line">disp.add(&#39;a&#39;);</div>
<div class="line">disp.add(&#39;m&#39;);</div>
<div class="line">disp.add(&#39;e&#39;);</div>
</div><!-- fragment --><p >위 코드가 &lsquo;unput('e&rsquo;); unput('m'); unput('a'); unput('n');<code>과 동일하다고 생각할 수 있지만, &lt;b&gt;전혀 다르게 동작&lt;/b&gt;합니다.</code>unput()<code>을 사용하면 렉서가 스트림에서 "name"이라는 문자열을 읽고 이를</code>STRVAL<code>토큰 하나로 인식합니다. 하지만 @ref <a class="el" href="classby_1_1token_dispatcher.html" title="Token queue management for parser">by::tokenDispatcher</a> "tokenDispatcher" 를 사용하면</code>'n'<code>,</code>'a'<code>,</code>'m'<code>,</code>'e'` 토큰을 개별적으로 파서에 반환하게 되며, 이는 파싱 오류를 일으킵니다.</p>
<p ><b>주의사항: dispatcher 사용 후 반드시 토큰을 리턴해야 합니다</b></p>
<p ><a class="el" href="classby_1_1token_dispatcher.html">tokenDispatcher</a> 를 사용할 때는 flex rule 안에서 <b>반드시 토큰을 리턴</b>해야 합니다. 토큰을 리턴하지 않으면 dispatcher가 동작하지 않습니다. 이는 flex의 구현 방식 때문입니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// ❌ 잘못된 사용 - dispatcher가 동작하지 않음</div>
<div class="line">yourRule {</div>
<div class="line">    PS.getDispatcher().add(&#39;+&#39;);</div>
<div class="line">    // 토큰을 리턴하지 않았으므로 dispatcher가 트리거되지 않음</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ✅ 올바른 사용 - dispatcher가 정상 동작</div>
<div class="line">yourSecondRule {</div>
<div class="line">    PS.getDispatcher().add(&#39;+&#39;);</div>
<div class="line">    return STRVAL; // 토큰을 리턴하면 다음 토큰으로 &#39;+&#39;가 반환됨</div>
<div class="line">}</div>
</div><!-- fragment --><p ><b>사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// tokenDispatcher를 통한 토큰 관리</div>
<div class="line">stelaTokenDispatcher dispatcher;</div>
<div class="line"> </div>
<div class="line">// 1. DEDENT 토큰 2개를 앞에 추가해야 하는 경우</div>
<div class="line">// (scope 2개가 종료되었을 때)</div>
<div class="line">dispatcher.pushFront(DEDENT);</div>
<div class="line">dispatcher.pushFront(DEDENT);</div>
<div class="line"> </div>
<div class="line">// 2. 현재 토큰을 다시 읽어야 하는 경우 (unput 대신)</div>
<div class="line">dispatcher.pushFront(currentToken);</div>
<div class="line"> </div>
<div class="line">// 3. 여러 토큰을 순서대로 추가</div>
<div class="line">dispatcher.pushFront(END_SCOPE);</div>
<div class="line">dispatcher.pushFront(DEDENT);</div>
<div class="line">dispatcher.pushFront(NEWLINE);</div>
<div class="line"> </div>
<div class="line">// 토큰 읽기</div>
<div class="line">while(!dispatcher.isEmpty()) {</div>
<div class="line">    Token token = dispatcher.pop();</div>
<div class="line">    // 토큰 처리</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// unput과의 차이 정리:</div>
<div class="line">// - unput: 문자를 스트림에 추가, 렉서가 다시 분석</div>
<div class="line">// - tokenDispatcher: 이미 결정된 토큰을 직접 반환, 렉서 우회</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md190"></a>
stelaTokenScan 클래스 - 스캔 모드 전략</h2>
<p ><a class="el" href="classby_1_1stela_parser.html">stelaParser</a> 는 indentation을 정밀하게 측정하기 위해서 <b>scan mode를 동적으로 변경</b>해야 합니다. tokenScan은 그러한 스캔 모드 전략 1개를 담당합니다.</p>
<p ><b>tokenScan의 동적 전환</b></p>
<p >앞서서 indentation을 탐지하는 게 얼마나 중요한지 설명했습니다. 정확한 공백의 갯수를 셈해야 하기 때문에 <code>normalScan</code>과 <code>indentScan</code> 2개의 scan 객체를 전환해가며 사용합니다.</p>
<p >개행이 탐지되면 indentScan으로 교체해서 정확하게 공백을 count해서 scope를 결정하고, 이후에는 normalScan으로 교체해서 평상시처럼 공백을 다 무시합니다.</p>
<p ><b>indentation 검사</b></p>
<p ><b>명령 token</b></p>
<p >token 중에는 <code>SCAN_AGAIN</code>, <code>SCAN_EXIT</code> 등 scanner나 parser에 명령을 주는 토큰들이 존재합니다. 자세한 내용은 <a class="el" href="classby_1_1stela_parser.html">stelaParser</a> 의 zztokenType enum을 참조하세요.</p>
<p ><b>isBypass</b></p>
<p >IndentScan의 경우 대부분의 token을 무시하며 오직 공백이 몇개인지 갯수를 세는 데 집중합니다. 그리고 indentation이 가장 최근 scope의 indentation과 차이가 발생한 경우 DEDENT 혹은 INDENT token을 dispatcher에 추가합니다.</p>
<p >하지만 이전 라인에서 여러 token을 push 해둔 상황이라면 내부적으로 bypass 모드로 동작합니다. 이때는 indentation 갯수를 세는 동작을 skip 하고 넣어둔 token을 그대로 읽어서 반환합니다.</p>
<p ><b>tokenScan 사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// tokenScan의 사용법과 교체되는 방식을 보여주기 위한 예제입니다.</div>
<div class="line">// 실제 코드와는 아주 다릅니다.</div>
<div class="line">class stelaParser {</div>
<div class="line">    normalScan* _normalScan;</div>
<div class="line">    indentScan* _indentScan;</div>
<div class="line">    stelaTokenScan* _currentScan;</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    int getNextToken() {</div>
<div class="line">        // 현재 스캔 모드에서 토큰 읽기</div>
<div class="line">        return _currentScan-&gt;onScan();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">nint indentScan::onScan(parser&amp; ps, .....) {</div>
<div class="line">    // indentScan도 마찬가지로 공백을 무시한다.</div>
<div class="line">    // 즉 여기에 온 tok 값은 개행후 가장 먼저 발견된 공백이 아닌 token이라는 뜻이다.</div>
<div class="line">    nint tok = super::onScan(ps.....);</div>
<div class="line"> </div>
<div class="line">    // 공백 계산은 뒤에서 할 것이다. 일단은 scan을 일반모드로 교체한다.</div>
<div class="line">    ps.setScan&lt;normalScan&gt;();</div>
<div class="line"> </div>
<div class="line">    ncnt cur = loc-&gt;start.col; // 현재 token의 column이 공백의 갯수가 된다.</div>
<div class="line">    std::vector&lt;ncnt&gt;&amp; ind = ps.getIndents();</div>
<div class="line">    ncnt prev = ind.back(); // 가장 최근의 indentation level</div>
<div class="line"> </div>
<div class="line">    if(cur &gt; prev) return ps.onIndent(cur, tok);</div>
<div class="line">    else if(cur &lt; prev) return ps.onDedent(cur, tok);</div>
<div class="line"> </div>
<div class="line">    return tok;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md191"></a>
stelaSmartDedent 클래스 - Scope 관리</h2>
<p >offside-rule에 의해 byeol은 개행이 있는지 여부가 매우 중요하다고 말씀드렸죠. byeol은 표현식 기반 문법을 가지고 있기 때문에 <code>for</code>나 <code>if</code> 문이 함수 인자로 오는 것도 가능해야 합니다. 이때 사용자는 간단하게 사용하기 위해 보통은 <code>:</code>을 사용하는 inline block 문법을 사용하게 되는데, 위의 3가지가 한번에 적용되기 시작하면 예외사항이 나오기 마련이죠.</p>
<div class="fragment"><div class="line">@style: language-byeol verified</div>
<div class="line">onEvent(e event) void</div>
<div class="line">foo(listener onEvent, e event) void</div>
<div class="line">    e.process()</div>
<div class="line">    listener(e)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line">    boo() void: print(&quot;&quot;) # 1) 이렇게 inline block을 만드는 건 아무런 문제가 없습니다.</div>
<div class="line"> </div>
<div class="line">    foo((e) void</div>
<div class="line">        onAfterRender()</div>
<div class="line">    , RENDER_UI) # 2) 이렇게 lambda를 써도 문제가 없습니다만,</div>
<div class="line"> </div>
<div class="line">    foo((e) void: onAfterRender(), RENDER_UI)</div>
<div class="line">    # 3) 위처럼 inline block과 람다를 한줄에 쓰면 문제가 됩니다.</div>
<div class="line">    # 왜 문제일까요?</div>
</div><!-- fragment --><p >함수 뒤에는 블록문이 옵니다. 블록문은 <code>&lt;표현식&gt; &lt;개행&gt;</code> 이 매치되면 구문으로 인식되고 이러한 구문들만 블록문에 들어올 수 있습니다. 1번의 경우처럼 inline block을 쓸 때도 뒤에 &lt;개행&gt;이 온다는 점은 유지되어야 합니다. 하지만 3번을 보세요. inline block 뒤에 콤마가 나오는데, 이 경우 inline block의 &lt;개행&gt;은 없습니다. 그렇다고 단순히 <code>inline block은 개행이 있을 수도 있고 없을 수도 있다</code> 라고 규칙을 정해버리면 모호한 경우가 너무 많이 생깁니다.</p>
<p >그래서 <a class="el" href="classby_1_1stela_smart_dedent.html">stelaSmartDedent</a> 가 나옵니다. 위와 같이 inline block을 블록을 사용하되, 콤마로 끝나는 경우는 개행을 추가해주는 아주 단순하지만 parser의 rule의 난이도를 낮추는 역할을 합니다.</p>
<hr  />
<p ><b>다음 문서</b>: <a class="el" href="ai-architecture-core.html">core 모듈 - 언어 구현의 핵심</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
