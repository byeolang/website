<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: meta 모듈 - 런타임 타입 시스템</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'검색','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('af-architecture-meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">meta 모듈 - 런타임 타입 시스템 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__home_runner_work_byeol_byeol_doc_ref_ko_af_architecture_meta"></a> <a class="el" href="group__meta.html">Meta</a> 모듈은 런타임 타입 정보(RTTI)와 리플렉션 기능을 제공합니다. C++의 기본 RTTI보다 더 강력하고 효율적인 타입 시스템을 구현하고 있으며, Byeol 언어의 타입 시스템 기반이 됩니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md129"></a>
메타 시스템 개요</h1>
<p >메타 시스템은 프로그램 실행 중에 타입 정보를 조회하고 조작할 수 있게 해줍니다. 이는 다음과 같은 목적을 위해 사용됩니다:</p>
<ol type="1">
<li>타입 계층 구조 탐색 (상속 관계 확인)</li>
<li>타입 정보 조회 (이름, 추상 클래스 여부, 템플릿 여부 등)</li>
<li>동적 인스턴스 생성</li>
<li>효율적인 타입 캐스팅 (dynamic_cast보다 빠름)</li>
</ol>
<p >메타 시스템의 핵심은 Monostate 패턴을 사용하여 매번 객체를 생성해도 내부 상태는 공유된다는 점이에요. 따라서 <code>ttype&lt;MyClass&gt;()</code>를 여러 번 호출해도 추가 비용이 들지 않습니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md131"></a>
타입 정보 사용하기</h1>
<h2><a class="anchor" id="autotoc_md132"></a>
ttype&lt;T&gt; 클래스</h2>
<p ><a class="el" href="classby_1_1ttype.html">ttype</a> 클래스는 사용자가 메타 정보를 다루고자할때 진입점이 되는 클래스예요. <a class="el" href="classby_1_1ttype.html">ttype</a> 를 사용할때는 매번 객체를 생성해서 사용해야 합니다. 전체적으로 monostate 패턴으로 설계 되어있어서 매번 객체를 만들어 사용하더라도 값은 공유하기 때문에 추가비용은 들지 않습니다.</p>
<p ><a class="el" href="group__meta.html">Meta</a> 모듈의 전체적인 설계에 대해 파악하고자 한다면 핵심이 되는 <a class="el" href="classby_1_1type.html">type</a> 을 먼저 살펴보세요.</p>
<p ><b>ttype 기본 사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">class myClass {};</div>
<div class="line"> </div>
<div class="line">class myDerivedClass : public myClass {</div>
<div class="line">    typedef myClass super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 타입 정보 조회</div>
<div class="line">const type&amp; typeInfo = ttype&lt;myClass&gt;();</div>
<div class="line">std::cout &lt;&lt; typeInfo.getName();  // &quot;myClass&quot; 출력</div>
<div class="line"> </div>
<div class="line">// 템플릿 여부 확인</div>
<div class="line">bool isTemplate = ttype&lt;myClass&gt;().isTemplate();  // false</div>
<div class="line"> </div>
<div class="line">// 추상 클래스 여부 확인</div>
<div class="line">bool isAbstract = ttype&lt;myClass&gt;().isAbstract();  // false</div>
<div class="line"> </div>
<div class="line">// 부모 타입 확인</div>
<div class="line">const type&amp; superType = ttype&lt;myDerivedClass&gt;().getSuper();</div>
<div class="line">std::cout &lt;&lt; superType.getName();  // &quot;myClass&quot; 출력</div>
<div class="line"> </div>
<div class="line">// 인스턴스 생성 (기본 생성자 필요)</div>
<div class="line">myClass* instance = ttype&lt;myClass&gt;().makeAs&lt;myClass&gt;();</div>
<div class="line">delete instance;</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md134"></a>
type 클래스의 기능</h1>
<p ><a class="el" href="classby_1_1type.html">type</a> 클래스는 <a class="el" href="group__meta.html">Meta</a> 모듈의 핵심이 되는 클래스예요. <a class="el" href="classby_1_1type.html">type</a> 에 대한 다음의 기본적인 API를 제공합니다.</p>
<h2><a class="anchor" id="autotoc_md135"></a>
기본 타입 식별</h2>
<p >다음 함수들로 타입의 기본 정보를 얻을 수 있습니다:</p>
<ul>
<li><code>isTemplate()</code>: 템플릿 클래스 여부를 반환합니다.</li>
<li><code>isAbstract()</code>: 추상 클래스 여부를 반환합니다.</li>
<li><code>getName()</code>: 클래스명을 반환합니다. 이름은 demangle 되어 반환됩니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md136"></a>
클래스 계층 관련 정보</h2>
<p ><b>getSupers()</b></p>
<p >super class들을 리스트에 담아 반환합니다. 이 클래스의 직접적인 부모 클래스는 리스트 마지막 원소에, 보다 더 super class일 수록 리스트 앞에 담겨있습니다.</p>
<p >예를들어 다음과 같은 코드를 보세요.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const auto&amp; supers = getType().getSupers();</div>
<div class="line"> </div>
<div class="line">// 가장 첫번째 클래스는 항상 adam 이 된다. adam 클래스 참조.</div>
<div class="line">supers[0].getName() // &quot;adam&quot;</div>
<div class="line"> </div>
<div class="line">supers.last()-&gt;getName() // this 클래스의 부모클래스 이름이 나온다.</div>
</div><!-- fragment --><p ><b>getSubs()</b></p>
<p >sub class들을 리스트에 담아 반환합니다. getSupers()와 마찬가지 방식으로, 가까운 sub 일 수록 리스트 앞에 담겨있습니다.</p>
<p ><b>isSuper(const rhs&amp; type)</b></p>
<p >this class가 rhs보다 super 클래스 인지 체크합니다. dynamic_cast과 동일한 기능이지만 알고리즘 복잡도가 더 뛰어납니다.</p>
<p >일반적으로 dynamic_cast는 vtable을 순회해서 체크합니다. 반면 meta는 메타 정보 생성시 super 클래스 계층도를 통해서 자신이 몇 tier의 자손인지를 바로 알 수 있습니다. 이 tier값과 char*의 주소값을 비교해서 타입정보를 비교합니다.</p>
<p ><b>isSub(const rhs&amp; type)</b></p>
<p >isSuper와 반대로 동작합니다.</p>
<p ><b>타입 계층 검사 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">class Animal {};</div>
<div class="line"> </div>
<div class="line">class Dog : public Animal {</div>
<div class="line">    typedef Animal super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Puppy : public Dog {</div>
<div class="line">    typedef Dog super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 상속 관계 확인</div>
<div class="line">const type&amp; animalType = ttype&lt;Animal&gt;();</div>
<div class="line">const type&amp; dogType = ttype&lt;Dog&gt;();</div>
<div class="line">const type&amp; puppyType = ttype&lt;Puppy&gt;();</div>
<div class="line"> </div>
<div class="line">// Animal이 Dog의 부모인가?</div>
<div class="line">bool isParent = animalType.isSuper(dogType);  // true</div>
<div class="line"> </div>
<div class="line">// Dog가 Animal의 자식인가?</div>
<div class="line">bool isChild = dogType.isSub(animalType);  // true</div>
<div class="line"> </div>
<div class="line">// Puppy는 Animal의 자식인가? (간접 상속도 체크)</div>
<div class="line">bool isDescendant = puppyType.isSub(animalType);  // true</div>
<div class="line"> </div>
<div class="line">// 형제 관계는 false</div>
<div class="line">class Cat : public Animal {</div>
<div class="line">    typedef Animal super;</div>
<div class="line">};</div>
<div class="line">bool areSiblings = ttype&lt;Dog&gt;().isSub(ttype&lt;Cat&gt;());  // false</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md137"></a>
인스턴스 생성</h2>
<p ><b>make()</b></p>
<p >이 type의 기본생성자로 인스턴스를 생성합니다. 만약, 기본생성자가 없다면 nullptr가 반환되니 주의하세요.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
메타 타입 정보 관리</h2>
<p ><code>init()</code>으로 초기화를, <code>rel()</code>로 해제를 합니다. 이는 <code>BY_INIT_META</code> 매크로를 통해서 자동으로 처리가 되는 부분이라 외부에서 직접 호출할 경우는 드뭅니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md140"></a>
메타 정보의 생성과 관리</h1>
<h2><a class="anchor" id="autotoc_md141"></a>
메타 정보가 어떻게 생성되나</h2>
<p ><code>isTemplate()</code> 이나 <code>isAbstract()</code>, <code>getName()</code> 같은 타입정보는 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 에서 메타프로그래밍을 통해 채워줍니다. 따라서 <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init()</a>이 존재하는 이유는 클래스 계층을 구성하기 위해서입니다.</p>
<p >그리고 그 계층을 구성하는 핵심은 **모든 클래스는 typedef로 super를 정의해야 한다**라는 제약사항으로 해결합니다. 모든 클래스에 <code>super</code>가 존재한다면, <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init()</a>도 호출할 수 있기 때문에 다음과 같은 간단한 코드로 클래스 계층을 재귀적으로 구성할 수 있게 됩니다.</p>
<p ><b>참고</b>: 부모 클래스가 없는 최상위 클래스는 <code>typedef adam super;</code>로 정의하여 <a class="el" href="classby_1_1adam.html">adam</a> 에 연결됩니다. 이를 통해 모든 타입이 단일 계층 구조를 이루게 됩니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// 주의: 다음은 실제 코드 동작을 이해하기 쉽게 간략화 한 것이다.</div>
<div class="line">nbool me::init() {</div>
<div class="line">    if(_isInit) return false;</div>
<div class="line">    _isInit = true;</div>
<div class="line"> </div>
<div class="line">    // 위 코드로 인해, 여기는 딱 1번만 실행된다.</div>
<div class="line">    type&amp; super = (type&amp;) getSuper(); // getSuper()는 ttype&lt;typename T::super&gt;::get() 를 반환한다.</div>
<div class="line">    super.init(); // 재귀적으로 부모의 타입을 계속 호출하는 과정이 반복된다.</div>
<div class="line">                  // 최종적으로는 adam 클래스까지 올라가게 되며, adam 은 부모가 없기 때문에 취소된다.</div>
<div class="line"> </div>
<div class="line">    types&amp; mySupers = getSupers();</div>
<div class="line">    mySupers = super.getSupers();</div>
<div class="line">    mySupers.push_back(&amp;super);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p >실제 코드는 이와 크게 다르지 않습니다. 실제로 몇 줄의 간단한 코드만으로도 클래스 계층을 구성합니다. 이 과정은 재귀를 사용하긴 하지만, 프로그램 실행 후 1번만 발생하기 때문에 비용도 비교적 적습니다.</p>
<h2><a class="anchor" id="autotoc_md142"></a>
메타 정보 자동 생성</h2>
<p >앞서 얘기한 대로 각 type 클래스들의 정보는 <code>init()</code> 함수를 호출하면 생성되고 채워집니다. 문제는 각 클래스들에 대한 타입 객체를 일일이 사용자가 생성하고 각각을 명시적으로 <code>init()</code>을 호출하는 것은 굉장히 비효율적이라는 점입니다.</p>
<p >이걸 해결하고자 BY_INIT_META 매크로를 사용합니다. BY_INIT_META 는 BY_INITIATOR 매크로를 응용하는데, 이 매크로는 static 객체에 람다함수를 끼워넣음으로써 원하는 동작을 main() 함수가 시작되기 전에 실행하는 매크로입니다.</p>
<p >이 매크로를 응용하면 init() 함수를 main() 함수가 호출되기 직전에 실행하는 게 가능해집니다. 한가지 제약사항으로는 각 클래스 선언시에 BY_INIT_META (MyClass)를 추가해야 한다는 점입니다.</p>
<p ><b>주의</b>: static 초기화 순서를 사용하므로, 여러 translation unit 간의 초기화 순서는 보장되지 않습니다. 다만, 각 type의 <code>init()</code>은 재귀적으로 부모를 먼저 초기화하는 구조이므로, 타입 계층 구조 내에서는 부모에서 자식으로 가는 초기화 순서가 보장됩니다.</p>
<p >이러한 메타 DSL 형태의 매크로들은 BY 매크로에 의해서 실행되도록 컨벤션이 정해져있습니다. 그리고 <a class="el" href="group__core.html">Core</a> 모듈에서도 추가로 정의해야할 메타 DSL 매크로가 있기 때문에 직접 BY_INIT_META 를 호출하기 보다는 <code>BY(CLASS())</code> 나 <code>BY(ADT())</code>를 통해서 한번에 정의합니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md144"></a>
adam - 최상위 타입</h1>
<p ><a class="el" href="classby_1_1adam.html">adam</a> 클래스는 모든 타입 계층의 루트예요. <a class="el" href="classby_1_1type.html">type</a> 의 클래스 계층구조 상 아무런 부모도 없는 메타타입은 범용적으로 다루기가 어렵습니다.</p>
<p >예를들어 모든 메타타입에 대해서 동작하는 함수를 작성하고자 한다면, 다음과 같은 코드를 작성할 수 있어야 합니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const auto&amp; types = how_to_get_all_meta_types() // ?</div>
<div class="line">for(const auto&amp; t : types)</div>
<div class="line">    cout &lt;&lt; t.getName() &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">vector&lt;type&gt; how_to_get_all_meta_types() {</div>
<div class="line">    // 모든 타입들을 순회해서 가져올 방법이 없다.</div>
<div class="line">    // 그러니 다음과 같이 해야한다?</div>
<div class="line">    vector&lt;type&gt; ret;</div>
<div class="line">    ret.push_back(ttype&lt;A&gt;());</div>
<div class="line">    ret.push_back(ttype&lt;B&gt;());</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    return ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p >이를 해결하고자 메타 정보를 구성할때 어떠한 부모클래스도 없는 클래스라면 부모를 <a class="el" href="classby_1_1adam.html">adam</a> 으로 정의합니다. 이제 다음과 같이 작성할 수 있게 됩니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">for(const auto&amp; t : ttype&lt;adam&gt;().getSubs())</div>
<div class="line">    cout &lt;&lt; t.getName() &lt;&lt; &quot;\n&quot;;</div>
</div><!-- fragment --><p ><b>adam을 활용한 타입 순회 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// 부모가 없는 여러 클래스들 정의</div>
<div class="line">class Shape {</div>
<div class="line">    // 부모가 없으므로 자동으로 adam이 부모가 됨</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Vehicle {</div>
<div class="line">    // 부모가 없으므로 자동으로 adam이 부모가 됨</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Animal {</div>
<div class="line">    typedef adam super;  // 명시적으로 adam을 부모로 지정</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 모든 최상위 타입들을 순회</div>
<div class="line">const types&amp; allTopLevelTypes = ttype&lt;adam&gt;().getSubs();</div>
<div class="line"> </div>
<div class="line">for(const type* t : allTopLevelTypes) {</div>
<div class="line">    std::cout &lt;&lt; &quot;Top-level type: &quot; &lt;&lt; t-&gt;getName() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">// 출력: Shape, Vehicle, Animal 등 모든 최상위 클래스들</div>
<div class="line"> </div>
<div class="line">// adam을 통해 특정 타입이 최상위 타입인지 확인</div>
<div class="line">const type&amp; shapeType = ttype&lt;Shape&gt;();</div>
<div class="line">bool isTopLevel = (shapeType.getSuper() == ttype&lt;adam&gt;());  // true</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md146"></a>
메타 타입 확장하기</h1>
<p ><a class="el" href="classby_1_1type.html">type</a> 은 기본적으로도 비교적 많은 타입 정보를 제공하지만, byeol 처럼 언어를 다루는 경우에는 parameter나 return type과 같이 추가적인 정보를 담고 싶은 경우가 있습니다.</p>
<p >이때 쉽게 생각하면 <a class="el" href="classby_1_1type.html">type</a> 을 상속받은 클래스를 만들면 되는거 아닌가라는 아이디어를 떠올리기 쉽지만 <code>ttype&lt;T&gt;</code>에서 언급한 것처럼, 항상 사용자의 최종 진입점은 <code>ttype&lt;T&gt;</code>에 접근하면서 시작되어야 합니다. 문제는 <a class="el" href="classby_1_1ttype.html">ttype</a> 의 코드를 <a class="el" href="group__meta.html">Meta</a> 모듈을 종속하는 쪽에서 수정할 수는 없기 때문에 상속으로는 불가능하고 메타 타입을 주입하는 형태로 문제를 해결합니다.</p>
<p >핵심 코드는 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 에 있습니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">template &lt;typename T, typename S = typename tmetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line">class ttypeBase: public S {</div>
<div class="line">    ....</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, nbool hasMeta = tifHasMetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line">struct tmetaTypeDef {</div>
<div class="line">    using is = type;</div>
<div class="line">};</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">struct tmetaTypeDef&lt;T, true&gt; {</div>
<div class="line">    using is = typename T::metaType;</div>
<div class="line">};</div>
</div><!-- fragment --><p >tmetaTypeDef는 T에 typedef metaType이 있을 경우에는 해당타입을 반환하고, 없으면 <a class="el" href="classby_1_1type.html">type</a> 을 반환합니다. <a class="el" href="classby_1_1ttype.html">ttype</a> 은 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 를 상속하며, <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 는 바로 tmetaTypeDef&lt;T&gt;::is를 상속합니다.</p>
<p >이걸 통해서 만약 class T에 대해 ttype&lt;T&gt;를 호출하는 순간, class T의 개발자가 <code>typedef metaType MyType;</code> 처럼 새로운 MyType 클래스를 선언하여 추가하면 해당 ttype&lt;T&gt;()로 객체를 만들었을때 MyType을 기반으로 해서 만들어지게 됩니다.</p>
<p >실제로 이 기능은 <a class="el" href="group__core.html">Core</a> 모듈에서 <a class="el" href="classby_1_1ntype.html">ntype</a> 을 주입하기 위해 사용합니다. 자세한 내용은 <a class="el" href="classby_1_1ntype.html">ntype</a> 을 참조하세요.</p>
<hr  />
<p ><b>다음 문서</b>: <a class="el" href="ag-architecture-memlite.html">memlite 모듈 - 커스텀 메모리 관리</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
