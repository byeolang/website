@startuml inline_umlgraph_1.png
skinparam ranksep 1
skinparam packagePadding 1

frame "Byeol Interpreter" {
  package "frontend module" as f {
    rectangle "cli"
    rectangle "flag"
  }
  package "core module" as co {
    rectangle "ASTs"
    rectangle "parser"
    rectangle "verifier"
    rectangle "expander"
    rectangle "interpreter"
    rectangle "starter"
    rectangle "thread"
    rectangle "frame"
    rectangle "func"
    rectangle "obj"
    rectangle "closure"
  }
  package "stela module" as s {
    rectangle "stelaParser"
    rectangle "stelaScanner"
    rectangle "stelaTokenDispatcher"
    rectangle "stela"
  }
  package "memlite module" as mem {
    rectangle "tstr"
    rectangle "tweak"
    rectangle "instance"
    rectangle "instancer"
    rectangle "watcher"
  }
  package "meta module" as met {
    rectangle "ttype"
    rectangle "type"
  }
  package "clog module" as cl {
    rectangle "logger"
    rectangle "stream"
  }
  package "indep module" as i {
    rectangle "platformAPI"
    rectangle "buildFeature"
  }

  f -down-> co
  co -down-> s
  s -down-> mem
  mem -down-> met
  met -down-> cl
  cl -down-> i
}
@enduml
@startuml inline_umlgraph_2.png
package "Error Handling" {
  class "tmay<T>" as tmay {
    - _val : tmedium<T>
    + has() : nbool
    + get() : T&
    + rel() : void
    + set(T&) : void
    --
    <b>Optional Type</b>
    Similar to std::optional
  }

  class "tres<T, E>" as tres {
    - _val : tmedium<T>
    - _err : E
    + has() : nbool
    + get() : T&
    + getErr() : E&
    --
    <b>Result/Either Type</b>
    Returns value or error
  }

  class "tmedium<T>" as tmedium {
    - _ptr : T*
    + has() : nbool
    + get() : T&
    + operator=(T*) : void
    --
    <b>Internal Implementation Class</b>
    Handles T& and nullptr
  }
}

package "Platform Abstraction" {
  class platformAPI {
    + {static} foreColor(color) : string
    + {static} unlimitCoreDump() : void
    + {static} getCpuCount() : nint
    + {static} getPageSize() : nint
    --
    <b>Facade Pattern</b>
    Integrates platform-dependent APIs
  }

  class buildFeature {
    + {static} version::get() : string
    + {static} date::get() : string
    + {static} platform::getName() : string
    + {static} config::isDbg() : nbool
    --
    Automatically generated by CMake
    Provides build information
  }

  class fsystem {
    + {static} scan(path) : iterator
    - _impl : OS-specific implementation
    --
    <b>Adapter Pattern</b>
    File system abstraction
  }

  class dlib {
    - _handle : void*
    + load(path) : nbool
    + getFunc(name) : void*
    + close() : void
    --
    Dynamic library loading
    Abstraction of dlopen/LoadLibrary
  }

  note bottom of platformAPI
    <b>Platform-specific Branching:</b>
    #ifdef BY_PLATFORM_WINDOWS
        // Use Windows API
    #else
        // Use POSIX API
    #endif
  end note
}

tmay --> tmedium
tres --> tmedium
@enduml
@startuml inline_umlgraph_3.png
class "tmedium<T>" as tmedium {
    - _ptr : T*
    + has() : nbool
    + get() : T&
    + get() const : const T&
    + rel() : T*
    + operator=(T*) : void
    + operator=(T&) : void
    --
    <b>Internal Type for indep Module</b>
}

class "tmay<T>" as tmay {
    - _val : tmedium<T>
    --
    + tmay()
    + tmay(T&)
    + has() : nbool
    + get() : T&
    + rel() : void
    + set(T&) : void
    --
    <b>Similar to std::optional</b>
    Can express presence or absence of T value
}

class "tres<T, E>" as tres {
    - _val : tmedium<T>
    - _err : E
    --
    + tres(T&)
    + tres(E&)
    + has() : nbool
    + get() : T&
    + getErr() : E&
    + isErr() : nbool
    --
    <b>Similar to std::expected:</b>
    Owns E value if T value is absent.
}

tmay *-- tmedium
tres *-- tmedium
@enduml
@startuml inline_umlgraph_4.png
class logger {
    - _streams : map<string, stream*>
    - _filters : filters
    + {static} get() : logger&
    + logBypass(level, msg) : void
    + getStream(name) : stream*
    + setFilters(filters&) : void
    + setEnable(bool) : void
    --
    <b>Facade Pattern</b>
    <b>Singleton Pattern</b>
    Logging system entry point
}

abstract class stream {
    - _enable : nbool
    - _state : State
    + dump(level, msg) : void
    + setEnable(bool) : void
    + rel() : void
    --
    <b>State Machine</b>
    Destination for logging messages
}

class consoleStream {
    + dump(level, msg) : void
    --
    Console output stream
    Uses stdout/stderr
}

class fileLogStream {
    - _file : FILE*
    + dump(level, msg) : void
    --
    File output stream
    Writes to log file
}

abstract class filterable {
    + {abstract} filt(Log&) : nbool
    --
    <b>Filter Interface</b>
}

class filters {
    - _container : vector<filterable*>
    + filt(Log&) : nbool
    + add(filterable*) : void
    --
    <b>Composite Pattern</b>
    Manages multiple filters
}

class errPassFilter {
    + filt(Log&) : nbool
    --
    Passes only ERR level
}

class warnPassFilter {
    + filt(Log&) : nbool
    --
    Passes only WARN level
}

logger "1" *-- "0..*" stream
logger *-- filters

stream <|-- consoleStream
stream <|-- fileLogStream

filterable <|-- filters
filterable <|-- errPassFilter
filterable <|-- warnPassFilter

filters "1" o-- "0..*" filterable
@enduml
@startuml inline_umlgraph_5.png
package "richLog System" {
    abstract class "convert(T)" as convert {
        + {static} convert(tstr<obj>&) : strWrap
        + {static} convert(int) : noWrap<int>
        + {static} convert(void*) : strWrap
        --
        <b>Compile-time Dispatching</b>
        Overloaded for each type
    }

    class strWrap {
        - _val : std::string
        + unwrap() : const char*
        --
        String Wrapper
        Returns c_str()
    }

    class "noWrap<T>" as noWrap {
        - _val : T
        + unwrap() : T
        --
        Passes value as is
        For scalar types
    }
}

convert ..> strWrap : Create
convert ..> noWrap : Create
@enduml
@startuml inline_umlgraph_6.png
participant "User Code" as user
participant "BY_I Macro" as macro
participant "richLog" as richLog
participant "convert()\n(Overload)" as convert
participant "wrap" as wrap
participant "logger" as logger

user -> macro : BY_I("obj: %s, val: %d", meObj, count)
activate macro

note right of macro
  Macro Expansion:
  richLog("obj: %s, val: %d",
          meObj, count)
end note

macro -> richLog : richLog(format, meObj, count)
activate richLog

richLog -> convert : convert(meObj)
activate convert

note right of convert
  <b>Calls appropriate overloaded convert():</b>
  Ex: meObj is tstr<obj>* type

  Calls convert(tstr<obj>*).
  (Calls convert(void*) if absent)

  Returns strWrap(obj.getName()).
end note

convert --> richLog : strWrap("obj")
deactivate convert

richLog -> convert : convert(count)
activate convert

note right of convert
  <b>Calls appropriate overloaded convert():</b>

  count is int type.
  Calls convert(int).

  return noWrap<int>(count)
end note

convert --> richLog : noWrap<int>(count)
deactivate convert

richLog -> wrap : strWrap.unwrap()
activate wrap
wrap --> richLog : "obj"
deactivate wrap

richLog -> wrap : noWrap.unwrap()
activate wrap
wrap --> richLog : 3 (value of count)
deactivate wrap

richLog -> logger : log(level, "obj: %s, val: %d", "obj", 3)
activate logger

note right of logger
  Variadic Function Call:
  - All args are scalar or pointer
  - printf style formatting available
end note

logger -> logger : Check filters
logger -> logger : Output to streams

logger --> richLog : void
deactivate logger

richLog --> macro : void
deactivate richLog

macro --> user : void
deactivate macro

note right of user
  <b>Output Result:</b>
  Oct 22 2025  22:01:12 I obj: obj, val: 42
end note
@enduml
@startuml inline_umlgraph_7.png
class "adam" as adam {
    Top-level Type
}

class "type" as type {
    - _name : string
    - _isTemplate : nbool
    - _isAbstract : nbool
    - _supers : types
    - _subs : types
    - _isInit : nbool
    ---
    + getName() : string
    + isTemplate() : nbool
    + isAbstract() : nbool
    + getSupers() : types
    + getSubs() : types
    + isSub(type) : nbool
    + isSuper(type) : nbool
    + make() : instance*
    + init() : nbool
    + rel() : nbool
}

class "ttypeBase<T, S>" as ttypeBase {
    + get() : S&
    + getStatic() : S&
}

class "ttype<T>" as ttype {
    User Entry Point
}

note right of type
  <b>Monostate Pattern:</b>
  All member variables are static

  Creating ttype<T>() multiple times
  shares internal state
end note

ttype --|> ttypeBase : Inherits
ttypeBase --|> type : Inherits when S=type
adam <-- type : Used as top-level type
@enduml
@startuml inline_umlgraph_8.png
participant "User Code" as user
participant "ttype<Dog>" as ttypeDog
participant "Dog::type" as dogType
participant "ttype<Animal>" as ttypeAnimal
participant "Animal::type" as animalType
participant "ttype<adam>" as ttypeAdam
participant "adam::type" as adamType

note over user, ttypeDog
At process start, by BY_INITIATOR,
or by user's explicit call,
end note

user -> ttypeDog : ttype<Dog>().init()
activate ttypeDog

ttypeDog -> dogType : init()
activate dogType

note right of dogType
  <b>Prevent Re-entry:</b>
  if(_isInit) return false;
  _isInit = true;
end note

dogType -> dogType : getSuper()
note right of dogType
  typedef Animal super;
  return ttype<Animal>::get()
end note

dogType -> ttypeAnimal : getSuper().init()
activate ttypeAnimal

ttypeAnimal -> animalType : init()
activate animalType

animalType -> animalType : getSuper()
note right of animalType
  typedef adam super;
  return ttype<adam>::get()
end note

animalType -> ttypeAdam : getSuper().init()
activate ttypeAdam

ttypeAdam -> adamType : init()
activate adamType

adamType -> adamType : getSuper()
note right of adamType
  <b>Recursion End:</b>
  adam has no parent
  Returns empty type
end note

adamType --> ttypeAdam : Initialization Complete
deactivate adamType
deactivate ttypeAdam

animalType -> animalType : getSupers() = super.getSupers()
animalType -> animalType : getSupers().push_back(&super)

note right of animalType
  <b>Hierarchy Construction:</b>
  mySupers = [adam]
  mySupers.push_back(adam)

  Animal's supers = [adam]
end note

animalType --> dogType : Initialization Complete
deactivate animalType

dogType -> dogType : getSupers() = super.getSupers()
dogType -> dogType : getSupers().push_back(&super)

note right of dogType
  <b>Hierarchy Construction:</b>
  mySupers = [adam, Animal]

  Dog's supers = [adam, Animal]
end note

dogType --> ttypeDog : Initialization Complete
deactivate dogType

ttypeDog --> user : Initialization Complete
deactivate ttypeDog

note over user, adamType
  <b>Features of Recursive Initialization Pattern:</b>

  1. Execute once: Prevent re-entry with _isInit flag
  2. Bottom-up Initialization: Child initializes parent first
  3. Hierarchy Construction: Copy parent's supers then add parent
  4. Safe Exit: End recursion at adam
end note
@enduml
@startuml inline_umlgraph_9.png
package "Memory Management Package" {
    class "instancer" as instancer {
        - _pool : pool
        - _watcher : watcher
        ---
        + make(size) : void*
        + destroy(void*) : void
    }

    class "pool" as pool {
        - _chunks : chunks[]
        ---
        + get(size) : chunks*
        + new1(size) : void*
        + del(ptr, size) : void
    }

    class "chunks" as chunks {
        - _chunks : chunk[]
        - _s : ncnt
        - _blkSize : ncnt
        ---
        + new1() : void*
        + del(ptr, size) : void
        + resize() : void
    }

    class "chunk" as chunk {
        - _heap : void*
        - _head : ncnt
        - _len : ncnt
        - _size : ncnt
        - _blkSize : ncnt
        ---
        + new1() : void*
        + del(ptr, size) : void
        + has(ptr) : nbool
        + operator[](idx) : void*
    }

    class "watcher" as watcher {
        - _lives : life[]
        ---
        + reg(instance*) : life*
        + unreg(id) : void
        + get(id) : life*
    }

    class "life" as life {
        - _pt : instance*
        - _strong : ncnt
        - _id : id
        ---
        + onStrong(delta) : void
        + getStrongCnt() : ncnt
        + isBind() : nbool
        + canBind(type) : nbool
    }
}

package "User Interface Package" {
    class "instance" as instance {
        - _id : id
        ---
        + getId() : id
        + getBindTag() : life&
    }

    class "binder" as binder {
        + bind(instance*) : nbool
        + rel() : void
        + isBind() : nbool
        + get() : instance*
    }

    class "tstr<T>" as tstr
    class "tweak<T>" as tweak
}

instancer *-- pool
instancer *-- watcher
pool *-- "n" chunks : Lazy creation
chunks *-- "n" chunk
watcher *-- "n" life
life --> instance : Reference

binder --> life : Indirect reference
tstr --|> binder
tweak --|> binder
instance --> life : getBindTag()
@enduml
@startuml inline_umlgraph_10.png
package "User Interface Package" {
    class "instance" as instance {
        - _id : id
        ---
        + getId() : id
        + getBindTag() : life&
    }

    class "binder" as binder {
        + bind(instance*) : nbool
        + rel() : void
        + isBind() : nbool
        + get() : instance*
    }

    class "tstr<T>" as tstr
    class "tweak<T>" as tweak
}

package "Memory Pool Package" {
  class life {}
}

life --> instance : Reference

binder --> life : Indirect reference
tstr --|> binder
tweak --|> binder
instance --> life : getBindTag()
@enduml
@startuml inline_umlgraph_11.png
package "Memory Management Package" {
    class "instancer" as instancer {
        - _pool : pool
        - _watcher : watcher
        ---
        + make(size) : void*
        + destroy(void*) : void
    }

    class "pool" as pool {
        - _chunks : chunks[]
        ---
        + get(size) : chunks*
        + new1(size) : void*
        + del(ptr, size) : void
    }

    class "chunks" as chunks {
        - _chunks : chunk[]
        - _s : ncnt
        - _blkSize : ncnt
        ---
        + new1() : void*
        + del(ptr, size) : void
        + resize() : void
    }

    class "chunk" as chunk {
        - _heap : void*
        - _head : ncnt
        - _len : ncnt
        - _size : ncnt
        - _blkSize : ncnt
        ---
        + new1() : void*
        + del(ptr, size) : void
        + has(ptr) : nbool
        + operator[](idx) : void*
    }

    class "watcher" as watcher {
        - _lives : life[]
        ---
        + reg(instance*) : life*
        + unreg(id) : void
        + get(id) : life*
    }

    class "life" as life {
        - _pt : instance*
        - _strong : ncnt
        - _id : id
        ---
        + onStrong(delta) : void
        + getStrongCnt() : ncnt
        + isBind() : nbool
        + canBind(type) : nbool
    }
}

instancer *-- pool
instancer *-- watcher
pool *-- "n" chunks : Lazy creation
chunks *-- "n" chunk
watcher *-- "n" life

instance --> instancer: Request ID
@enduml
@startuml inline_umlgraph_12.png
participant "chunk" as chunk
participant "_heap[0]" as heap0
participant "_heap[1]" as heap1
participant "_heap[2]" as heap2
participant "_heap[3]" as heap3

note over chunk
  <b>Initialization (size=4):</b>
  _head = 0
  _len = 0
  Store next index in each element
end note

chunk -> heap0 : *(_heap[0]) = 1
chunk -> heap1 : *(_heap[1]) = 2
chunk -> heap2 : *(_heap[2]) = 3
chunk -> heap3 : *(_heap[3]) = 4

note over chunk, heap3
  Initial State: [1, 2, 3, 4]
  _head = 0 (Next allocatable index)
end note

== First Allocation: new1() ==

chunk -> heap0 : ptr1 = _heap + (_head * blkSize)
activate heap0 #lightgreen

note right of chunk
  Update _head to _heap[_head]
  _head = _heap[0] = 1
  _len = 1
end note

note over heap0, heap3
  State: [<b>Used</b>, 2, 3, 4]
  _head = 1
end note

== Second Allocation: new1() ==

chunk -> heap1 : ptr2 = _heap + (_head * blkSize)
activate heap1 #lightgreen

note right of chunk
  _head = _heap[1] = 2
  _len = 2
end note

note over heap0, heap3
  State: [<b>Used</b>, <b>Used</b>, 3, 4]
  _head = 2
end note

== Third Allocation: new1() ==

chunk -> heap2 : ptr3 = _heap + (_head * blkSize)
activate heap2 #lightgreen

note right of chunk
  _head = _heap[2] = 3
  _len = 3
end note

note over heap0, heap3
  State: [<b>Used</b>, <b>Used</b>, <b>Used</b>, 4]
  _head = 3
end note

== Free First Block: del(ptr1) ==

note right of chunk
  1. Store current _head at ptr1
  *ptr1 = _head = 3

  2. Update _head to freed block index
  _head = (ptr1 - _heap) / blkSize = 0

  3. Decrease _len
  _len = 2
end note

chunk -> heap0 : *(_heap[0]) = 3
deactivate heap0

note over heap0, heap3
  State: [3, <b>Used</b>, <b>Used</b>, 4]
  _head = 0

  <b>Free List Structure:</b>
  _heap[0] → _heap[3] → _heap[4] (None)
end note

== Fourth Allocation: new1() ==

chunk -> heap0 : ptr4 = _heap + (_head * blkSize)
activate heap0 #lightgreen

note right of chunk
  <b>Reuse:</b>
  Reuse freed block 0
  _head = _heap[0] = 3
  _len = 3
end note

note over heap0, heap3
  State: [<b>Used</b>, <b>Used</b>, <b>Used</b>, 4]
  _head = 3

  <b>Improve Memory Locality:</b>
  Reuse freed block immediately
end note

note over chunk, heap3
  <b>Features of Free List Algorithm:</b>

  1. <b>Intrusive Linked List:</b>
     Store next free block index in the free block itself
     No extra metadata needed

  2. <b>O(1) Allocation/Deallocation:</b>
     Constant time as only _head update is needed

  3. <b>Memory Locality:</b>
     Reuse recently freed block first

  4. <b>Prevent Fragmentation:</b>
     Use fixed size blocks
end note
@enduml
@startuml inline_umlgraph_13.png
actor "Client" as client
participant "new" as new
participant "instancer" as instancer
participant "pool" as pool
participant "chunks" as chunks
participant "chunk" as chunk
participant "watcher" as watcher
participant "life" as life
participant "instance" as instance
participant "binder" as binder

== Instance Creation Stage ==

client -> new : MyClass* obj = new MyClass()
activate new

new -> instancer : operator new(size)
activate instancer

note right of instancer
  <b>1. Memory Allocation:</b>
  Secure memory via pool
end note

instancer -> pool : new1(size)
activate pool

pool -> pool : get(size)
note right of pool
  Find chunks of that size
  Lazy create if absent
end note

pool -> chunks : new1()
activate chunks

chunks -> chunks : Search available chunk
note right of chunks
  Iterate from _chunks[_s]
  resize() if no memory available
end note

chunks -> chunk : new1()
activate chunk

note right of chunk
  <b>Free List Algorithm:</b>
  ptr = _heap + (_head * blkSize)
  _head = _heap[_head]
  _len++
end note

chunk --> chunks : void* ptr
deactivate chunk

chunks --> pool : void* ptr
deactivate chunks

pool --> instancer : void* ptr
deactivate pool

note right of instancer
  <b>2. Lifecycle Management:</b>
  Register to watcher and allocate life
end note

instancer -> watcher : new1()
activate watcher

watcher -> watcher : Find available life
note right of watcher
  Allocate free life from life pool
  Object Pool Pattern
end note

watcher -> life : Initialize
activate life

note right of life
  _pt = ptr
  _strong = 0
  _id = Create (tagN, chkN, serial)
end note

life --> watcher : life*
deactivate life
watcher --> instancer : life*
deactivate watcher

note right of instancer
  <b>3. ID Assignment:</b>
  Register instance to vault
end note

instancer -> instancer : vault[ptr] = id

instancer --> new : void* ptr
deactivate instancer

new -> instance : Call Constructor
activate instance

instance -> instance : _id = vault[this]
note right of instance
  Get ID from vault
end note

instance --> new : Initialization Complete
deactivate instance

new --> client : MyClass* obj
deactivate new

== Binding Stage ==

client -> binder : tstr<MyClass> ptr(obj)
activate binder

binder -> instance : getBindTag()
instance --> binder : life&

binder -> life : onStrong(+1)
activate life

note right of life
  <b>Reference Counting:</b>
  _strong++
  _strong = 1
end note

life --> binder : void
deactivate life

binder --> client : Binding Complete
deactivate binder

== Destruction Stage ==

client -> binder : ptr.rel() or scope end
activate binder

binder -> life : onStrong(-1)
activate life

note right of life
  <b>Decrease Count:</b>
  _strong--
  _strong = 0
end note

life -> life : if(_strong == 0)
note right of life
  When reference count becomes 0
  Start instance destruction
end note

life -> instance : delete _pt
activate instance

instance -> instance : Call ~MyClass() destructor

instance -> instancer : operator delete(ptr)
activate instancer

note right of instancer
  <b>1. Lifecycle Release:</b>
  Unregister from watcher
end note

instancer -> watcher : del()
activate watcher

watcher -> watcher : Mark as available
note right of life
  _pt = nullptr
  _strong = 0
  Initialize _id

  Reusable later
end note

watcher --> instancer : void
deactivate watcher

note right of instancer
  <b>2. Memory Return:</b>
  Return memory to pool
end note

instancer -> pool : del(ptr, size)
activate pool

pool -> chunks : del(ptr, size)
activate chunks

chunks -> chunk : del(ptr, size)
activate chunk

note right of chunk
  <b>Free List Update:</b>
  *ptr = _head
  _head = (ptr - _heap) / blkSize
  _len--

  No memory initialization
  (For reuse)
end note

chunk --> chunks : void
deactivate chunk

chunks --> pool : void
deactivate chunks

pool --> instancer : void
deactivate pool

instancer --> instance : void
deactivate instancer

instance --> life : void
deactivate instance

life --> binder : void
deactivate life

binder --> client : Destruction Complete
deactivate binder
@enduml
@startuml inline_umlgraph_14.png
package "Parser Package" {
    class "stelaParser" as stelaParser {
        - _scanner : stelaLowscanner*
        - _normalScan : normalScan*
        - _indentScan : indentScan*
        - _currentScan : stelaTokenScan*
        - _indents : smartDedent
        ---
        + parse(script) : stela&
        + parseFromFile(path) : stela&
        ---
        <b>Callback Functions:</b>
        + onIndent(cur, tok) : nint
        + onDedent(cur, tok) : nint
        + onBlock() : void
        + onStatement() : void
        + onExpression() : void
    }

    class "stelaLowscanner" as scanner {
        - _dispatcher : tokenDispatcher*
        - _parser : stelaParser*
        ---
        + yylex() : nint
        + getDispatcher() : tokenDispatcher&
    }

    class "stelaLowparser" as parser {
        - _parser : stelaParser*
        ---
        + yyparse() : nint
    }

    class "tokenDispatcher" as dispatcher {
        - _queue : deque<Token>
        ---
        + pushFront(tok) : void
        + pushBack(tok) : void
        + pop() : Token
        + isEmpty() : nbool
    }

    class "stelaTokenScan" as tokenScan <<abstract>> {
        + onScan(parser, ...) : nint
    }

    class "normalScan" as normalScan {
        + onScan(parser, ...) : nint
    }

    class "indentScan" as indentScan {
        + onScan(parser, ...) : nint
        ---
        - Calculate space count
        - Generate INDENT/DEDENT
    }

    class "stelaSmartDedent" as smartDedent {
        - _indents : vector<ncnt>
        ---
        + push(indent) : void
        + pop() : void
        + back() : ncnt
        + len() : ncnt
    }
}

package "AST Package" {
    class "stela" as stela {
        + asInt() : int
        + asStr() : string
        + sub(name) : stela&
        + operator[](name) : stela&
    }

    class "valStela" as valStela
    class "verStela" as verStela
    class "nulStela" as nulStela
}

stelaParser *-- scanner
stelaParser *-- smartDedent
stelaParser --> parser : Create
stelaParser o-- tokenScan : Switch strategy if needed
scanner *-- dispatcher
scanner --> parser : Deliver token

normalScan --|> tokenScan
indentScan --|> tokenScan

parser ..> stelaParser : Event Callback

stelaParser ..> stela : Create

valStela --|> stela
verStela --|> stela
nulStela --|> stela
@enduml
@startuml inline_umlgraph_15.png
package "Result Hierarchy" {
    class "stela" as stela {
        + asInt() : int
        + asStr() : string
        + sub(name) : stela&
        + operator[](name) : stela&
    }

    class "valStela" as valStela
    class "verStela" as verStela
    class "nulStela" as nulStela
}

stelaParser ..> stela : Create

valStela --|> stela
verStela --|> stela
nulStela --|> stela
@enduml
@startuml inline_umlgraph_16.png
package "Parser Layer" {
    class "stelaParser" as stelaParser {
        - _scanner : stelaLowscanner*
        - _normalScan : normalScan*
        - _indentScan : indentScan*
        - _currentScan : stelaTokenScan*
        - _indents : smartDedent
        ---
        + parse(script) : stela&
        + parseFromFile(path) : stela&
        ---
        <b>Callback Functions:</b>
        + onIndent(cur, tok) : nint
        + onDedent(cur, tok) : nint
        + onBlock() : void
        + onStatement() : void
        + onExpression() : void
    }

    class "stelaLowscanner" as scanner {
        - _dispatcher : tokenDispatcher*
        - _parser : stelaParser*
        ---
        + yylex() : nint
        + getDispatcher() : tokenDispatcher&
    }

    class "stelaLowparser" as parser {
        - _parser : stelaParser*
        ---
        + yyparse() : nint
    }

    class "tokenDispatcher" as dispatcher {
        - _queue : deque<Token>
        ---
        + pushFront(tok) : void
        + pushBack(tok) : void
        + pop() : Token
        + isEmpty() : nbool
    }

    class "stelaTokenScan" as tokenScan <<abstract>> {
        + onScan(parser, ...) : nint
    }

    class "normalScan" as normalScan {
        + onScan(parser, ...) : nint
    }

    class "indentScan" as indentScan {
        + onScan(parser, ...) : nint
        ---
        - Calculate space count
        - Generate INDENT/DEDENT
    }

    class "stelaSmartDedent" as smartDedent {
        - _indents : vector<ncnt>
        ---
        + push(indent) : void
        + pop() : void
        + back() : ncnt
        + len() : ncnt
    }

    note top of stelaParser
      <b>Event-driven Design:</b>
      On rule match in lowparser
      Event callback via 'onFunc()'
    end note

    note right of scanner
      <b>Flex-based:</b>
      Token scanning with Regex
    end note

    note bottom of dispatcher
      <b>Queue-based Token Buffer:</b>
      - Return token directly bypassing lexer
      - Can add multiple tokens sequentially
    end note

    note left of tokenScan
      <b>Strategy Pattern:</b>
      Runtime scan strategy switch

      normalScan: Ignore spaces
      indentScan: Count spaces
    end note

    note right of smartDedent
      <b>Scope Management:</b>
      Indentation of each scope
      Manage levels as stack
    end note
}

stelaParser *-- scanner
stelaParser *-- smartDedent
stelaParser --> parser : Create
stelaParser o-- tokenScan : Switch strategy if needed
scanner *-- dispatcher
scanner --> parser : Deliver token

normalScan --|> tokenScan
indentScan --|> tokenScan

parser ..> stelaParser : Event Callback
@enduml
@startuml inline_umlgraph_17.png
participant "stelaParser" as parser
participant "normalScan" as normalScan
participant "indentScan" as indentScan
participant "tokenDispatcher" as dispatcher
participant "smartDedent" as smartDedent

note over parser
  <b>Initial State:</b>
  currentScan = normalScan
  indents = [0]
end note

== NormalScan ==

parser -> normalScan : onScan()
activate normalScan

note right of normalScan
  <b>normalScan Strategy:</b>
  Ignore spaces,
  Process only normal tokens
end note

normalScan -> normalScan : Token Scan
normalScan --> parser : STRVAL "config"
deactivate normalScan

parser -> parser : Token Processing

== normalScan: On Newline Detection ==

parser -> normalScan : onScan()
activate normalScan

normalScan -> normalScan : Detect newline character ('\\n')

note right of normalScan
  <b>Newline Detection:</b>
  Need precise indentation measurement of next line.

  Switch normalScan → indentScan
end note

normalScan -> parser : setScan<indentScan>()
parser -> parser : currentScan = indentScan

normalScan --> parser : NEWLINE
deactivate normalScan

== indentScan ==

parser -> indentScan : onScan()
activate indentScan

note right of indentScan
  <b>indentScan Strategy:</b>
  Measure column to first non-space
  token after newline
  Space count = column position
end note

indentScan -> indentScan : Scan skipping spaces
note right of indentScan
  "         def device"
  ^^^^
  4 spaces detected
end note

indentScan -> indentScan : Found first non-space token
note right of indentScan
  tok = DEF
  col = 4 (current column)
end note

note right of indentScan: Compare indentation level

indentScan -> smartDedent : back()
activate smartDedent

note right of smartDedent
  Current indents = [0]
  prev = 0
end note

smartDedent --> indentScan : prev = 0
deactivate smartDedent

indentScan -> indentScan : Compare cur vs prev
note right of indentScan
  cur (4) > prev (0)
  → Need INDENT
end note

note right of indentScan: Create INDENT

indentScan -> parser : onIndent(cur=4, tok=DEF)
activate parser

parser -> smartDedent : push(4)
activate smartDedent

note right of smartDedent
  indents = [0, 4]
  Start new scope
end note

smartDedent --> parser : void
deactivate smartDedent

parser -> dispatcher : pushFront(DEF)
activate dispatcher

note right of dispatcher
  Buffer current token to
  dispatcher and return later
end note

dispatcher --> parser : void
deactivate dispatcher

parser --> indentScan : return INDENT
deactivate parser

note right of indentScan
  <b>Mode Switch:</b>
  Indentation measurement complete
  Return to normalScan
end note

indentScan -> parser : setScan<normalScan>()
parser -> parser : currentScan = normalScan

indentScan --> parser : INDENT
deactivate indentScan

parser -> parser : Process INDENT token

== normalScan: Returned ==

parser -> normalScan : onScan()
activate normalScan

normalScan -> dispatcher : isEmpty()?
activate dispatcher
dispatcher --> normalScan : false
deactivate dispatcher

normalScan -> dispatcher : pop()
activate dispatcher
dispatcher --> normalScan : DEF
deactivate dispatcher

normalScan --> parser : DEF
deactivate normalScan

parser -> parser : Process DEF token
@enduml
@startuml inline_umlgraph_18.png
actor "User/CLI" as user
participant "interpreter" as ip
participant "parser" as pa
participant node
participant "expander" as ex
participant verifier as ve

user -> ip : start interpreting
activate ip

== parsing phase ==
ip -> pa: parse codes \nfrom file or stream
activate pa
pa -> node: construct AST
activate node
note right of node
  If there is a part that cannot
  be created as AST right away
  due to dependency issues,
  save it in the @expand() function.
end note
node --> pa: created instances
deactivate node
pa --> ip: return AST

deactivate pa

== expand phase ==
ip -> ex: set pointer to parsed AST
ip -> ex: start expanding
activate ex
ex -> node: link symbols traversing @expand() in each nodes
alt if linking is failed
  ex --> ip: expand is failed
  note over ex, ip
    suspend interpreting.
  end note
end
ex --> ip: expansion success
deactivate ex

== verification phase ==
ip -> ve: set pointer to parsed AST
ip -> ve: start verification
activate ve
ve -> node: try to find errors traversing AST nodes
alt if verification is failed
  ve --> ip: errors found during verification
  note over ve, ip
    syntax error founds.
    suspend interpreting.
  end note
end
ve --> ip: verified
deactivate ve
ip --> user: interpreted AST structure

== execution phase ==
create participant "starter" as s
user -> s: set pointer to AST.
user -> s: execution program
activate s

s -> node: traverse and find main function
node --> s: main()

group prepare thread
  create participant thread
  s -> thread: make a thread
  s -> node: load pack holding main()
  activate node
  node -> thread: load its symbol
  activate thread
  thread -> frame: load
  activate frame
  frame --> thread: loaded
  deactivate frame
  thread -> node: loaded
  deactivate thread
  node --> s: loaded
  deactivate node
end

s -> node: execute main()
node --> s: final output
s --> user: output
deactivate s
@enduml
@startuml inline_umlgraph_19.png
package container {
  class tnarr
  class tnmap
}

package "AST" {
  abstract class node {
      + {abstract} eval(args) : str
      + {abstract} infer() : str
      + {abstract} subs() : scope&
      + as<T>() : str
      + is<T>() : nbool
  }

  class scope {
      + add(name, node)
      + get(name) : node
      + len() : ncnt
  }

  class args {
      + add(node)
      + setMe(obj)
  }

  class params

  package objects {
    abstract class baseObj {
        + clone() : baseObj*
        + getOrigin() : baseObj&
    }
    class obj {
        - _shares : nchain
        - _owns : nchain
        - _type : mgdType
    }
  }

  package func {
    note "..." as N1
  }

  package exprs {
    abstract class expr
    class blockExpr
  }
}

node <|-- baseObj
node <|-- func
node <|-- expr
tnmap <.. params: <<typedef>>
tnarr <.. args: <<typedef>>

baseObj <|-- obj

blockExpr o-- node

package type {
  class ntype
  class mgdType
}

ntype <|-- mgdType
obj *-- mgdType : has type info

package builtIn {
  class nInt
}

baseObj <|-- nInt

package bridge {
  class tbridge
}
baseObj <|-- tbridge

package loader {
  class slot
  class slotLoader
}

package "frame" as frame1 {
  class frame
  class thread
  class starter
}
node <|-- frame
thread *-- frame
starter ..> thread: make and run main()
thread --> slotLoader: start loading

package worker {
  class interpreter {
      + eval(src)
      + work()
  }
  class parser
  class expander
  class verifier
}

interpreter *-- parser
interpreter *-- expander
interpreter *-- verifier
parser --> AST: make AST
@enduml
@startuml inline_umlgraph_20.png
abstract class "node" as node {
    + eval(args) : str
    + infer() : str
    + run(args) : str
    ---
    + sub(name) : node&
    + subs() : scope&
    + subAll(name, args) : narr
    + operator[](name) : node&
    + in(name) : nbool
    ---
    + as<T>() : str
    + is<T>() : nbool
    + cast<T>() : T*
}

class "func" as func {
    - _name : string
    - _params : narr
    - _retType : node*
    - _block : blockExpr*
    ---
    + subs() : scope&
    + eval(args) : str
}

class "blockExpr" as blockExpr {
    - _stmts : narr
    - _localScope : scope*
    ---
    + eval(args) : str
}

class expr {}

class "FBOExpr" as FBOExpr {
    - _lhs : node*
    - _rhs : node*
    - _op : operator
    ---
    + eval(args) : str
}

class baseObj {}

class "obj" as obj {
    - _subs : scope
    ---
    + subs() : scope&
    + eval(args) : str
}

class "scope" as scope {
    + add(name, node*) : void
    + get(name) : node*
    + len() : ncnt
}

note right of scope
  <b>based on multimap:</b>
  to support function overloading.
  key-value based implementation.
end note

node <|-- baseFunc
baseFunc <|-- func
expr <|-- blockExpr
node <|-- expr
expr <|-- FBOExpr
node <|-- baseObj
baseObj <|-- obj

node o.. node: Composite pattern

func *-- blockExpr
obj *-- scope
scope o-- "n" node
@enduml
@startuml inline_umlgraph_21.png
abstract class node {
    + subs() : scope&
    + eval(args) : str
    + infer(args) : str
    + getType() : type&
    + accept(visitInfo, visitor)
}

abstract class baseObj {
    + getOrigin() : baseObj&
    + clone() : baseObj*
    --
    <b>Polymorphism</b>
    native/script object
    Common Interface
}

class obj {
    - _shares : nchain
    - _owns : nchain
    - _type : mgdType
    + getShares() : nchain&
    + getOwns() : nchain&
    + clone() : obj*
    --
    <b>Flyweight Pattern</b>
    shares: shared data (function)
    owns: own data (property)
}

class origin {
    + setCallComplete(...)
    + clone() : origin*
    --
    <b>Prototype Pattern</b>
    Clone original object
    Create instance
}

class nInt {
    - _val : nint
    + get() : nint
    + set(nint)
}

class nStr {
    - _val : std::string
    + len() : nint
    + get(nidx) : nchar
}

class nFlt {
    - _val : nflt
    + get() : nflt
    + set(nflt)
}

note top of node
  Base of all AST nodes
  Component of Composite pattern
end note

note right of baseObj
  Common base class
  of native and script object

  Unify all object types
  with baseObj* pointer
end note

note right of obj
  Object in script environment

  - shares: Shared by all instances
    (function, constant)
  - owns: Unique per instance
    (variable, property)
end note

note left of origin
  Original object of type

  <b>Prototype Pattern:</b>
  New instance with clone()
  Create (Copy construction)
end note

node <|-- baseObj
baseObj <|-- obj
obj <|-- origin

baseObj <|-- nInt
baseObj <|-- nStr
baseObj <|-- nFlt

note bottom of nInt
  Object in native environment
  (Defined in C++)
end note
@enduml
@startuml inline_umlgraph_22.png
abstract class "expr" as expr {
    + eval(thread&) : str
    + run(thread&) : str
}

abstract class "retStateExpr" as retStateExpr {
    <b>Early Exit Pattern</b>
    ---
    + eval(thread&) : str
    ---
    Set setRet() to thread
    Terminate block immediately
}

class "FBOExpr" as FBOExpr {
    - _lhs : str
    - _rhs : str
    - _op : operator
    ---
    + eval(thread&) : str
}

class "FUOExpr" as FUOExpr {
    - _operand : str
    - _op : operator
    ---
    + eval(thread&) : str
}

class "assignExpr" as assignExpr {
    - _left : str
    - _right : str
    ---
    + eval(thread&) : str
}

class "blockExpr" as blockExpr {
    - _stmts : narr
    - _localScope : scope*
    ---
    + eval(thread&) : str
    + onLeaveFrame(frame&) : void
}

class "defArrayExpr" as defArrayExpr {
    - _elements : narr
    ---
    + eval(thread&) : str
    ---
    With Type Promotion
    Infer array type
}

class "defNestedFuncExpr" as defNestedFuncExpr {
    - _funcDef : func*
    ---
    + eval(thread&) : str
    ---
    Can be used as closure
}

class "defSeqExpr" as defSeqExpr {
    - _start : str
    - _end : str
    - _step : str
    ---
    + eval(thread&) : str
}

class "endExpr" as endExpr {
    - _block : blockExpr*
    ---
    + eval(thread&) : str
}

class "retExpr" as retExpr {
    - _retVal : str
    ---
    + eval(thread&) : str
}

class "breakExpr" as breakExpr {
    + eval(thread&) : str
}

class "continueExpr" as continueExpr {
    + eval(thread&) : str
}

expr <|-- FBOExpr
expr <|-- FUOExpr
expr <|-- assignExpr
expr <|-- blockExpr
expr <|-- defArrayExpr
expr <|-- defNestedFuncExpr
expr <|-- defSeqExpr
expr <|-- endExpr
expr <|-- retStateExpr

retStateExpr <|-- retExpr
retStateExpr <|-- breakExpr
retStateExpr <|-- continueExpr
@enduml
@startuml inline_umlgraph_23.png
package "Container Interface" {
    abstract class "tucontainable<T, R, RSquare>" as tucontainable {
        + operator[](idx) : R
        + add(T) : void
        + del(idx) : void
        + len() : ncnt
        + begin() : iterator
        + end() : iterator
        + iterate() : iterator
    }

    abstract class "tbicontainable<K, T, R, RSquare>" as tbicontainable {
        + operator[](key) : R
        + add(key, T) : void
        + del(key) : void
        + in(key) : nbool
        + len() : ncnt
        + begin() : iterator
        + end() : iterator
        + iterate() : iterator
    }
}

package "Native Type (n prefix)" {
    class "tnarr<T>" as tnarr {
        - _data : T*[]
        - _len : ncnt
        ---
        + operator[](idx) : T*
        + add(T*) : void
        + del(idx) : void
    }

    class "tnmap<K, T>" as tnmap {
        - _map : map<K, T*>
        ---
        + operator[](key) : T*
        + add(key, T*) : void
        + in(key) : nbool
    }

    class "tnseq<T>" as tnseq {
        - _start : T
        - _end : T
        - _step : T
        ---
        + operator[](idx) : T
        + len() : ncnt
    }

    class "tnchain<T, Container>" as tnchain {
        - _container : Container
        - _next : tnchain*
        - _prev : tnchain*
        ---
        + link(tnchain&) : void
        + getNext() : tnchain*
        + getPrev() : tnchain*
        + operator[](key) : T*
    }
}

package "Script Type" {
    class "arr" as arr {
        Inherits tnarr<node>
        For byeol runtime environment
    }

    class "map" as map {
        Inherits tnmap<key, node>
        For byeol runtime environment
    }

    class "seq" as seq {
        Inherits tnseq<node>
        For byeol runtime environment
    }
}

tucontainable <|.. tnarr
tucontainable <|.. tnseq
tbicontainable <|.. tnmap
tbicontainable <|.. tnchain

tnarr <|-- arr
tnmap <|-- map
tnseq <|-- seq
@enduml
@startuml inline_umlgraph_24.png
object "chn1" as chn1 {
    _container = tnmap
    {"0": node(0), "1": node(1)}
    _next = chn2
    _prev = null
}

object "chn2" as chn2 {
    _container = tnmap
    {"6": node(6), "5": node(5)}
    _next = chn3
    _prev = chn1
}

object "chn3" as chn3 {
    _container = tnmap
    {"2": node(2), "3": node(3)}
    _next = null
    _prev = chn2
}

note top of chn1
  <b>Linked List structure of tnchain:</b>

  Each tnchain:
  1. Owns defaultContainer (tnmap, etc.)
  2. Linked by next, prev pointers
  3. Looks like a single flattened map from outside
end note

note bottom of chn2
  <b>link() operation:</b>

  chn1.link(chn2);  // chn1._next = chn2
                    // chn2._prev = chn1

  chn2.link(chn3);  // chn2._next = chn3
                    // chn3._prev = chn2

  <b>When traversing:</b>
  Traversing from chn1
  Access in order {0, 1, 6, 5, 2, 3}
  (Traverse chn1 → chn2 → chn3)
end note

note right of chn3
  <b>Usage example:</b>

  // Search "2" in chn1
  chn1["2"]
  → Search chn1._container (Not found)
  → Search chn2._container (Not found)
  → Search chn3._container (Found!)
  → Return node(2)

  <b>Facade Pattern:</b>
  Complex linked list structure
  Abstracted as simple bicontainer
end note

chn1 -right-> chn2 : next
chn2 -right-> chn3 : next
chn2 -left-> chn1 : prev
chn3 -left-> chn2 : prev
@enduml
@startuml inline_umlgraph_25.png
participant "User Code" as user
participant "getGenericExpr" as expr
participant "genericOrigin" as genOrigin
participant "map<type, origin>" as cache
participant "generalizer" as gen
participant "Original origin" as org

user -> expr : Call MyByeol<int>()
activate expr

expr -> genOrigin : get(nInt&)
activate genOrigin

genOrigin -> cache : Search key "nInt"
activate cache

alt In cache
    cache --> genOrigin : Return existing origin
    note right
      <b>Cache Hit!</b>
      Reuse already created origin
    end note

else Not in cache
    cache --> genOrigin : Return nullptr

    genOrigin -> org : deepClone()
    activate org
    org --> genOrigin : origin copy
    deactivate org

    genOrigin -> gen : generalize(copy, T→nInt)
    activate gen

    note right of gen
      <b>AST Transformation:</b>
      1. Traverse entire AST
      2. Find getExpr("T") node
      3. Replace with getExpr("nInt")
    end note

    loop Each node in AST
        gen -> gen : visit(node)
        alt Found getExpr("T")
            gen -> gen : Replace node with getExpr("nInt")
        end
    end

    gen --> genOrigin : Transformed origin
    deactivate gen

    genOrigin -> cache : add(nInt, transformed origin)
    note right
      <b>Cache Store</b>
      Save for next request
    end note
end

deactivate cache

genOrigin --> expr : MyByeol<int>
deactivate genOrigin

expr --> user : Return origin
deactivate expr
@enduml
@startuml inline_umlgraph_26.png
package "Native Environment (C++)" {
    class "window" as window {
        - _y : int
        ---
        + getX() : int
        + getY() : int
        + setY(int) : void
        + new1(int) : window&
    }

    class "openGL" as openGL {
        + init(window*) : int
    }
}

package "Bridging Layer" {
    class "tbridger<T>" as tbridger {
        {static} - _staticSubs : nchain
        {static} - _staticOrigin : origin*
        ---
        + ctor() : tbridger&
        + func(name, funcPtr) : tbridger&
        + make(T*) : node*
        ---
        {static} + _get() : tbridger&
    }

    class "tbridge<T>" as tbridge {
        - _native : T*
        ---
        + eval(name, args) : str
        + subs() : scope&
    }

    class "tbridgeFunc" as tbridgeFunc {
        - _funcPtr : FuncPtr
        ---
        + eval(args) : str
        + run(args) : str
    }

    class "tbridgeCtor" as tbridgeCtor {
        + eval(args) : str
        + run(args) : str
    }

    class "tmarshaling<From, To>" as tmarshaling {
        + wrap(From) : To
        + unwrap(To) : From
    }
}

package "byeol Runtime Environment" {
    class "baseObj" as baseObj {
        + eval(name, args) : str
        + subs() : scope&
    }

    class "origin" as origin {
        + subs() : scope&
    }

    class "nInt" as nInt
    class "nStr" as nStr
}

window .right.> tbridger : Register
openGL .right.> tbridger : Register

tbridger ..> tbridge : Create
tbridger *-- "n" tbridgeFunc
tbridger *-- "n" tbridgeCtor

tbridge --|> baseObj
tbridge *--> window
tbridgeFunc ..> tmarshaling : Use
tbridgeCtor ..> tmarshaling : Use

tbridge ..> origin

nInt .up.> tmarshaling : Convert to c++ int
nStr .up.> tmarshaling : Convert to c++ std::string
@enduml
@startuml inline_umlgraph_27.png
actor "Byeol Code" as byeol
participant "tbridge<window>" as tbridge
participant "tbridgeFunc" as tbridgeFunc
participant "tmarshaling" as tmarshaling
participant "window (C++)" as window

== Registration Phase (Program Start) ==

note over tbridge, window
  <b>Register in C++ Code:</b>

  tbridger<window>::ctor()
    .func("setY", &window::setY)

  tbridgeFunc is created at this point
  Saved in static subs of tbridger
end note

== Call Phase (Runtime) ==

byeol -> tbridge : win.setY(20)
activate byeol
activate tbridge

note right of byeol
  <b>Byeol Code:</b>
  win := window()
  win.setY(20)

  → eval("setY", args)
end note

tbridge -> tbridge : Search "setY" in subs
note right of tbridge
  subs refers to
  tbridger's static origin

  "setY" → tbridgeFunc found
end note

tbridge -> tbridge : _onEvalSub()
note right of tbridge
  <b>Inject this into args:</b>
  args.setMe(this)

  So function can know
  the object that called it
end note

tbridge -> tbridgeFunc : eval(args)
activate tbridgeFunc

note right of tbridgeFunc
  <b>args content:</b>
  - setMe: tbridge object
  - Parameter: nInt(20)
end note

== Marshaling: Script → Native ==

tbridgeFunc -> tmarshaling : unwrap(nInt(20))
activate tmarshaling

note right of tmarshaling
  <b>Type Conversion:</b>
  nInt → int

  Convert script type
  to native type
end note

tmarshaling --> tbridgeFunc : int(20)
deactivate tmarshaling

tbridgeFunc -> tbridge : Get _native pointer
tbridge --> tbridgeFunc : window*

== Native Function Call ==

tbridgeFunc -> window : window->setY(20)
activate window

note right of window
  <b>Execute actual C++ function:</b>
  Via member function pointer
  Execute native code

  _y = 20
end note

window --> tbridgeFunc : void
deactivate window

== Marshaling: Native → Script ==

tbridgeFunc -> tmarshaling : wrap(void)
activate tmarshaling

note right of tmarshaling
  <b>Return value conversion:</b>
  If void
  Return nulOf()
end note

tmarshaling --> tbridgeFunc : str(nulOf())
deactivate tmarshaling

tbridgeFunc --> tbridge : str(nulOf())
deactivate tbridgeFunc

tbridge --> byeol : str(nulOf())
deactivate tbridge
deactivate byeol

note over byeol, window
  <b>Core of Marshaling Process:</b>

  1. <b>Unwrap (Script → Native):</b>
     - nInt → int
     - nStr → string
     - tbridge<T> → T*

  2. <b>Native Function Execution:</b>
     - Called via member function pointer
     - Executes actual C++ code

  3. <b>Wrap (Native → Script):</b>
     - int → nInt
     - string → nStr
     - T* → tbridge<T>

  <b>With automatic type conversion:</b>
  - Byeol code doesn't need to know native types
  - C++ code doesn't need to know script types
  - Complete transparency
end note

== Example with return value ==

byeol -> tbridge : res := win.getY()
activate byeol
activate tbridge

tbridge -> tbridgeFunc : eval(args)
activate tbridgeFunc

tbridgeFunc -> window : window->getY()
activate window

window --> tbridgeFunc : int(20)
deactivate window

tbridgeFunc -> tmarshaling : wrap(20)
activate tmarshaling

note right of tmarshaling
  Convert int → nInt
end note

tmarshaling --> tbridgeFunc : str(nInt(20))
deactivate tmarshaling

tbridgeFunc --> tbridge : str(nInt(20))
deactivate tbridgeFunc

tbridge --> byeol : str(nInt(20))
deactivate tbridge

note right of byeol
  res is now nInt(20)
  Available in byeol code
end note

deactivate byeol
@enduml
@startuml inline_umlgraph_28.png
class thread {
    - _frames : frames
    - _errReport : errReport*
    + {static} get() : thread&
    + getFrames() : frames&
    + getReport() : errReport&
    --
    <b>Singleton Pattern</b>
    thread-local storage
}

class frames {
    - _container : vector<frame*>
    + add(frame&) : void
    + del(frame&) : void
    + len() : nint
    + operator[](nidx) : frame&
    --
    Manage frame stack
    Track function calls
}

class frame {
    - _scopes : scope
    + subs() : scope&
    + inFrame() : void
    + outFrame() : void
    --
    <b>RAII Pattern</b>
    Register/Unregister to frames
    On creation/destruction
}

class scope {
    - _container : tnchain
    + add(key, node&) : void
    + get(key) : node*
    + link(scope&) : void
    --
    <b>Chain of Responsibility</b>
    Link with tnchain
}

class tnchain {
    - _next : tnchain*
    - _prev : tnchain*
    - _defaultContainer : Container
    + link(tnchain&) : void
    + get(key) : T*
    --
    <b>Linked List</b>
    Link scopes
}

thread "1" *-- "1" frames
frames "1" *-- "0..*" frame : Manage
frame "1" *-- "1..*" scope : Integrate
scope "1" *-- "1" tnchain : Base
@enduml
@startuml inline_umlgraph_29.png
start

:Request search by symbol name;

:Get current thread\nwith thread::get();

:Get frames\nwith thread.getFrames();

:Get top frame of frames;

:Get scope chain\nwith frame.subs();

partition "Chain of Responsibility" {
    repeat
        :Search symbol in current scope;

        if (Symbol found?) then (Yes)
            :Return symbol;
            stop
        endif

        :Get next scope\nwith scope.getNext();

    repeat while (Next scope exists?)
}

:Symbol not found;

:Return nullptr or error;

stop
@enduml
@startuml inline_umlgraph_30.png
actor "User Code" as user
participant "slotLoader" as loader
participant "autoslot" as autoslot
participant "packLoading" as packLoading
participant "manifest" as manifest
participant "File System" as fs

== Pack Registration Phase ==

user -> loader : addPack("mylib")
activate loader

loader -> fs : Find manifest.stela
activate fs

fs --> loader : manifest file
deactivate fs

loader -> manifest : Parse
activate manifest

note right of manifest
  <b>Manifest Content:</b>
  - name: "mylib"
  - version: "1.0.0"
  - dependencies: ["core"]
  - entrypoint: "byeol" or "cpp"
end note

manifest --> loader : manifest object
deactivate manifest

loader -> packLoading : Create (native/script)
activate packLoading

note right of packLoading
  <b>packLoading Type:</b>
  - .byeol file → script
  - .so/.dll file → native
  - or both
end note

packLoading --> loader : packLoading[]
deactivate packLoading

loader -> autoslot : Create (RELEASED state)
activate autoslot

note right of autoslot
  <b>Initial State:</b>
  state = RELEASED
  No memory occupation
  Store packLoadings only
end note

autoslot --> loader : autoslot object
deactivate autoslot

loader -> loader : Register dependencies
note right of loader
  Recursively load
  dependencies from manifest
end note

loader --> user : Registration complete
deactivate loader

== Lazy Loading Phase (On symbol access) ==

user -> autoslot : Access mylib.someFunc()
activate autoslot

note right of user
  <b>Lazy Loading Trigger:</b>
  Delay loading
  until actual usage
end note

autoslot -> autoslot : state == RELEASED?
note right of autoslot
  Since it's first access
  start loading
end note

== PARSED Phase ==

autoslot -> packLoading : parse()
activate packLoading

packLoading -> fs : Read .byeol file
activate fs

fs --> packLoading : Source code
deactivate fs

packLoading -> packLoading : Run parser
note right of packLoading
  Create AST
  (Skip for native pack)
end note

packLoading --> autoslot : AST
deactivate packLoading

autoslot -> autoslot : state = PARSED

== VERIFIED Phase ==

autoslot -> packLoading : verify()
activate packLoading

packLoading -> packLoading : Run verification
note right of packLoading
  <b>Verification Items:</b>
  - Type checking
  - Syntax verification
  - Dependency check
end note

alt Verification Success

    packLoading --> autoslot : isValid = true
    autoslot -> autoslot : state = VERIFIED

else Verification Failed

    packLoading --> autoslot : isValid = false
    autoslot -> autoslot : state = VERIFIED\n(Mark as failed)

end

deactivate packLoading

== LINKED Phase ==

autoslot -> packLoading : link()
activate packLoading

alt isValid == true

    packLoading -> packLoading : Linking complete
    packLoading --> autoslot : Success

    autoslot -> autoslot : state = LINKED

else isValid == false

    packLoading --> autoslot : Failure

    autoslot -> autoslot : state = LINKED\nPropagate to dependent packs

    note right of autoslot
      <b>Failure Propagation:</b>
      Propagate failure fact
      to all dependents
      that rely on this pack
    end note

end

deactivate packLoading

autoslot --> user : Return symbol or error
deactivate autoslot
@enduml
@startuml inline_umlgraph_31.png
[*] --> RELEASED : Create autoslot

state RELEASED {
    RELEASED : Initial state
    RELEASED : No memory occupation
    RELEASED : Most slots are in this state
}

state PARSED {
    PARSED : Code parsing complete
    PARSED : AST created
    PARSED : Native pack skips this step
}

state VERIFIED {
    VERIFIED : Code verification complete
    VERIFIED : Type checking complete
    VERIFIED : isValid flag set
}

state LINKED {
    LINKED : Final state
    LINKED : Ready for execution
    LINKED : Propagate to dependent pack on verification failure
}

RELEASED --> PARSED : On symbol access\npackLoading.parse()
RELEASED --> LINKED : native/optimized pack\nParsing unnecessary

PARSED --> VERIFIED : packLoading.verify()

VERIFIED --> LINKED : packLoading.link()

note right of RELEASED
  <b>Lazy Loading:</b>
  Delay loading
  until used
end note

note right of PARSED
  <b>Conditional Transition:</b>
  - .byeol file: Go through PARSED
  - .so/.dll file: Go straight to LINKED
end note

note bottom of VERIFIED
  <b>On Verification Failure:</b>
  Set isValid = false
  Propagate failure
  to dependent packs in LINKED phase
end note

note right of LINKED
  <b>Dependency Propagation:</b>
  If verification failed
  Mark all packs
  depending on this as failed
end note
@enduml
@startuml inline_umlgraph_32.png
participant "Client" as client
participant "visitor" as visitor
participant "func (node)" as func
participant "blockExpr (node)" as block
participant "assignExpr (node)" as assign

client -> func : accept(visitor)
activate func

note right of client
  <b>AST Structure:</b>
  func
    └─ blockExpr
        ├─ assignExpr
        └─ assignExpr
end note

== Visit func (Pre-order) ==

func -> visitor : visit(visitInfo, *this)
activate visitor

note right of func
  <b>Double Dispatch:</b>
  1st: func.accept(visitor)
  2nd: visitor.visit(func&)
end note

visitor -> visitor : 1. onVisit(func&)
activate visitor #lightblue

note right of visitor
  <b>Template Method Step 1:</b>
  Process current node visit
  Perform specific action for func
end note

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 2. onTraverse(func&)
activate visitor #lightgreen

note right of visitor
  <b>Template Method Step 2:</b>
  Traverse child nodes
  Access func.subs()
end note

visitor -> func : subs()
func --> visitor : scope& (blockExpr etc)

visitor -> block : accept(visitor)
activate block

== Visit blockExpr (Recursive) ==

block -> visitor : visit(visitInfo, *this)

visitor -> visitor : 1. onVisit(blockExpr&)
activate visitor #lightblue

note right of visitor
  Process blockExpr visit
end note

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 2. onTraverse(blockExpr&)
activate visitor #lightgreen

note right of visitor
  Traverse children of blockExpr
  Traverse _stmts array
end note

visitor -> block : subs() / _stmts
block --> visitor : narr (assignExprs)

visitor -> assign : accept(visitor)
activate assign

== Visit assignExpr ==

assign -> visitor : visit(visitInfo, *this)

visitor -> visitor : 1. onVisit(assignExpr&)
activate visitor #lightblue

note right of visitor
  Process assignExpr visit
end note

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 2. onTraverse(assignExpr&)
activate visitor #lightgreen

note right of visitor
  Traverse children of assignExpr
  (lhs, rhs)
end note

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 3. onLeave(assignExpr&)
activate visitor #lightyellow

note right of visitor
  <b>Template Method Step 3:</b>
  Leave current node
  Cleanup assignExpr
end note

visitor --> visitor : void
deactivate visitor

visitor --> assign : void
assign --> visitor : void
deactivate assign

== Continue traversing blockExpr ==

note right of visitor
  Visit other assignExprs
  in the same way
end note

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 3. onLeave(blockExpr&)
activate visitor #lightyellow

note right of visitor
  Leave blockExpr
end note

visitor --> visitor : void
deactivate visitor

visitor --> block : void
block --> visitor : void
deactivate block

== func traversal complete ==

visitor --> visitor : void
deactivate visitor

visitor -> visitor : 3. onLeave(func&)
activate visitor #lightyellow

note right of visitor
  Leave func
  Traversal complete
end note

visitor --> visitor : void
deactivate visitor

visitor --> func : void
deactivate visitor

func --> client : Traversal complete
deactivate func
@enduml
@startuml inline_umlgraph_33.png
participant "Client" as client
participant "visitor\n(verifier)" as visitor
participant "node*\n(Runtime Type:\nnInt)" as node
participant "nInt" as nInt

client -> visitor : visit(visitInfo, node*)
activate visitor

note right of visitor
  <b>Problem:</b>
  Only know node* type
  Don't know actual type (nInt)
end note

visitor -> node : accept(visitInfo, *this)
activate node

note right of node
  <b>First Dispatch:</b>
  Virtual function dynamic binding
  Call accept() of
  actual type (nInt) at runtime
end note

node -> nInt : nInt::accept(visitInfo, visitor)
activate nInt

nInt -> visitor : visitor.visit(visitInfo, *this)

note left of nInt
  <b>Second Dispatch:</b>
  *this is nInt& type
  Compile-time overload resolution
  Call visitor::visit(visitInfo, nInt&)
end note

activate visitor

visitor -> visitor : onVisit(visitInfo, nInt&)

note right of visitor
  <b>Success!</b>
  Execute visit logic
  specialized for concrete type (nInt)
end note

deactivate visitor

nInt --> node
deactivate nInt
node --> visitor
deactivate node
visitor --> client
deactivate visitor
@enduml
@startuml inline_umlgraph_34.png
actor "User" as user
participant "parser" as parser
participant "expander" as expander
participant "verifier" as verifier
participant "interpreter" as interpreter
participant "AST" as ast

== 1. Parsing Phase ==

user -> parser : Provide source code
activate parser

parser -> ast : Create AST
activate ast

note right of ast
  <b>Initial AST:</b>
  - func, obj, expr etc
  - Still incomplete
  - Generic type undetermined
end note

ast -> parser: created ast
deactivate ast

parser --> user : AST
deactivate parser

== 2. Expansion Phase ==

user -> expander : Request AST expansion
activate expander

note right of expander
  <b>Expander:</b>
  - Instantiate Generic type
  - Resolve Auto type
  - Complete AST
end note

expander -> ast : Modify/Expand AST
activate ast
ast --> expander : Completed AST
deactivate ast

expander --> user : Completed AST
deactivate expander

== 3. Verification Phase ==

user -> verifier : Request AST verification
activate verifier

verifier -> verifier : setTask(ast)
verifier -> verifier : work()

loop Traverse AST (Visitor Pattern)

    verifier -> ast : visit(node)
    activate ast

    verifier -> verifier : onVisit(node)

    note right of verifier
      <b>Type Inference:</b>
      Use infer() instead of eval()
    end note

    verifier -> ast : infer()
    ast --> verifier : Type info (origin)

    note right of verifier
      <b>Type Checking:</b>
      - Check type matching
      - Implicit conversion possibility
      - Resolve function overloading
    end note

    alt Type Error Found
        verifier -> verifier : Add to errReport
        note right of verifier
          Collect errors
          and continue traversing
        end note
    end

    verifier -> verifier : onLeave(node)

    ast --> verifier : void
    deactivate ast

end

verifier -> verifier : Judge verification completion

alt Errors exist
    verifier --> user : Verification failed\nReturn errReport
else No errors
    verifier --> user : Verification success
end

deactivate verifier

== 4. Execution Phase ==

user -> interpreter : Request execution
activate interpreter

interpreter -> ast : eval()
activate ast

ast -> ast : Recursive eval()
ast --> interpreter : Execution result (str)
deactivate ast

interpreter --> user : Execution result
deactivate interpreterp
@enduml
@startuml inline_umlgraph_35.png
package "Callstack Composition" {
    class "frames" as frames {
        - _stack : tnarr<frame>
        ---
        + pushFrame() : void
        + popFrame() : void
        + getFrames() : narr
    }

    class "frame" as frame {
        - _funcName : string
        - _args : args
        - _src : src
        ---
        + getName() : string
        + getArgs() : args
        + getSrc() : src
    }

    class "baseErr" as baseErr {
        - _frames : tstr<frames>
        - _msg : string
        ---
        + dump() : void
        + log() : void
    }

    class "nerr" as nerr {
        - _code : errCode
        ---
        + dump() : void
    }

    class "errReport" as errReport {
        - _errs : narr
        - _noisy : nbool
        ---
        + add(baseErr*) : void
        + len() : ncnt
        + setNoisy(nbool) : void
    }

    class "errCode" as errCode {
        + IS_NUL : 2203
        + TYPE_MISMATCH : 2401
        + ...
    }
}

note top of frames
  <b>Callstack Stack:</b>
  Push frame on every function call
  Pop frame on function exit

  [frame1, frame2, frame3]
  Stack structure
end note

note right of frame
  <b>Frame Info:</b>
  - Function name
  - Arguments
  - Call location (src)

  One step of callstack
end note

note right of errReport
  <b>Error Collector:</b>
  Collect all errors
  occurred during task

  noisy == true:
  Log immediately when error added
end note

frames *-- "n" frame
baseErr *-- frames
nerr --|> baseErr
errReport o-- "n" baseErr : Collect
nerr --> errCode : Use
@enduml
@startuml inline_umlgraph_36.png
participant "verifier/parser" as worker
participant "node" as node
participant "nerr" as nerr
participant "frames" as frames
participant "frame" as frame
participant "errReport" as errReport

== Callstack Composition (Normal Execution) ==

worker -> node : func.eval(args)
activate node

node -> frames : pushFrame()
activate frames

frames -> frame : Create (funcName, args)
activate frame

frame --> frames : tstr<frame>
frames -> frames : Push to _stack

note right of frames
  <b>Callstack:</b>
  [frame1, frame2, ...]
  Function call stack
end note

frames --> node : void
deactivate frames

== Error Occurrence ==

node -> node : stmt executing...

alt stmt is nullptr
    node -> node : Detect WHEN_NUL(stmt)
    node -> nerr : Create (IS_NUL, "stmt")
    activate nerr

    nerr -> frames : getFrames()
    frames --> nerr : tstr<frames>

    nerr -> nerr : Capture callstack
    note right of nerr
      Save current callstack
      via frames
    end note

    nerr --> node : nerr*
    deactivate nerr

== Error Propagation ==

    node -> errReport : add(nerr)
    activate errReport

    note right of errReport
      <b>Collect Error:</b>
      Collect error
      and continue task
    end note

    alt noisy == true
        errReport -> nerr : log()
        note right of nerr
          Immediate logging
          Easier debugging
        end note
    end

    errReport --> node : void
    deactivate errReport

    note right of node
      <b>Early Return:</b>
      Terminate C++ function immediately
      with `ret(blk)` of WHEN macro
    end note

    node --> worker : Return error
    deactivate node

end

== Function Exit (Normal/Error) ==

worker -> frames : popFrame()
activate frames

frames -> frames : Pop from _stack
frames -> frame : del()
frame --> frames : void
frames --> worker : void
deactivate frames

== Error Handling & Output ==

worker -> errReport : Errors exist?
activate errReport

errReport --> worker : true (Errors exist)
deactivate errReport

worker -> errReport : Traverse all errors
activate errReport

loop Each error

    errReport -> nerr : dump()
    activate nerr

    note right of nerr
      <b>Print Callstack:</b>
      Print callstack info
      via frames referenced by nerr

      e.g.
        at func1() in file.byeol:10
        at func2() in file.byeol:20
        at main() in file.byeol:30
    end note

    nerr -> frames : Each frame info
    activate frames

    frames -> frame : getName(), getSrc()
    activate frame

    frame --> frames : Function name, location
    deactivate frame

    frames --> nerr : callstack info
    deactivate frames

    nerr -> nerr : Print log

    nerr --> errReport : void
    deactivate nerr

end

errReport --> worker : void
deactivate errReport

note right of worker
  <b>Error Handling Complete:</b>
  Print all errors
  Stop task
end note

deactivate frame
@enduml
@startuml inline_umlgraph_37.png
package "Core Module" {
    class "tworker<programRes, flagArgs>" as tworker {
    }
    class interpreter {
    }
    class starter {
    }
    class errReport {
    }
}

package "Frontend Module" {
    class cli {
        + getFlags() : const flags&
        # _onWork() : programRes
        - _evalArgs(...) : flag::res
    }

    class flagArgs {
    }

    abstract class flag {
        + take(...) : res
    }

    cli --|> tworker
    cli ..> interpreter : Create
    cli ..> starter : Create
    cli ..> errReport : Create
    cli ..> flagArgs
    cli "1" *-- "many" flag : Manage
}
@enduml
@startuml inline_umlgraph_38.png
actor User
participant "cli" as cli
participant "flagArgs" as flags
participant "interpreter" as ip
participant "errReport" as report
participant "starter" as st

User -> cli : eval(flagArgs)
activate cli

cli -> ip : new interpreter()
cli -> report : new errReport()
cli -> st : new starter()

cli -> ip : setFlag(tworker flag)
cli -> st : setFlag(tworker flag)

cli -> flags : Pattern Matching
activate flags
note right of flags
  This part will be covered in detail later.
end note
flags -> cli: Complete
deactivate flags

cli -> ip : work()
activate ip
ip -> ip : Parse source
ip -> ip : Expand type
ip -> ip : Verify AST
ip --> cli : Return
deactivate ip

alt Verification Failed
    cli -> report : Dump error
    cli --> User : Exit with error
else Verification Succeeded
    cli -> st : setTask(Verified AST)
    cli -> st : work()
    activate st
    st -> st : Execute main()
    st --> cli : Return result
    deactivate st

    cli --> User : Return result
end

deactivate cli
@enduml
@startuml inline_umlgraph_39.png
abstract class flag {
    + take(flagArgs, cli, interpreter, starter) : res
    # {abstract} _getRegExpr() : strings&
    # {abstract} _onTake(flagArgs, cli, interpreter, starter) : res
    # getArgCount() : ncnt
}

note right of flag
  Template Method Pattern:
  take() defines algorithm skeleton
  _getRegExpr(), _onTake() are
  implemented by subclasses
end note

class verFlag {
    # _getRegExpr() : strings&
    # _onTake() : res
    --
    Regex: "^\\\\--version$"
    Return: EXIT_PROGRAM
}

class helpFlag {
    # _getRegExpr() : strings&
    # _onTake() : res
    --
    Regex: "^\\\\-h$", "^\\\\--help$"
    Return: EXIT_PROGRAM
}

class bufferSrcFlag {
    # _getRegExpr() : strings&
    # _onTake() : res
    # getArgCount() : ncnt
    --
    Regex: "^\\\\--script$"
    Arg Count: 1
    Return: MATCH
}

class logStructureFlag {
    # _getRegExpr() : strings&
    # _onTake() : res
    --
    Regex: "^\\\\-S$", "^\\\\--show-structure$"
    Return: MATCH
}

class fileSrcFlag {
    # _getRegExpr() : strings&
    # _onTake() : res
    # getArgCount() : ncnt
    --
    Regex: "^[^\\\\-].*\\\\.byeol$"
    Return: MATCH
}

flag <|-- verFlag
flag <|-- helpFlag
flag <|-- bufferSrcFlag
flag <|-- logStructureFlag
flag <|-- fileSrcFlag

note bottom of verFlag
  Print version info and
  exit program immediately
end note

note bottom of bufferSrcFlag
  Consume 1 additional argument
  Add code string as bufSupply
end note
@enduml
@startuml inline_umlgraph_40.png
participant "cli" as c
participant "arguments" as a
participant "flag" as f

== Preparation ==

c -> a: Create from argv
activate a
a --> c: new arguments()
deactivate a

c -> f: Acquire array containing all flag objects.
activate f
f --> c: new flags{helpFlag, verFlag.....}
deactivate f


== Consume Arguments ==

c -> c: _evalArgs()
activate c

loop For each element f in flags
  c -> f: take(arguments)
  activate f
  f -> f: Get pattern string
  f -> f: Does pattern match arguments?
  alt Match Failed
    f --> c: take failed.
  else Match Succeeded
    f -> f: Execute action with _onTake()
    f -> a: Delete matched pattern
    activate a
    a --> f: Deleted.
    deactivate a
    f --> c: take(arguments) complete.
    deactivate f
  end
end
deactivate c
@enduml
