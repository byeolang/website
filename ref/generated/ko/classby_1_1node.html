<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: by::node 클래스 참조</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'검색','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classby_1_1node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 멤버 함수</a> &#124;
<a href="#pub-attribs">Public 속성</a> &#124;
<a href="#pro-methods">Protected 멤버 함수</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classby_1_1node-members.html">모든 멤버 목록</a>  </div>
  <div class="headertitle"><div class="title">by::node 클래스 참조<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__core.html">Core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all AST nodes in the byeol language  
 <a href="classby_1_1node.html#details">더 자세히 ...</a></p>

<p><code>#include &lt;<a class="el" href="node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<div class="dynheader">
by::node에 대한 상속 다이어그램 : </div>
<div class="dyncontent">
 <div class="center">
  <img src="classby_1_1node.png" usemap="#by::node_map" alt=""/>
  <map id="by::node_map" name="by::node_map">
<area href="classby_1_1instance.html" title="Base class for all managed instances in memlite system" alt="by::instance" shape="rect" coords="1449,56,1761,80"/>
<area href="classby_1_1frame_interactable.html" title="Interface for frame interaction" alt="by::frameInteractable" shape="rect" coords="1771,56,2083,80"/>
<area href="classby_1_1type_providable.html" title="Interface for objects that can provide their type information" alt="by::typeProvidable" shape="rect" coords="1288,0,1600,24"/>
<area href="classby_1_1clonable.html" title="Interface for objects that can be cloned" alt="by::clonable" shape="rect" coords="1610,0,1922,24"/>
<area href="classby_1_1base_func.html" title="Base class for all function types" alt="by::baseFunc" shape="rect" coords="0,168,312,192"/>
<area href="classby_1_1base_obj.html" title="Base class for representing byeol objects" alt="by::baseObj" shape="rect" coords="644,168,956,192"/>
<area href="classby_1_1expr.html" title="Base class for all expressions" alt="by::expr" shape="rect" coords="1288,168,1600,192"/>
<area href="classby_1_1frame.html" title="Execution frame" alt="by::frame" shape="rect" coords="1610,168,1922,192"/>
<area href="classby_1_1slot.html" title="Pack slot" alt="by::slot" shape="rect" coords="1932,168,2244,192"/>
<area href="classby_1_1src_file.html" title="Source code file information" alt="by::srcFile" shape="rect" coords="2254,168,2566,192"/>
<area href="classby_1_1thread.html" title="Thread execution context for byeol runtime" alt="by::thread" shape="rect" coords="2576,168,2888,192"/>
<area href="classby_1_1tbase_bridge_func.html" alt="by::tbaseBridgeFunc&lt; Ret, T, Marshaling, Args... &gt;" shape="rect" coords="322,224,634,248"/>
<area href="classby_1_1tbase_bridge_func.html" alt="by::tbaseBridgeFunc&lt; void, T, Marshaling, Args... &gt;" shape="rect" coords="322,280,634,304"/>
<area href="classby_1_1base_ctor.html" title="Base class for all constructor types" alt="by::baseCtor" shape="rect" coords="322,336,634,360"/>
<area href="classby_1_1closure.html" title="func closure with captured object scope" alt="by::closure" shape="rect" coords="322,392,634,416"/>
<area href="classby_1_1func.html" title="Function definition in byeol language" alt="by::func" shape="rect" coords="322,448,634,472"/>
<area href="classby_1_1input_func.html" title="Input function for reading user input" alt="by::inputFunc" shape="rect" coords="322,504,634,528"/>
<area href="classby_1_1print_func.html" title="Template print function for output operations" alt="by::printFunc&lt; T &gt;" shape="rect" coords="322,560,634,584"/>
<area href="classby_1_1tbase_bridge_func.html" title="Base bridge function template" alt="by::tbaseBridgeFunc&lt; Ret, T, Marshaling, Args &gt;" shape="rect" coords="322,616,634,640"/>
<area href="classby_1_1tbridge_closure.html" title="Bridge closure for C++ lambda/function objects" alt="by::tbridgeClosure&lt; Ret, T, Marshaling, Args &gt;" shape="rect" coords="322,672,634,696"/>
<area href="classby_1_1tbridge_closure_3_01void_00_01_t_00_01_marshaling_00_01_args_8_8_8_01_4.html" title="Bridge closure specialization for void return type" alt="by::tbridgeClosure&lt; void, T, Marshaling, Args... &gt;" shape="rect" coords="322,728,634,752"/>
<area href="classby_1_1tbridge.html" alt="by::tbridge&lt; narr &gt;" shape="rect" coords="966,224,1278,248"/>
<area href="classby_1_1base_err.html" title="Base class for error hierarchy" alt="by::baseErr" shape="rect" coords="966,280,1278,304"/>
<area href="classby_1_1generic_origin.html" alt="by::genericOrigin" shape="rect" coords="966,336,1278,360"/>
<area href="classby_1_1obj.html" title="Managed environment object" alt="by::obj" shape="rect" coords="966,392,1278,416"/>
<area href="classby_1_1scalar.html" title="Base class for arithmetic operations on primitive types" alt="by::scalar" shape="rect" coords="966,448,1278,472"/>
<area href="classby_1_1tbridge.html" title="C++ native class bridge" alt="by::tbridge&lt; T &gt;" shape="rect" coords="966,504,1278,528"/>
<area href="classby_1_1_f_b_o_expr.html" title="Fundamental Binary Operator expression" alt="by::FBOExpr" shape="rect" coords="1610,224,1922,248"/>
<area href="classby_1_1_f_u_o_expr.html" title="Fundamental Unary Operator expression" alt="by::FUOExpr" shape="rect" coords="1610,280,1922,304"/>
<area href="classby_1_1as_expr.html" title="Type casting expression" alt="by::asExpr" shape="rect" coords="1610,336,1922,360"/>
<area href="classby_1_1assign_expr.html" title="Assignment expression" alt="by::assignExpr" shape="rect" coords="1610,392,1922,416"/>
<area href="classby_1_1block_expr.html" title="Block expression" alt="by::blockExpr" shape="rect" coords="1610,448,1922,472"/>
<area href="classby_1_1def_array_expr.html" title="Array literal expression" alt="by::defArrayExpr" shape="rect" coords="1610,504,1922,528"/>
<area href="classby_1_1def_nested_func_expr.html" title="Nested function definition expression" alt="by::defNestedFuncExpr" shape="rect" coords="1610,560,1922,584"/>
<area href="classby_1_1def_seq_expr.html" title="Sequence definition expression" alt="by::defSeqExpr" shape="rect" coords="1610,616,1922,640"/>
<area href="classby_1_1def_var_expr.html" title="Variable definition expression base class" alt="by::defVarExpr" shape="rect" coords="1610,672,1922,696"/>
<area href="classby_1_1eval_expr.html" title="Function/method call expression" alt="by::evalExpr" shape="rect" coords="1610,728,1922,752"/>
<area href="classby_1_1get_expr.html" title="Expression for property and method access" alt="by::getExpr" shape="rect" coords="1610,784,1922,808"/>
<area href="classby_1_1if_expr.html" title="If conditional expression" alt="by::ifExpr" shape="rect" coords="1610,840,1922,864"/>
<area href="classby_1_1is_expr.html" title="ntype checking expression" alt="by::isExpr" shape="rect" coords="1610,896,1922,920"/>
<area href="classby_1_1loop_expr.html" title="Base class for loop expressions" alt="by::loopExpr" shape="rect" coords="1610,952,1922,976"/>
<area href="classby_1_1ret_state_expr.html" title="Base class for keywords that exit blockExpr" alt="by::retStateExpr" shape="rect" coords="1610,1008,1922,1032"/>
<area href="classby_1_1autoslot.html" title="Automatic pack loading slot" alt="by::autoslot" shape="rect" coords="1932,224,2244,248"/>
<area href="classby_1_1dum_src_file.html" title="Dummy source file implementation" alt="by::dumSrcFile" shape="rect" coords="2254,224,2566,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 멤버 함수</h2></td></tr>
<tr class="memitem:a7691d658e3632d05ed6a1a9ba9535a45"><td class="memItemLeft" align="right" valign="top"><a id="a7691d658e3632d05ed6a1a9ba9535a45" name="a7691d658e3632d05ed6a1a9ba9535a45"></a>
me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a7691d658e3632d05ed6a1a9ba9535a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fa77f164eb7d65c244041125bfc51f"><td class="memItemLeft" align="right" valign="top"><a id="a62fa77f164eb7d65c244041125bfc51f" name="a62fa77f164eb7d65c244041125bfc51f"></a>
const me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string &amp;name) const BY_CONST_FUNC(operator[](name))</td></tr>
<tr class="separator:a62fa77f164eb7d65c244041125bfc51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5974af181fe20259371964a1bfd4613"><td class="memItemLeft" align="right" valign="top"><a id="af5974af181fe20259371964a1bfd4613" name="af5974af181fe20259371964a1bfd4613"></a>
me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string *it)</td></tr>
<tr class="separator:af5974af181fe20259371964a1bfd4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d49d5a4bf477109ffa933974645c6c"><td class="memItemLeft" align="right" valign="top"><a id="af4d49d5a4bf477109ffa933974645c6c" name="af4d49d5a4bf477109ffa933974645c6c"></a>
const me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string *it) const BY_CONST_FUNC(operator[](it))</td></tr>
<tr class="separator:af4d49d5a4bf477109ffa933974645c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769351b14082ca9f35aed18b83987628"><td class="memItemLeft" align="right" valign="top"><a id="a769351b14082ca9f35aed18b83987628" name="a769351b14082ca9f35aed18b83987628"></a>
me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const nchar *name)</td></tr>
<tr class="separator:a769351b14082ca9f35aed18b83987628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626c7f1351c0247e51687f7197c9521"><td class="memItemLeft" align="right" valign="top"><a id="a2626c7f1351c0247e51687f7197c9521" name="a2626c7f1351c0247e51687f7197c9521"></a>
const me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const nchar *name) const BY_CONST_FUNC(operator[](name))</td></tr>
<tr class="separator:a2626c7f1351c0247e51687f7197c9521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c67c0e30c00023ed718399c2dd8da"><td class="memItemLeft" align="right" valign="top"><a id="ae58c67c0e30c00023ed718399c2dd8da" name="ae58c67c0e30c00023ed718399c2dd8da"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>in</b> (const <a class="el" href="classby_1_1node.html">node</a> &amp;elem) const</td></tr>
<tr class="separator:ae58c67c0e30c00023ed718399c2dd8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb17af59642e555c372c8f50790ad33c"><td class="memItemLeft" align="right" valign="top"><a id="aeb17af59642e555c372c8f50790ad33c" name="aeb17af59642e555c372c8f50790ad33c"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>in</b> (const <a class="el" href="classby_1_1node.html">node</a> *elem) const</td></tr>
<tr class="separator:aeb17af59642e555c372c8f50790ad33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a409eaff6d92b7c854dc3eaea54b1c"><td class="memItemLeft" align="right" valign="top"><a id="ad5a409eaff6d92b7c854dc3eaea54b1c" name="ad5a409eaff6d92b7c854dc3eaea54b1c"></a>
virtual <a class="el" href="group__core.html#gaec057623c97cf8804f9f793f36f492df">scope</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>subs</b> ()=0</td></tr>
<tr class="separator:ad5a409eaff6d92b7c854dc3eaea54b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1d3547d21b47a47734d0a13959cb60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__core.html#gaec057623c97cf8804f9f793f36f492df">scope</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a5e1d3547d21b47a47734d0a13959cb60">subs</a> () const BY_CONST_FUNC(subs()) virtual <a class="el" href="classby_1_1tstr.html">tstr</a>&lt; <a class="el" href="classby_1_1tnbicontainer.html">nbicontainer</a> &gt; mySubs() const</td></tr>
<tr class="memdesc:a5e1d3547d21b47a47734d0a13959cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tstr to a container of immediate sub-nodes (excluding inherited or chained ones).  <a href="classby_1_1node.html#a5e1d3547d21b47a47734d0a13959cb60">더 자세히 ...</a><br /></td></tr>
<tr class="separator:a5e1d3547d21b47a47734d0a13959cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27e99e2b0d28af967ea721acc3df40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classby_1_1node.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a3c27e99e2b0d28af967ea721acc3df40">promote</a> (const <a class="el" href="classby_1_1node.html">node</a> &amp;it) const</td></tr>
<tr class="separator:a3c27e99e2b0d28af967ea721acc3df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339731399e564e673246e2e67d0ea498"><td class="memItemLeft" align="right" valign="top"><a id="a339731399e564e673246e2e67d0ea498" name="a339731399e564e673246e2e67d0ea498"></a>
const <a class="el" href="classby_1_1node.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>promote</b> (const <a class="el" href="classby_1_1node.html">node</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(promote)</td></tr>
<tr class="separator:a339731399e564e673246e2e67d0ea498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29d1e179339d426e006fe5578b7fc1"><td class="memTemplParams" colspan="2"><a id="a4f29d1e179339d426e006fe5578b7fc1" name="a4f29d1e179339d426e006fe5578b7fc1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29d1e179339d426e006fe5578b7fc1"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (std::function&lt; nbool(const std::string &amp;, const T &amp;)&gt; l)</td></tr>
<tr class="separator:a4f29d1e179339d426e006fe5578b7fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad8f1f720f3eb90b178dd03997d304"><td class="memTemplParams" colspan="2"><a id="aefad8f1f720f3eb90b178dd03997d304" name="aefad8f1f720f3eb90b178dd03997d304"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefad8f1f720f3eb90b178dd03997d304"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (std::function&lt; nbool(const std::string &amp;, const T &amp;)&gt; l) const BY_CONST_FUNC(sub&lt; T &gt;(l)) template&lt; typename T</td></tr>
<tr class="separator:aefad8f1f720f3eb90b178dd03997d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f79e69e55b6e020bcaba845783ac9d3"><td class="memTemplParams" colspan="2"><a id="a4f79e69e55b6e020bcaba845783ac9d3" name="a4f79e69e55b6e020bcaba845783ac9d3"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a4f79e69e55b6e020bcaba845783ac9d3"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> () const BY_CONST_FUNC(sub&lt; T &gt;()) template&lt; typename T</td></tr>
<tr class="separator:a4f79e69e55b6e020bcaba845783ac9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b28952670c7d6e017b0bc1708f588a4"><td class="memTemplParams" colspan="2"><a id="a5b28952670c7d6e017b0bc1708f588a4" name="a5b28952670c7d6e017b0bc1708f588a4"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a5b28952670c7d6e017b0bc1708f588a4"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const std::string *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(sub)</td></tr>
<tr class="separator:a5b28952670c7d6e017b0bc1708f588a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0dff36d9eceecfee05d8b0b3f537ca"><td class="memTemplParams" colspan="2"><a id="a7e0dff36d9eceecfee05d8b0b3f537ca" name="a7e0dff36d9eceecfee05d8b0b3f537ca"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a7e0dff36d9eceecfee05d8b0b3f537ca"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const std::string &amp;name) const BY_CONST_FUNC(sub&lt; T &gt;(name)) template&lt; typename T</td></tr>
<tr class="separator:a7e0dff36d9eceecfee05d8b0b3f537ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853035ee22a274d2612f5e11374ee696"><td class="memTemplParams" colspan="2"><a id="a853035ee22a274d2612f5e11374ee696" name="a853035ee22a274d2612f5e11374ee696"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a853035ee22a274d2612f5e11374ee696"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(name</td></tr>
<tr class="separator:a853035ee22a274d2612f5e11374ee696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7f1bc7abb69bd6ee79c6cb4cb8a886"><td class="memTemplParams" colspan="2"><a id="aba7f1bc7abb69bd6ee79c6cb4cb8a886" name="aba7f1bc7abb69bd6ee79c6cb4cb8a886"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:aba7f1bc7abb69bd6ee79c6cb4cb8a886"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const std::string &amp;name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const BY_CONST_FUNC(sub&lt; T &gt;(name</td></tr>
<tr class="separator:aba7f1bc7abb69bd6ee79c6cb4cb8a886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5d0681783231c775f51b769b52c949"><td class="memTemplParams" colspan="2"><a id="a2d5d0681783231c775f51b769b52c949" name="a2d5d0681783231c775f51b769b52c949"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a2d5d0681783231c775f51b769b52c949"><td class="memTemplItemLeft" align="right" valign="top">const T a const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sub</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const BY_CONST_FUNC(sub&lt; T &gt;(name</td></tr>
<tr class="separator:a2d5d0681783231c775f51b769b52c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4ca30e3ec1fce37829162c37d0d80"><td class="memTemplParams" colspan="2"><a id="a12e4ca30e3ec1fce37829162c37d0d80" name="a12e4ca30e3ec1fce37829162c37d0d80"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12e4ca30e3ec1fce37829162c37d0d80"><td class="memTemplItemLeft" align="right" valign="top">const T a const T a <a class="el" href="classby_1_1tnarr.html">tnarr</a>&lt; T, <a class="el" href="classby_1_1str_tactic.html">strTactic</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> (std::function&lt; nbool(const std::string &amp;, const T &amp;)&gt; l) const</td></tr>
<tr class="separator:a12e4ca30e3ec1fce37829162c37d0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa91a2135d8ef4f0a8f2d5e49081f28d"><td class="memTemplParams" colspan="2"><a id="aaa91a2135d8ef4f0a8f2d5e49081f28d" name="aaa91a2135d8ef4f0a8f2d5e49081f28d"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:aaa91a2135d8ef4f0a8f2d5e49081f28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tnarr.html">tnarr</a>&lt; T, <a class="el" href="classby_1_1str_tactic.html">strTactic</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> () const</td></tr>
<tr class="separator:aaa91a2135d8ef4f0a8f2d5e49081f28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4c016457bc926046eceac9c3625750"><td class="memTemplParams" colspan="2"><a id="a9d4c016457bc926046eceac9c3625750" name="a9d4c016457bc926046eceac9c3625750"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a9d4c016457bc926046eceac9c3625750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> (const std::string &amp;name) const</td></tr>
<tr class="separator:a9d4c016457bc926046eceac9c3625750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331ff4f9b78b53cb893dfaaa6d9645de"><td class="memTemplParams" colspan="2">template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a331ff4f9b78b53cb893dfaaa6d9645de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a331ff4f9b78b53cb893dfaaa6d9645de">subAll</a> (const std::string *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(subAll&lt; T &gt;) template&lt; typename T</td></tr>
<tr class="separator:a331ff4f9b78b53cb893dfaaa6d9645de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ea3cd837d1ec1d9a199b56510b013"><td class="memTemplParams" colspan="2"><a id="a742ea3cd837d1ec1d9a199b56510b013" name="a742ea3cd837d1ec1d9a199b56510b013"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a742ea3cd837d1ec1d9a199b56510b013"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> (const std::string &amp;name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const</td></tr>
<tr class="separator:a742ea3cd837d1ec1d9a199b56510b013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8adca31688bbb61973f38e5ad8e74ba"><td class="memTemplParams" colspan="2"><a id="ac8adca31688bbb61973f38e5ad8e74ba" name="ac8adca31688bbb61973f38e5ad8e74ba"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:ac8adca31688bbb61973f38e5ad8e74ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> *a) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(name</td></tr>
<tr class="separator:ac8adca31688bbb61973f38e5ad8e74ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be8949a044b9f7c527e13b6a4b059d4"><td class="memItemLeft" align="right" valign="top"><a id="a1be8949a044b9f7c527e13b6a4b059d4" name="a1be8949a044b9f7c527e13b6a4b059d4"></a>
<a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt; subAll&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tpriorities</b> ())</td></tr>
<tr class="separator:a1be8949a044b9f7c527e13b6a4b059d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0f91545982f818c99b759793afe424"><td class="memTemplParams" colspan="2"><a id="a8b0f91545982f818c99b759793afe424" name="a8b0f91545982f818c99b759793afe424"></a>
template&lt;typename T  = me&gt; </td></tr>
<tr class="memitem:a8b0f91545982f818c99b759793afe424"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAll</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(name</td></tr>
<tr class="separator:a8b0f91545982f818c99b759793afe424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be8949a044b9f7c527e13b6a4b059d4"><td class="memItemLeft" align="right" valign="top"><a id="a1be8949a044b9f7c527e13b6a4b059d4" name="a1be8949a044b9f7c527e13b6a4b059d4"></a>
<a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt; subAll&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tpriorities</b> ())</td></tr>
<tr class="separator:a1be8949a044b9f7c527e13b6a4b059d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d5cf6256e889592daa9206e2169b99"><td class="memItemLeft" align="right" valign="top"><a id="a01d5cf6256e889592daa9206e2169b99" name="a01d5cf6256e889592daa9206e2169b99"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canEval</b> (const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const</td></tr>
<tr class="separator:a01d5cf6256e889592daa9206e2169b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada65608a5bb8d5d0c01a291f84dbc1d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="tpriorities_8hpp.html#a1a65fd37188763b1ebe002fc60d4608e">priorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#ada65608a5bb8d5d0c01a291f84dbc1d3">prioritize</a> (const <a class="el" href="classby_1_1args.html">args</a> &amp;a) const =0</td></tr>
<tr class="separator:ada65608a5bb8d5d0c01a291f84dbc1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d1f8361a8a14bb5543cf0904d72321"><td class="memItemLeft" align="right" valign="top"><a id="a11d1f8361a8a14bb5543cf0904d72321" name="a11d1f8361a8a14bb5543cf0904d72321"></a>
<a class="el" href="tpriorities_8hpp.html#a1a65fd37188763b1ebe002fc60d4608e">priorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>prioritize</b> (const <a class="el" href="classby_1_1args.html">args</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(it</td></tr>
<tr class="separator:a11d1f8361a8a14bb5543cf0904d72321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef1a38f15287d9fed531ae598b2fa9d"><td class="memItemLeft" align="right" valign="top"><a id="a7ef1a38f15287d9fed531ae598b2fa9d" name="a7ef1a38f15287d9fed531ae598b2fa9d"></a>
virtual <a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const <a class="el" href="classby_1_1args.html">args</a> &amp;a)=0</td></tr>
<tr class="separator:a7ef1a38f15287d9fed531ae598b2fa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2235108efdd0fbd2a698c2b21f3d3b"><td class="memItemLeft" align="right" valign="top"><a id="a1f2235108efdd0fbd2a698c2b21f3d3b" name="a1f2235108efdd0fbd2a698c2b21f3d3b"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const <a class="el" href="classby_1_1args.html">args</a> *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(eval)</td></tr>
<tr class="separator:a1f2235108efdd0fbd2a698c2b21f3d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487a1c0912c269ff34a5db5ebb29d9ae"><td class="memItemLeft" align="right" valign="top"><a id="a487a1c0912c269ff34a5db5ebb29d9ae" name="a487a1c0912c269ff34a5db5ebb29d9ae"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string &amp;name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a)</td></tr>
<tr class="separator:a487a1c0912c269ff34a5db5ebb29d9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad304f4099137c0c31e276e18b2a873"><td class="memItemLeft" align="right" valign="top"><a id="a8ad304f4099137c0c31e276e18b2a873" name="a8ad304f4099137c0c31e276e18b2a873"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string &amp;name, const <a class="el" href="classby_1_1args.html">args</a> *a) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(a</td></tr>
<tr class="separator:a8ad304f4099137c0c31e276e18b2a873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4431567d9117df3600ddb2933d4faea7"><td class="memItemLeft" align="right" valign="top"><a id="a4431567d9117df3600ddb2933d4faea7" name="a4431567d9117df3600ddb2933d4faea7"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (name, a)</td></tr>
<tr class="separator:a4431567d9117df3600ddb2933d4faea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a172dc8015263be3dd4cf67f9aec425"><td class="memItemLeft" align="right" valign="top"><a id="a9a172dc8015263be3dd4cf67f9aec425" name="a9a172dc8015263be3dd4cf67f9aec425"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> ())</td></tr>
<tr class="separator:a9a172dc8015263be3dd4cf67f9aec425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeefe5596061072fc5122c00cd77eadf"><td class="memItemLeft" align="right" valign="top"><a id="adeefe5596061072fc5122c00cd77eadf" name="adeefe5596061072fc5122c00cd77eadf"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> &amp;a) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(name</td></tr>
<tr class="separator:adeefe5596061072fc5122c00cd77eadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e4ea58fc96a616813f939fdf4741f1"><td class="memItemLeft" align="right" valign="top"><a id="ac9e4ea58fc96a616813f939fdf4741f1" name="ac9e4ea58fc96a616813f939fdf4741f1"></a>
<a class="el" href="classby_1_1tstr.html">str</a> eval&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> ())</td></tr>
<tr class="separator:ac9e4ea58fc96a616813f939fdf4741f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88699b8747f916e239fd446ea98eaa76"><td class="memItemLeft" align="right" valign="top"><a id="a88699b8747f916e239fd446ea98eaa76" name="a88699b8747f916e239fd446ea98eaa76"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string *name, const <a class="el" href="classby_1_1args.html">args</a> *a) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(name &amp;&amp;a</td></tr>
<tr class="separator:a88699b8747f916e239fd446ea98eaa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e4ea58fc96a616813f939fdf4741f1"><td class="memItemLeft" align="right" valign="top"><a id="ac9e4ea58fc96a616813f939fdf4741f1" name="ac9e4ea58fc96a616813f939fdf4741f1"></a>
<a class="el" href="classby_1_1tstr.html">str</a> eval&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> ())</td></tr>
<tr class="separator:ac9e4ea58fc96a616813f939fdf4741f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8515220370617e199792602eb55386"><td class="memItemLeft" align="right" valign="top"><a id="a3c8515220370617e199792602eb55386" name="a3c8515220370617e199792602eb55386"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a3c8515220370617e199792602eb55386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ae1a26847452b658c44fc41ab80405"><td class="memItemLeft" align="right" valign="top"><a id="af1ae1a26847452b658c44fc41ab80405" name="af1ae1a26847452b658c44fc41ab80405"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> (const std::string *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(eval)</td></tr>
<tr class="separator:af1ae1a26847452b658c44fc41ab80405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769397bf34aa96e38cb1d95ee518aabf"><td class="memItemLeft" align="right" valign="top"><a id="a769397bf34aa96e38cb1d95ee518aabf" name="a769397bf34aa96e38cb1d95ee518aabf"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval</b> ()</td></tr>
<tr class="separator:a769397bf34aa96e38cb1d95ee518aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a636219cb26fbd6c32e38f4b3a5c81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#ac5a636219cb26fbd6c32e38f4b3a5c81">rel</a> ()</td></tr>
<tr class="separator:ac5a636219cb26fbd6c32e38f4b3a5c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e4f5cd95d7b40e24ad04fe008cede8"><td class="memTemplParams" colspan="2"><a id="a33e4f5cd95d7b40e24ad04fe008cede8" name="a33e4f5cd95d7b40e24ad04fe008cede8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33e4f5cd95d7b40e24ad04fe008cede8"><td class="memTemplItemLeft" align="right" valign="top">nbool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> () const</td></tr>
<tr class="separator:a33e4f5cd95d7b40e24ad04fe008cede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfaa4cc46dfb92c91136a14955a8170"><td class="memItemLeft" align="right" valign="top"><a id="abbfaa4cc46dfb92c91136a14955a8170" name="abbfaa4cc46dfb92c91136a14955a8170"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;to) const</td></tr>
<tr class="separator:abbfaa4cc46dfb92c91136a14955a8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117432ddb55d816104624b904cd142f9"><td class="memItemLeft" align="right" valign="top"><a id="a117432ddb55d816104624b904cd142f9" name="a117432ddb55d816104624b904cd142f9"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(is)</td></tr>
<tr class="separator:a117432ddb55d816104624b904cd142f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf1a5e51d1bcf10219ba92350036ab0"><td class="memItemLeft" align="right" valign="top"><a id="a8bf1a5e51d1bcf10219ba92350036ab0" name="a8bf1a5e51d1bcf10219ba92350036ab0"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;to) const</td></tr>
<tr class="separator:a8bf1a5e51d1bcf10219ba92350036ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525253ea6a19dfd2049078af559b360a"><td class="memItemLeft" align="right" valign="top"><a id="a525253ea6a19dfd2049078af559b360a" name="a525253ea6a19dfd2049078af559b360a"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(is)</td></tr>
<tr class="separator:a525253ea6a19dfd2049078af559b360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac522309e55b52da1c2c7e3f4690e59e1"><td class="memTemplParams" colspan="2"><a id="ac522309e55b52da1c2c7e3f4690e59e1" name="ac522309e55b52da1c2c7e3f4690e59e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac522309e55b52da1c2c7e3f4690e59e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tstr.html">tstr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as</b> () const</td></tr>
<tr class="separator:ac522309e55b52da1c2c7e3f4690e59e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a351db78be538ba3019f928bba0a90"><td class="memItemLeft" align="right" valign="top"><a id="a01a351db78be538ba3019f928bba0a90" name="a01a351db78be538ba3019f928bba0a90"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>as</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;to) const</td></tr>
<tr class="separator:a01a351db78be538ba3019f928bba0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90db3a25da20271971b86730b1cd541"><td class="memItemLeft" align="right" valign="top"><a id="aa90db3a25da20271971b86730b1cd541" name="aa90db3a25da20271971b86730b1cd541"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>as</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(as)</td></tr>
<tr class="separator:aa90db3a25da20271971b86730b1cd541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb7a006bc891ce6bbca209f2bd4e62"><td class="memItemLeft" align="right" valign="top"><a id="a89fb7a006bc891ce6bbca209f2bd4e62" name="a89fb7a006bc891ce6bbca209f2bd4e62"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>as</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;to) const</td></tr>
<tr class="separator:a89fb7a006bc891ce6bbca209f2bd4e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f11d8b9f7a0c9482d42d2054024e7e"><td class="memItemLeft" align="right" valign="top"><a id="ad0f11d8b9f7a0c9482d42d2054024e7e" name="ad0f11d8b9f7a0c9482d42d2054024e7e"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>as</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(as)</td></tr>
<tr class="separator:ad0f11d8b9f7a0c9482d42d2054024e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2298ad32fd390b5c674399f1f0dfceac"><td class="memTemplParams" colspan="2"><a id="a2298ad32fd390b5c674399f1f0dfceac" name="a2298ad32fd390b5c674399f1f0dfceac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2298ad32fd390b5c674399f1f0dfceac"><td class="memTemplItemLeft" align="right" valign="top">nbool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isImpli</b> () const</td></tr>
<tr class="separator:a2298ad32fd390b5c674399f1f0dfceac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c14d0eec1b8df3e294c94e942b6876"><td class="memItemLeft" align="right" valign="top"><a id="a14c14d0eec1b8df3e294c94e942b6876" name="a14c14d0eec1b8df3e294c94e942b6876"></a>
virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isImpli</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;to) const</td></tr>
<tr class="separator:a14c14d0eec1b8df3e294c94e942b6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c7094dbcae0ef3985154359af4881"><td class="memItemLeft" align="right" valign="top"><a id="aed2c7094dbcae0ef3985154359af4881" name="aed2c7094dbcae0ef3985154359af4881"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isImpli</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;to) const</td></tr>
<tr class="separator:aed2c7094dbcae0ef3985154359af4881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeaafcc1f3186ffab78451db473a32b"><td class="memItemLeft" align="right" valign="top"><a id="abfeaafcc1f3186ffab78451db473a32b" name="abfeaafcc1f3186ffab78451db473a32b"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isImpli</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isImpli)</td></tr>
<tr class="separator:abfeaafcc1f3186ffab78451db473a32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00896299ad1a6eba825a4c3a2b6a6584"><td class="memTemplParams" colspan="2"><a id="a00896299ad1a6eba825a4c3a2b6a6584" name="a00896299ad1a6eba825a4c3a2b6a6584"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00896299ad1a6eba825a4c3a2b6a6584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classby_1_1tstr.html">tstr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>asImpli</b> () const</td></tr>
<tr class="separator:a00896299ad1a6eba825a4c3a2b6a6584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fa9157bae2227dfc39085c9178aafb"><td class="memItemLeft" align="right" valign="top"><a id="af2fa9157bae2227dfc39085c9178aafb" name="af2fa9157bae2227dfc39085c9178aafb"></a>
virtual <a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asImpli</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;to) const</td></tr>
<tr class="separator:af2fa9157bae2227dfc39085c9178aafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bae7ff98f00920dcd77cc6737d503dd"><td class="memItemLeft" align="right" valign="top"><a id="a1bae7ff98f00920dcd77cc6737d503dd" name="a1bae7ff98f00920dcd77cc6737d503dd"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asImpli</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;to) const</td></tr>
<tr class="separator:a1bae7ff98f00920dcd77cc6737d503dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c3576755fd851661c4252923d1e15"><td class="memItemLeft" align="right" valign="top"><a id="a328c3576755fd851661c4252923d1e15" name="a328c3576755fd851661c4252923d1e15"></a>
<a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asImpli</b> (const <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(asImpli)</td></tr>
<tr class="separator:a328c3576755fd851661c4252923d1e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a66f8b2f5fa2be984145b43ff514f"><td class="memItemLeft" align="right" valign="top"><a id="ac70a66f8b2f5fa2be984145b43ff514f" name="ac70a66f8b2f5fa2be984145b43ff514f"></a>
virtual const <a class="el" href="classby_1_1src.html">src</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSrc</b> () const</td></tr>
<tr class="separator:ac70a66f8b2f5fa2be984145b43ff514f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422800bf7875c45e31b13feab65547d0"><td class="memItemLeft" align="right" valign="top">virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a422800bf7875c45e31b13feab65547d0">isComplete</a> () const</td></tr>
<tr class="separator:a422800bf7875c45e31b13feab65547d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a80ea572c628b9206aad1a7a6d7d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a168a80ea572c628b9206aad1a7a6d7d9">infer</a> () const</td></tr>
<tr class="separator:a168a80ea572c628b9206aad1a7a6d7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9e537cdff3f17d6d5c64d4525919c3"><td class="memItemLeft" align="right" valign="top"><a id="aec9e537cdff3f17d6d5c64d4525919c3" name="aec9e537cdff3f17d6d5c64d4525919c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>accept</b> (const <a class="el" href="classby_1_1visit_info.html">visitInfo</a> &amp;i, <a class="el" href="classby_1_1visitor.html">visitor</a> &amp;v)</td></tr>
<tr class="separator:aec9e537cdff3f17d6d5c64d4525919c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ecc490beef9748730cc37f93a1161b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a91ecc490beef9748730cc37f93a1161b">inFrame</a> (const <a class="el" href="classby_1_1tbicontainable.html">bicontainable</a> *<a class="el" href="classby_1_1args.html">args</a>) const override</td></tr>
<tr class="separator:a91ecc490beef9748730cc37f93a1161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c32818426ab990c0beeaf171eb9558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a02c32818426ab990c0beeaf171eb9558">outFrame</a> () const override</td></tr>
<tr class="separator:a02c32818426ab990c0beeaf171eb9558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddded461468d78660b63032e83c5d1e"><td class="memItemLeft" align="right" valign="top"><a id="a3ddded461468d78660b63032e83c5d1e" name="a3ddded461468d78660b63032e83c5d1e"></a>
virtual const <a class="el" href="classby_1_1modifier.html">modifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getModifier</b> () const</td></tr>
<tr class="separator:a3ddded461468d78660b63032e83c5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e42c1571a2ddd2b47869f8e80d9f3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a27e42c1571a2ddd2b47869f8e80d9f3f">inFrame</a> (const <a class="el" href="classby_1_1tbicontainable.html">bicontainable</a> *<a class="el" href="classby_1_1args.html">args</a>) const=0</td></tr>
<tr class="separator:a27e42c1571a2ddd2b47869f8e80d9f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fa9875c39255b969d83580a41a9cf6"><td class="memItemLeft" align="right" valign="top"><a id="af4fa9875c39255b969d83580a41a9cf6" name="af4fa9875c39255b969d83580a41a9cf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>inFrame</b> () const</td></tr>
<tr class="separator:af4fa9875c39255b969d83580a41a9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fe51f0720c46b9ee00ea15b137a510"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#af6fe51f0720c46b9ee00ea15b137a510">outFrame</a> () const=0</td></tr>
<tr class="separator:af6fe51f0720c46b9ee00ea15b137a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1instance"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classby_1_1instance')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1instance.html">by::instance</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:a16469e451673fecd6f99c75c1d584c78 inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="a16469e451673fecd6f99c75c1d584c78" name="a16469e451673fecd6f99c75c1d584c78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (<a class="el" href="structby_1_1id.html">id</a> newId)</td></tr>
<tr class="separator:a16469e451673fecd6f99c75c1d584c78 inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa6c106af9dd09a40928322e9df0bd inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="aa6fa6c106af9dd09a40928322e9df0bd" name="aa6fa6c106af9dd09a40928322e9df0bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> (const me &amp;rhs)</td></tr>
<tr class="separator:aa6fa6c106af9dd09a40928322e9df0bd inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5a18858e6fd37ac26d8db0d5aaf3c inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="a1dc5a18858e6fd37ac26d8db0d5aaf3c" name="a1dc5a18858e6fd37ac26d8db0d5aaf3c"></a>
me &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const me &amp;rhs)=default</td></tr>
<tr class="separator:a1dc5a18858e6fd37ac26d8db0d5aaf3c inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e6107c16eb014ece555d045bf2e31 inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="a689e6107c16eb014ece555d045bf2e31" name="a689e6107c16eb014ece555d045bf2e31"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t sz) noexcept</td></tr>
<tr class="separator:a689e6107c16eb014ece555d045bf2e31 inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eedc79a1e3dde4bccdad9e5a70b38c inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="a01eedc79a1e3dde4bccdad9e5a70b38c" name="a01eedc79a1e3dde4bccdad9e5a70b38c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *pt, size_t sz) noexcept</td></tr>
<tr class="separator:a01eedc79a1e3dde4bccdad9e5a70b38c inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b67fbe69d68c4a073610a557e2c27e inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="ab3b67fbe69d68c4a073610a557e2c27e" name="ab3b67fbe69d68c4a073610a557e2c27e"></a>
virtual <a class="el" href="structby_1_1id.html">id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getId</b> () const</td></tr>
<tr class="separator:ab3b67fbe69d68c4a073610a557e2c27e inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f449486eea01ea434f348c3b142760 inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top">virtual nbool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1instance.html#a56f449486eea01ea434f348c3b142760">isHeap</a> () const</td></tr>
<tr class="memdesc:a56f449486eea01ea434f348c3b142760 inherit pub_methods_classby_1_1instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this instance is allocated on the heap.  <a href="classby_1_1instance.html#a56f449486eea01ea434f348c3b142760">더 자세히 ...</a><br /></td></tr>
<tr class="separator:a56f449486eea01ea434f348c3b142760 inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b3f5841bf020b5f5e421db1efa7ce inherit pub_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classby_1_1life.html">life</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1instance.html#a838b3f5841bf020b5f5e421db1efa7ce">getBindTag</a> () const</td></tr>
<tr class="memdesc:a838b3f5841bf020b5f5e421db1efa7ce inherit pub_methods_classby_1_1instance"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the associated life object for reference counting.  <a href="classby_1_1instance.html#a838b3f5841bf020b5f5e421db1efa7ce">더 자세히 ...</a><br /></td></tr>
<tr class="separator:a838b3f5841bf020b5f5e421db1efa7ce inherit pub_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1type_providable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classby_1_1type_providable')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1type_providable.html">by::typeProvidable</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:ae79a4ecc80915511509195a4d6949643 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="ae79a4ecc80915511509195a4d6949643" name="ae79a4ecc80915511509195a4d6949643"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const me &amp;rhs) const</td></tr>
<tr class="separator:ae79a4ecc80915511509195a4d6949643 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588f51a220cf4eca9e7df44ff04977e7 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a588f51a220cf4eca9e7df44ff04977e7" name="a588f51a220cf4eca9e7df44ff04977e7"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const me &amp;rhs) const</td></tr>
<tr class="separator:a588f51a220cf4eca9e7df44ff04977e7 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e69312548672dbcad53a369ded5630 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="aa4e69312548672dbcad53a369ded5630" name="aa4e69312548672dbcad53a369ded5630"></a>
virtual const <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getType</b> () const =0</td></tr>
<tr class="separator:aa4e69312548672dbcad53a369ded5630 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07327fb7b52a45b6fbaa48ae0eb89f inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a2f07327fb7b52a45b6fbaa48ae0eb89f" name="a2f07327fb7b52a45b6fbaa48ae0eb89f"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;it) const</td></tr>
<tr class="separator:a2f07327fb7b52a45b6fbaa48ae0eb89f inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390706279ba9b1d3edc72b8e24096931 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a390706279ba9b1d3edc72b8e24096931" name="a390706279ba9b1d3edc72b8e24096931"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:a390706279ba9b1d3edc72b8e24096931 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b7129535e10f7455631f9dd83ef44 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a159b7129535e10f7455631f9dd83ef44" name="a159b7129535e10f7455631f9dd83ef44"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (const me &amp;it) const</td></tr>
<tr class="separator:a159b7129535e10f7455631f9dd83ef44 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2461c92af9ee4f424a197beb341135a2 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a2461c92af9ee4f424a197beb341135a2" name="a2461c92af9ee4f424a197beb341135a2"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (const me *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:a2461c92af9ee4f424a197beb341135a2 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a58d5c9754baf2cac10f00d3c464fb4 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a9a58d5c9754baf2cac10f00d3c464fb4" name="a9a58d5c9754baf2cac10f00d3c464fb4"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;it) const</td></tr>
<tr class="separator:a9a58d5c9754baf2cac10f00d3c464fb4 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88afd96107b542735244fcc761385f08 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a88afd96107b542735244fcc761385f08" name="a88afd96107b542735244fcc761385f08"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (const <a class="el" href="classby_1_1type.html">type</a> *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:a88afd96107b542735244fcc761385f08 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a93289f111e4000ee98a943149409c4 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a6a93289f111e4000ee98a943149409c4" name="a6a93289f111e4000ee98a943149409c4"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (const me &amp;it) const</td></tr>
<tr class="separator:a6a93289f111e4000ee98a943149409c4 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24df0319e39a1ebd35cfdd3b9ea09f72 inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a24df0319e39a1ebd35cfdd3b9ea09f72" name="a24df0319e39a1ebd35cfdd3b9ea09f72"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (const me *it) const <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:a24df0319e39a1ebd35cfdd3b9ea09f72 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable"><td class="memTemplParams" colspan="2"><a id="aacf82d8ddf74c862902802dfad217ddc" name="aacf82d8ddf74c862902802dfad217ddc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top">nint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSub</b> () const</td></tr>
<tr class="separator:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable"><td class="memTemplParams" colspan="2"><a id="aa64bd64ab1354fb0dc0689389bc485c6" name="aa64bd64ab1354fb0dc0689389bc485c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top">nint&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSuper</b> () const</td></tr>
<tr class="separator:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable"><td class="memTemplParams" colspan="2"><a id="af6f60075f199d6eb48d39ed8e33b4329" name="af6f60075f199d6eb48d39ed8e33b4329"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> ()</td></tr>
<tr class="separator:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classby_1_1type_providable.html#ad05c9ba2164853c3e8db3af3cb5198c3">cast</a> () const BY_CONST_FUNC(cast&lt; T &gt;()) virtual void *cast(const <a class="el" href="classby_1_1type.html">type</a> &amp;to)</td></tr>
<tr class="memdesc:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast to target type using type hierarchy information  <a href="classby_1_1type_providable.html#ad05c9ba2164853c3e8db3af3cb5198c3">더 자세히 ...</a><br /></td></tr>
<tr class="separator:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d50919c02f16448bc84396c625dd5b inherit pub_methods_classby_1_1type_providable"><td class="memItemLeft" align="right" valign="top"><a id="a09d50919c02f16448bc84396c625dd5b" name="a09d50919c02f16448bc84396c625dd5b"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (const <a class="el" href="classby_1_1type.html">type</a> &amp;to) const BY_CONST_FUNC(cast(to)) void *cast(const <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(cast)</td></tr>
<tr class="separator:a09d50919c02f16448bc84396c625dd5b inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1clonable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classby_1_1clonable')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1clonable.html">by::clonable</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:a7e040b29a78bf3d1ed3a5372f8edfceb inherit pub_methods_classby_1_1clonable"><td class="memItemLeft" align="right" valign="top"><a id="a7e040b29a78bf3d1ed3a5372f8edfceb" name="a7e040b29a78bf3d1ed3a5372f8edfceb"></a>
virtual me *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const =0</td></tr>
<tr class="separator:a7e040b29a78bf3d1ed3a5372f8edfceb inherit pub_methods_classby_1_1clonable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d1567bbb34636e0d171ca99306b0e inherit pub_methods_classby_1_1clonable"><td class="memItemLeft" align="right" valign="top"><a id="af94d1567bbb34636e0d171ca99306b0e" name="af94d1567bbb34636e0d171ca99306b0e"></a>
virtual me *&#160;</td><td class="memItemRight" valign="bottom"><b>cloneDeep</b> () const</td></tr>
<tr class="separator:af94d1567bbb34636e0d171ca99306b0e inherit pub_methods_classby_1_1clonable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78216acb96f85e6e23db1b119a17bfa inherit pub_methods_classby_1_1clonable"><td class="memItemLeft" align="right" valign="top"><a id="ad78216acb96f85e6e23db1b119a17bfa" name="ad78216acb96f85e6e23db1b119a17bfa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onCloneDeep</b> (const me &amp;from)</td></tr>
<tr class="separator:ad78216acb96f85e6e23db1b119a17bfa inherit pub_methods_classby_1_1clonable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1frame_interactable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classby_1_1frame_interactable')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1frame_interactable.html">by::frameInteractable</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:af4fa9875c39255b969d83580a41a9cf6 inherit pub_methods_classby_1_1frame_interactable"><td class="memItemLeft" align="right" valign="top"><a id="af4fa9875c39255b969d83580a41a9cf6" name="af4fa9875c39255b969d83580a41a9cf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>inFrame</b> () const</td></tr>
<tr class="separator:af4fa9875c39255b969d83580a41a9cf6 inherit pub_methods_classby_1_1frame_interactable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public 속성</h2></td></tr>
<tr class="memitem:a61a558262f0785eeb3af4024c3e81d2e"><td class="memItemLeft" align="right" valign="top"><a id="a61a558262f0785eeb3af4024c3e81d2e" name="a61a558262f0785eeb3af4024c3e81d2e"></a>
T sub&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a61a558262f0785eeb3af4024c3e81d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dd2e0fe1afc525f7a9cc36ed3c5b23"><td class="memItemLeft" align="right" valign="top"><a id="ad2dd2e0fe1afc525f7a9cc36ed3c5b23" name="ad2dd2e0fe1afc525f7a9cc36ed3c5b23"></a>
T sub&#160;</td><td class="memItemRight" valign="bottom"><b>nullptr</b></td></tr>
<tr class="separator:ad2dd2e0fe1afc525f7a9cc36ed3c5b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7679cfaf90b149e223e66b87c2180c"><td class="memItemLeft" align="right" valign="top"><a id="a8f7679cfaf90b149e223e66b87c2180c" name="a8f7679cfaf90b149e223e66b87c2180c"></a>
<a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt; subAll&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a8f7679cfaf90b149e223e66b87c2180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c881559cb2a0fcc04e4c22cab7c28a"><td class="memItemLeft" align="right" valign="top"><a id="aa3c881559cb2a0fcc04e4c22cab7c28a" name="aa3c881559cb2a0fcc04e4c22cab7c28a"></a>
<a class="el" href="tpriorities_8hpp.html#a1a65fd37188763b1ebe002fc60d4608e">priorType</a> prioritize&#160;</td><td class="memItemRight" valign="bottom"><b>it</b></td></tr>
<tr class="separator:aa3c881559cb2a0fcc04e4c22cab7c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc646b8791c3220ebddba28cb6579837"><td class="memItemLeft" align="right" valign="top"><a id="acc646b8791c3220ebddba28cb6579837" name="acc646b8791c3220ebddba28cb6579837"></a>
<a class="el" href="tpriorities_8hpp.html#a1a65fd37188763b1ebe002fc60d4608e">priorType</a> prioritize&#160;</td><td class="memItemRight" valign="bottom"><b>NO_MATCH</b></td></tr>
<tr class="separator:acc646b8791c3220ebddba28cb6579837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a558262f0785eeb3af4024c3e81d2e"><td class="memItemLeft" align="right" valign="top"><a id="a61a558262f0785eeb3af4024c3e81d2e" name="a61a558262f0785eeb3af4024c3e81d2e"></a>
<a class="el" href="classby_1_1tstr.html">str</a> eval&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a61a558262f0785eeb3af4024c3e81d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected 멤버 함수</h2></td></tr>
<tr class="memitem:a3bf7de9c828022e0eb5dde3d462d645c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classby_1_1tstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1node.html#a3bf7de9c828022e0eb5dde3d462d645c">_onEvalSub</a> (<a class="el" href="classby_1_1node.html">node</a> &amp;sub, const <a class="el" href="classby_1_1args.html">args</a> &amp;a)</td></tr>
<tr class="memdesc:a3bf7de9c828022e0eb5dde3d462d645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected virtual method for evaluating a sub-node.  <a href="classby_1_1node.html#a3bf7de9c828022e0eb5dde3d462d645c">더 자세히 ...</a><br /></td></tr>
<tr class="separator:a3bf7de9c828022e0eb5dde3d462d645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7928ad6a36a48a9ced02e968e05fa8e"><td class="memItemLeft" align="right" valign="top"><a id="aa7928ad6a36a48a9ced02e968e05fa8e" name="aa7928ad6a36a48a9ced02e968e05fa8e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>_setSrc</b> (const <a class="el" href="classby_1_1src.html">src</a> &amp;s)</td></tr>
<tr class="separator:aa7928ad6a36a48a9ced02e968e05fa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ab39175496171689720e1f308d7f71"><td class="memItemLeft" align="right" valign="top"><a id="a28ab39175496171689720e1f308d7f71" name="a28ab39175496171689720e1f308d7f71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_setSrc</b> (const <a class="el" href="classby_1_1src.html">src</a> *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(_setSrc)</td></tr>
<tr class="separator:a28ab39175496171689720e1f308d7f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classby_1_1instance"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classby_1_1instance')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1instance.html">by::instance</a>(으)로부터 상속된 Protected 멤버 함수</td></tr>
<tr class="memitem:a067b78083e79bea14beb1d015283019f inherit pro_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="a067b78083e79bea14beb1d015283019f" name="a067b78083e79bea14beb1d015283019f"></a>
nbool&#160;</td><td class="memItemRight" valign="bottom"><b>_setId</b> (<a class="el" href="structby_1_1id.html">id</a> new1)</td></tr>
<tr class="separator:a067b78083e79bea14beb1d015283019f inherit pro_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a41bef8186e6a81a9dc0ec6b6e3b680c9"><td class="memItemLeft" align="right" valign="top"><a id="a41bef8186e6a81a9dc0ec6b6e3b680c9" name="a41bef8186e6a81a9dc0ec6b6e3b680c9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>coreInternal</b></td></tr>
<tr class="separator:a41bef8186e6a81a9dc0ec6b6e3b680c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
추가로 상속된 멤버들</h2></td></tr>
<tr class="inherit_header pub_static_methods_classby_1_1instance"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classby_1_1instance')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1instance.html">by::instance</a>(으)로부터 상속된 정적 Public 멤버 함수</td></tr>
<tr class="memitem:adc7c4424f664c4e5ac0f55d981bf93da inherit pub_static_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="adc7c4424f664c4e5ac0f55d981bf93da" name="adc7c4424f664c4e5ac0f55d981bf93da"></a>
static <a class="el" href="classby_1_1instance_1_1vault.html">vault</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getVault</b> ()</td></tr>
<tr class="separator:adc7c4424f664c4e5ac0f55d981bf93da inherit pub_static_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classby_1_1instance"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classby_1_1instance')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1instance.html">by::instance</a>(으)로부터 상속된 정적 Protected 멤버 함수</td></tr>
<tr class="memitem:ac233c40e2381a0f3d0aefe0082cceeb8 inherit pro_static_methods_classby_1_1instance"><td class="memItemLeft" align="right" valign="top"><a id="ac233c40e2381a0f3d0aefe0082cceeb8" name="ac233c40e2381a0f3d0aefe0082cceeb8"></a>
static <a class="el" href="classby_1_1instancer.html">instancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_getMgr</b> ()</td></tr>
<tr class="separator:ac233c40e2381a0f3d0aefe0082cceeb8 inherit pro_static_methods_classby_1_1instance"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">상세한 설명</h2>
<div class="textblock"><p >Base class for all AST nodes in the byeol language </p>
<p >The most fundamental class in the core module. Unlike traditional AST (Abstract Syntax Tree) implementations, byeol executes programs while maintaining the AST structure, making it more akin to a Program Execution Tree (PET). Provides comprehensive APIs for AST structure manipulation, node evaluation, child node traversal, and type conversion.</p>
<h1><a class="anchor" id="program_execution_tree"></a>
Program Execution Tree</h1>
<p >Unlike typical programming languages, byeol executes programs while maintaining the AST structure intact. In most languages, the AST is merely an intermediate representation of grammatical structure, but in byeol, the AST serves as the final executable output. Because execution is considered from the start, the class provides not only tree-based program structure representation but also APIs for type conversion and node evaluation.</p>
<h1><a class="anchor" id="fundamental_class"></a>
Fundamental Base Class</h1>
<p >Each node must be executable, so a node can be a function, an object, or an operator like <code>+</code>. The evaluation function is provided as <code>eval(const args&amp;)</code> to execute and evaluate values.</p>
<h1><a class="anchor" id="side_funcs"></a>
Side Functions</h1>
<p >As the core base class of the byeol project, node provides numerous side functions for various operations.</p>
<h1><a class="anchor" id="ast_traversal"></a>
AST Traversal</h1>
<p >Due to AST characteristics, a node can contain objects of other node-derived classes. Like a DOM tree, it uses the composition pattern, and various functions are provided to traverse this tree. In byeol, this tree is called scope and is map-based. Classes like <a class="el" href="classby_1_1block_expr.html">blockExpr</a> contain statement blocks as arrays while also being nodes. Therefore, the overall AST structure is a mix of maps and arrays. The scope uses each node's name as a key, where the <a class="el" href="classby_1_1parser.html">parser</a> defines appropriate names as keys when adding instances.</p>
<p >Common traversal functions: <code>operator[], sub(), subs(), in(), subAll()</code></p>
<div class="fragment"><div class="line"><span class="keyword">const</span> node&amp; root = getRoot();</div>
<div class="line">root.sub(<span class="stringliteral">&quot;name1&quot;</span>);             <span class="comment">// Find node named name1 in root (unknown if function or object)</span></div>
<div class="line">root.sub&lt;func&gt;(<span class="stringliteral">&quot;name1&quot;</span>);       <span class="comment">// Get symbol named name1 only if it&#39;s a function</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Find all nodes named name2 that take one int argument</span></div>
<div class="line">tnarr found = root.subAll(<span class="stringliteral">&quot;name2&quot;</span>, args(narr(*<span class="keyword">new</span> nInt())));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="group__core.html#gaec057623c97cf8804f9f793f36f492df">scope</a>&amp; subs = root.subs(); <span class="comment">// Can utilize all tbicontainable APIs</span></div>
<div class="line">                                 <span class="comment">// Supports for loops, iterators, lambda filtering, etc.</span></div>
<div class="line">subs.len();                      <span class="comment">// Returns number of child nodes root has</span></div>
<div class="ttc" id="agroup__core_html_gaec057623c97cf8804f9f793f36f492df"><div class="ttname"><a href="group__core.html#gaec057623c97cf8804f9f793f36f492df">by::scope</a></div><div class="ttdeci">tnchain&lt; std::string, node, tnmap&lt; std::string, node, immutableTactic &gt; &gt; scope</div><div class="ttdoc">Symbol scope container</div><div class="ttdef"><b>Definition:</b> node.hpp:20</div></div>
</div><!-- fragment --><h1><a class="anchor" id="duplicate_symbols"></a>
Handling Duplicate Symbols</h1>
<p >Byeol doesn't allow duplicate symbols within the same scope, but this doesn't mean two pairs with the same key cannot exist. Functions with the same name but different parameter counts or types are different symbols. Simple string comparison cannot determine duplication, so the scope class is based on multimap rather than map.</p>
<h1><a class="anchor" id="eval_section"></a>
Evaluation</h1>
<p >A node can be a function, object, or expression. <code>eval(const args&amp;)</code> returns the execution result of such nodes. (Byeol has no class concept; objects replace this role. Objects can be executed like functions, equivalent to calling a constructor.) The <a class="el" href="classby_1_1args.html">args</a> object containing required arguments is passed to eval(). If the node's expected parameters differ in count or type from args, an empty str may be returned. Some node functions take a name parameter along with <code>eval()</code>, which finds child nodes matching the node's name and passes args to evaluate them—essentially dispatching a message.</p>
<h1><a class="anchor" id="infer_section"></a>
Type Inference</h1>
<p ><code><a class="el" href="classby_1_1node.html#a168a80ea572c628b9206aad1a7a6d7d9">infer()</a></code> performs type inference. It doesn't return the exact runtime value but the type determined at verification stage. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// In byeol language, `2 + 3.5` is represented as:</span></div>
<div class="line">FBOExpr e = FBOExpr(FBOExpr::SYMBOL_ADD, *<span class="keyword">new</span> nInt(2), *nFlt(3.5));</div>
<div class="line"> </div>
<div class="line">str infered = e.infer();       <span class="comment">// What type results from adding int 2 and flt 3.5?</span></div>
<div class="line">infered-&gt;cast&lt;nFlt&gt;() != <span class="keyword">nullptr</span>; <span class="comment">// true: answer is flt</span></div>
</div><!-- fragment --><p >This creates an expression like 2 + 3.5 by putting <a class="el" href="classby_1_1n_int.html">nInt</a> and <a class="el" href="classby_1_1n_flt.html">nFlt</a> objects into <a class="el" href="classby_1_1_f_b_o_expr.html">FBOExpr</a>. Calling <code><a class="el" href="classby_1_1node.html#a168a80ea572c628b9206aad1a7a6d7d9">infer()</a></code> yields <a class="el" href="classby_1_1n_flt.html" title="Float primitive type in byeol language">nFlt</a> due to type promotion (int + flt = flt). Type inference for an expression requires recursively calling type inference on child nodes, unlike <code>getType()</code> which returns immediately. The AST must be traversed to calculate type information. Note that type inference focuses on quickly determining types and doesn't compute values. In the example above, the <a class="el" href="classby_1_1n_flt.html" title="Float primitive type in byeol language">nFlt</a> value in <code>infered</code> contains the default value—use <code>eval()</code> for accurate values.</p>
<h1><a class="anchor" id="type_conversion"></a>
Type Conversion</h1>
<p >Node provides <code>as()</code> for explicit type conversion and <code>is()</code> to check conversion possibility:</p>
<div class="fragment"><div class="line"><span class="comment">// The following byeol code translated to C++:</span></div>
<div class="line"><span class="comment">//  foo(val int) void</span></div>
<div class="line"><span class="comment">//      if val is flt</span></div>
<div class="line"><span class="comment">//          doSomething(val as flt)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> nInt&amp; val) {</div>
<div class="line">    <span class="keywordflow">if</span>(val.is&lt;nFlt&gt;()) {</div>
<div class="line">        str isFlt = val.as&lt;nFlt&gt;();</div>
<div class="line">        nflt converted = isFlt-&gt;get();</div>
<div class="line">        doSomething(converted);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p ><code>as()</code> and <code>is()</code> provide various side functions, enabling generic functions:</p>
<div class="fragment"><div class="line">str convertIfPossible(<span class="keyword">const</span> node&amp; it, <span class="keyword">const</span> node&amp; toThisType) {</div>
<div class="line">    <span class="comment">// getType() retrieves type information (C++ class type or user-defined byeol type)</span></div>
<div class="line">    <span class="comment">// See type and ntype classes for details</span></div>
<div class="line">    <span class="keywordflow">if</span>(!it.is(toThisType.getType())) <span class="keywordflow">return</span> str();</div>
<div class="line">    <span class="keywordflow">return</span> it.as(toThisType.getType());</div>
<div class="line">}</div>
</div><!-- fragment --><p >This example is verbose for clarity. Real code uses WHEN for brevity. Rewriting foo():</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> nInt&amp; val) {</div>
<div class="line">    tstr&lt;nFlt&gt; converted = val OR.ret(); <span class="comment">// early-return pattern + WHEN + OR macro</span></div>
<div class="line">    doSomething(converted-&gt;get());</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="managed_vs_native"></a>
Managed vs Native Type Conversion</h1>
<p >The <code>as()</code> and <code>is()</code> functions handle type conversion in the byeol language environment. For example, <a class="el" href="classby_1_1n_int.html">nInt</a> is the C++ class representing byeol's <code>int</code>. It inherits from <a class="el" href="classby_1_1node.html">node</a> because int can be an AST instance in byeol. Calling is&lt;nFlt&gt;() on <a class="el" href="classby_1_1n_int.html" title="Integer primitive type in byeol language">nInt</a> is allowed, but this doesn't mean <a class="el" href="classby_1_1n_int.html" title="Integer primitive type in byeol language">nInt</a> converts to <a class="el" href="classby_1_1n_flt.html" title="Float primitive type in byeol language">nFlt</a> in C++ code. In C++, implicit conversion is generally only allowed when <a class="el" href="classby_1_1n_int.html" title="Integer primitive type in byeol language">nInt</a> is a parent class of <a class="el" href="classby_1_1n_flt.html" title="Float primitive type in byeol language">nFlt</a>.</p>
<p >To check if <a class="el" href="classby_1_1n_flt.html" title="Float primitive type in byeol language">nFlt</a> is a kind of node, use the meta module's type conversion via <code>cast()</code>. The meta module manages native environment types in C++ code. Thus, two type conversion systems exist: one for native (C++) and one for managed (byeol language):</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified inheritance relationship of nFlt and nInt:</span></div>
<div class="line"><span class="keyword">class </span>nFlt : <span class="keyword">public</span> obj {};</div>
<div class="line"><span class="keyword">class </span>nInt : <span class="keyword">public</span> obj {};</div>
<div class="line"><span class="keyword">class </span>obj : <span class="keyword">public</span> node {};</div>
<div class="line"> </div>
<div class="line">nInt val1;</div>
<div class="line">nFlt val2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Native type conversion:</span></div>
<div class="line">nFlt* cast1 = <span class="keyword">dynamic_cast&lt;</span>nFlt<span class="keyword">&gt;</span>(val1);  <span class="comment">// nullptr: disallowed conversion</span></div>
<div class="line">nFlt* cast2 = val1.cast&lt;val2&gt;();          <span class="comment">// nullptr: same, using meta module conversion</span></div>
<div class="line">node* isNode = val1.cast&lt;node&gt;();         <span class="comment">// != nullptr: upcasting allowed</span></div>
<div class="line">isNode-&gt;cast&lt;nFlt&gt;();                     <span class="comment">// nullptr</span></div>
<div class="line">&amp;val1 == isNode-&gt;cast&lt;nInt&gt;();            <span class="comment">// true</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Managed type conversion:</span></div>
<div class="line">val1.is&lt;nFlt&gt;(); <span class="comment">// true: byeol supports explicit int &lt;-&gt; flt conversion</span></div>
</div><!-- fragment --><p >The core module often implements the same concept separately for native and managed environments. Get familiar with this pattern. See <a class="el" href="classby_1_1ases.html">ases</a> and <a class="el" href="classby_1_1asable.html">asable</a> for type conversion flow details.</p>
<h1><a class="anchor" id="implicit_explicit"></a>
Implicit vs Explicit Conversion</h1>
<p >Implicit conversion is provided via <code>impliAs()</code> and <code>impliIs()</code>. Rarely called directly by external code; mostly invoked by AST classes like <a class="el" href="classby_1_1expr.html">expr</a> and <a class="el" href="classby_1_1base_func.html">baseFunc</a>. User-defined type conversions are naturally excluded from implicit conversion, hence the distinction.</p>
<h1><a class="anchor" id="visitable_class"></a>
Visitable Class</h1>
<p >AST traversal occurs for various purposes, not just <code>eval()</code> but also for debugging output. To separate traversal methods from node processing, the visitor pattern must be applied to nodes. <code>accept()</code> is used by the <a class="el" href="classby_1_1visitor.html">visitor</a> class, and each class header requires the VISIT macro. See <a class="el" href="classby_1_1visitor.html">visitor</a> for details.</p>
<h1><a class="anchor" id="frame_interaction"></a>
Frame Interaction</h1>
<p ><a class="el" href="classby_1_1frame.html">frame</a> manages the currently executing scope and registered symbols. Since node forms the AST base, if a node is an object or function, it must register or unregister owned functions or properties with the frame. <code>inFrame()</code> and <code>outFrame()</code> handle this. See <a class="el" href="classby_1_1frame.html">frame</a> for details.</p>
<h1><a class="anchor" id="message_priority"></a>
Message Priority</h1>
<p >Byeol supports function overloading, so an object may have multiple functions with the same name but different parameters. Some functions match args exactly, while others may require type conversion. Node uses <code>prioritize()</code> to determine how well child nodes match given args. Derived node classes return EXACT_MATCH for precise matches and NO_MATCH otherwise. See <a class="el" href="structby_1_1tprior.html">tprior</a> and priorType for detailed criteria and algorithms. </p>
</div><h2 class="groupheader">멤버 함수 문서화</h2>
<a id="a3bf7de9c828022e0eb5dde3d462d645c" name="a3bf7de9c828022e0eb5dde3d462d645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf7de9c828022e0eb5dde3d462d645c">&#9670;&nbsp;</a></span>_onEvalSub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classby_1_1tstr.html">str</a> by::node::_onEvalSub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classby_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classby_1_1args.html">args</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected virtual method for evaluating a sub-node. </p>
<p >This method is a crucial part of the evaluation mechanism, allowing derived classes to define how a specific sub-node is evaluated within the context of the current node. </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The sub-node to be evaluated. </td></tr>
    <tr><td class="paramname">a</td><td>The arguments for evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>반환값</dt><dd>The result of the evaluation as a <code>str</code> object. </dd></dl>

<p><a class="el" href="classby_1_1base_obj.html#a7612588286f4ab3d4410b2e2597fd80a">by::baseObj</a>, <a class="el" href="classby_1_1generic_origin.html#a76b7c3e191ba5c5c21fa4caa6217a810">by::genericOrigin</a>, <a class="el" href="classby_1_1slot.html#a069bc3facea2305fedd14f3341f04196">by::slot</a>에서 재구현되었습니다.</p>

</div>
</div>
<a id="a168a80ea572c628b9206aad1a7a6d7d9" name="a168a80ea572c628b9206aad1a7a6d7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168a80ea572c628b9206aad1a7a6d7d9">&#9670;&nbsp;</a></span>infer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classby_1_1tstr.html">str</a> by::node::infer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >getType() returns what it is. opposite to it, this returns what this class will represents after evaluation.</p>
<p >for example, the <a class="el" href="classby_1_1expr.html">expr</a> class has derived from this node class. and if an user call the funcs to get type of it, class 'ntype' of 'expr' will be returned. but if that user call the '<a class="el" href="classby_1_1node.html#a168a80ea572c628b9206aad1a7a6d7d9">infer()</a>' then the 'expr' object evaluate its terms and returns it as a node from the output. it could be an integer if it was addExpr and all terms are constructed with integers.</p>
<p >and also this func requires frames. means that you have to interact frame first before call this func. </p><dl class="section remark"><dt>Remarks</dt><dd>some derived class of node may require to call this function first by <a class="el" href="classby_1_1verifier.html">verifier</a>. if you call this function without calling <a class="el" href="classby_1_1verifier.html">verifier</a> previously will damage then process. </dd></dl>

<p><a class="el" href="classby_1_1base_ctor.html#a10f125f079fd244514fd227f65c5711d">by::baseCtor</a>, <a class="el" href="classby_1_1ctor.html#a0321075c1f26daddd3a20cc59297a1fa">by::ctor</a>, <a class="el" href="classby_1_1as_expr.html#a4538bfb27b89760a0ca083a227635bd8">by::asExpr</a>, <a class="el" href="classby_1_1assign_expr.html#a0be6cf2710a51c84eac22503825ea101">by::assignExpr</a>, <a class="el" href="classby_1_1block_expr.html#a953330b9d03e803e3b040b04840aac4e">by::blockExpr</a>, <a class="el" href="classby_1_1def_array_expr.html#a4cad676367cfba4156bbf884f34ec117">by::defArrayExpr</a>, <a class="el" href="classby_1_1def_assign_expr.html#addd9f95f3b9983fc81df0ae46b2517e2">by::defAssignExpr</a>, <a class="el" href="classby_1_1def_seq_expr.html#a6ea08763c22b92f46ec10ad6a8bf1e92">by::defSeqExpr</a>, <a class="el" href="classby_1_1def_var_expr.html#a4012b1a5a805326aebb30fc870d4b16d">by::defVarExpr</a>, <a class="el" href="classby_1_1end_expr.html#a6012dac87e80856bf6a2b7bad39a7845">by::endExpr</a>, <a class="el" href="classby_1_1eval_expr.html#acf9c95959869c3fa5b2812553b078e0a">by::evalExpr</a>, <a class="el" href="classby_1_1_f_b_o_expr.html#a1f10915c307135fbba47bbe006da1f21">by::FBOExpr</a>, <a class="el" href="classby_1_1get_expr.html#adf45e8c701ff2c81e9dba0579d3de18a">by::getExpr</a>, <a class="el" href="classby_1_1if_expr.html#a4f540f2e8a5d5d14932175ab816cf7ce">by::ifExpr</a>, <a class="el" href="classby_1_1is_expr.html#a4f8a94d672719bf55781617ae9176866">by::isExpr</a>, <a class="el" href="classby_1_1loop_expr.html#ad57cf07c970ff1a390d4cb24b281392b">by::loopExpr</a>, <a class="el" href="classby_1_1ret_expr.html#a43fcfcca37c83095842523bf0a8b1472">by::retExpr</a>, <a class="el" href="classby_1_1generic_origin.html#a8d9438eed9c149f2ce6f4b53bb5c4c39">by::genericOrigin</a>, <a class="el" href="classby_1_1slot.html#ac23b59daca7619c3d14ada8eb51c6846">by::slot</a>에서 재구현되었습니다.</p>

</div>
</div>
<a id="a91ecc490beef9748730cc37f93a1161b" name="a91ecc490beef9748730cc37f93a1161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ecc490beef9748730cc37f93a1161b">&#9670;&nbsp;</a></span>inFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void by::node::inFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1tbicontainable.html">bicontainable</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1frame_interactable.html">by::frameInteractable</a>를 구현.</p>

</div>
</div>
<a id="a27e42c1571a2ddd2b47869f8e80d9f3f" name="a27e42c1571a2ddd2b47869f8e80d9f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e42c1571a2ddd2b47869f8e80d9f3f">&#9670;&nbsp;</a></span>inFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void by::frameInteractable::inFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1tbicontainable.html">bicontainable</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1frame_interactable.html">by::frameInteractable</a>를 구현.</p>

</div>
</div>
<a id="a422800bf7875c45e31b13feab65547d0" name="a422800bf7875c45e31b13feab65547d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422800bf7875c45e31b13feab65547d0">&#9670;&nbsp;</a></span>isComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nbool by::node::isComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >returns whether this instance is complete or not. if some instance is incomplete, it means that it's not accessible on byeolang source codes. </p>

<p><a class="el" href="classby_1_1origin.html#a0677eaaff5fceb681e56b5acb03ff7bd">by::origin</a>에서 재구현되었습니다.</p>

</div>
</div>
<a id="a02c32818426ab990c0beeaf171eb9558" name="a02c32818426ab990c0beeaf171eb9558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c32818426ab990c0beeaf171eb9558">&#9670;&nbsp;</a></span>outFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void by::node::outFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1frame_interactable.html">by::frameInteractable</a>를 구현.</p>

</div>
</div>
<a id="af6fe51f0720c46b9ee00ea15b137a510" name="af6fe51f0720c46b9ee00ea15b137a510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fe51f0720c46b9ee00ea15b137a510">&#9670;&nbsp;</a></span>outFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void by::frameInteractable::outFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1frame_interactable.html">by::frameInteractable</a>를 구현.</p>

</div>
</div>
<a id="ada65608a5bb8d5d0c01a291f84dbc1d3" name="ada65608a5bb8d5d0c01a291f84dbc1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada65608a5bb8d5d0c01a291f84dbc1d3">&#9670;&nbsp;</a></span>prioritize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="tpriorities_8hpp.html#a1a65fd37188763b1ebe002fc60d4608e">priorType</a> by::node::prioritize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1args.html">args</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1expr.html#a31d760e6647054482a123889b4261799">by::expr</a>, <a class="el" href="classby_1_1ret_expr.html#aea39c3c888feaf0bbe8371e4ed3ee171">by::retExpr</a>에서 구현되었습니다.</p>

</div>
</div>
<a id="a3c27e99e2b0d28af967ea721acc3df40" name="a3c27e99e2b0d28af967ea721acc3df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27e99e2b0d28af967ea721acc3df40">&#9670;&nbsp;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classby_1_1node.html">node</a> * by::node::promote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classby_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>type to be promoted to this type. if a type is null, it means that there is no type specified. it's complete different to 'void' type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>반환값</dt><dd>null if it's not relative between l &amp; r. </dd></dl>

</div>
</div>
<a id="ac5a636219cb26fbd6c32e38f4b3a5c81" name="ac5a636219cb26fbd6c32e38f4b3a5c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a636219cb26fbd6c32e38f4b3a5c81">&#9670;&nbsp;</a></span>rel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void by::node::rel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Release all held resources and prepare for termination. </p><dl class="section remark"><dt>Remarks</dt><dd>Some classes won't be able to reinitialize after <a class="el" href="classby_1_1node.html#ac5a636219cb26fbd6c32e38f4b3a5c81">rel()</a> is called. </dd></dl>

<p><a class="el" href="classby_1_1autoslot.html#a1144881a1256d6fd289636d07f92caba">by::autoslot</a>, <a class="el" href="classby_1_1block_expr.html#a5b63daeb5b5caff442a5be3936acf177">by::blockExpr</a>, <a class="el" href="classby_1_1frame.html#a2779d034aee4cd68fceeb892faf86bbd">by::frame</a>, <a class="el" href="classby_1_1thread.html#a05563f2bb3df2fa85310a0f37f47c343">by::thread</a>에서 재구현되었습니다.</p>

</div>
</div>
<a id="a331ff4f9b78b53cb893dfaaa6d9645de" name="a331ff4f9b78b53cb893dfaaa6d9645de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331ff4f9b78b53cb893dfaaa6d9645de">&#9670;&nbsp;</a></span>subAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = me&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classby_1_1tpriorities.html">tpriorities</a>&lt; T &gt; by::node::subAll </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >finds subnodes of this node, allowing implicit conversion based on name and arguments. </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>if you pass this as a nullptr, the argument will be ignored and all names that are the same will be considered to meet the condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>경고</dt><dd>if you pass the argument as <code>args()</code>, it will be considered to meet the condition only if there are no parameters and the names are the same, so the two have completely different meanings. </dd></dl>

</div>
</div>
<a id="a5e1d3547d21b47a47734d0a13959cb60" name="a5e1d3547d21b47a47734d0a13959cb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1d3547d21b47a47734d0a13959cb60">&#9670;&nbsp;</a></span>subs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__core.html#gaec057623c97cf8804f9f793f36f492df">scope</a> &amp; by::node::subs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a tstr to a container of immediate sub-nodes (excluding inherited or chained ones). </p>
<p >This method provides direct access to the immediate children owned by this node, distinguishing them from children accessible via chained scopes or inheritance. </p><dl class="section return"><dt>반환값</dt><dd>A tstr to a container holding the immediate sub-nodes. </dd></dl>

</div>
</div>
<hr/>이 클래스에 대한 문서화 페이지는 다음의 파일로부터 생성되었습니다.:<ul>
<li>/home/runner/work/byeol/byeol/module/core/ast/<a class="el" href="node_8hpp_source.html">node.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
