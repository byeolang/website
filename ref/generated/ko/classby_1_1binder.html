<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: by::binder 클래스 참조</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classby_1_1binder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 멤버 함수</a> &#124;
<a href="#pro-methods">Protected 멤버 함수</a> &#124;
<a href="#pro-attribs">Protected 속성</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classby_1_1binder-members.html">모든 멤버 목록</a>  </div>
  <div class="headertitle"><div class="title">by::binder 클래스 참조<div class="ingroups"><a class="el" href="group__memlite.html">Memlite</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Generalized binding class for managing instance lifecycles  
 <a href="#details">더 자세히 ...</a></p>

<p><code>#include &lt;<a class="el" href="binder_2binder_8hpp_source.html">binder.hpp</a>&gt;</code></p>
<div class="dynheader">
by::binder에 대한 상속 다이어그램 : </div>
<div class="dyncontent">
 <div class="center">
  <img src="classby_1_1binder.png" usemap="#by::binder_map" alt=""/>
  <map id="by::binder_map" name="by::binder_map">
<area href="classby_1_1type_providable.html" title="Interface for objects that can provide their type information" alt="by::typeProvidable" shape="rect" coords="0,0,221,24"/>
<area href="classby_1_1tbindable.html" alt="by::tbindable&lt; instance &gt;" shape="rect" coords="231,0,452,24"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::errReport, strTactic &gt;" shape="rect" coords="346,112,567,136"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; flagArgs, strTactic &gt;" shape="rect" coords="346,168,567,192"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::baseObj, strTactic &gt;" shape="rect" coords="346,224,567,248"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::baseFunc, strTactic &gt;" shape="rect" coords="346,280,567,304"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; pack, strTactic &gt;" shape="rect" coords="346,336,567,360"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; node, strTactic &gt;" shape="rect" coords="346,392,567,416"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::src, strTactic &gt;" shape="rect" coords="346,448,567,472"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; super, strTactic &gt;" shape="rect" coords="346,504,567,528"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; T, strTactic &gt;" shape="rect" coords="346,560,567,584"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::frames, strTactic &gt;" shape="rect" coords="346,616,567,640"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::modifier, strTactic &gt;" shape="rect" coords="346,672,567,696"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::arr, strTactic &gt;" shape="rect" coords="346,728,567,752"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::tnchain, strTactic &gt;" shape="rect" coords="346,784,567,808"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::tnarr, strTactic &gt;" shape="rect" coords="346,840,567,864"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::func, strTactic &gt;" shape="rect" coords="346,896,567,920"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::nStr, strTactic &gt;" shape="rect" coords="346,952,567,976"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::obj &gt;" shape="rect" coords="346,1008,567,1032"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::func &gt;" shape="rect" coords="346,1064,567,1088"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::srcFile, strTactic &gt;" shape="rect" coords="346,1120,567,1144"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::obj, strTactic &gt;" shape="rect" coords="346,1176,567,1200"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::blockExpr, strTactic &gt;" shape="rect" coords="346,1232,567,1256"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::args, strTactic &gt;" shape="rect" coords="346,1288,567,1312"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::tnmap, strTactic &gt;" shape="rect" coords="346,1344,567,1368"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::stela, strTactic &gt;" shape="rect" coords="346,1400,567,1424"/>
<area href="classby_1_1tweak.html" alt="by::tweak&lt; by::thread, strTactic &gt;" shape="rect" coords="346,1456,567,1480"/>
<area href="classby_1_1tweak.html" title="Weak reference smart pointer with type-safe access" alt="by::tweak&lt; T, TACTIC &gt;" shape="rect" coords="346,1512,567,1536"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 멤버 함수</h2></td></tr>
<tr class="memitem:a49b4b4287d4d23a1b5f4475a81a5e31f" id="r_a49b4b4287d4d23a1b5f4475a81a5e31f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b4b4287d4d23a1b5f4475a81a5e31f">binder</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="classby_1_1type.html">type</a>, <a class="el" href="classby_1_1bind_tacticable.html">bindTacticable</a> &amp;<a class="el" href="structby_1_1no_wrap.html">tactic</a>)</td></tr>
<tr class="memdesc:a49b4b4287d4d23a1b5f4475a81a5e31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a binder with a specific type and binding tactic.  <br /></td></tr>
<tr class="separator:a49b4b4287d4d23a1b5f4475a81a5e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d95f032d5114b8f4c52ba614e50d0f1" id="r_a2d95f032d5114b8f4c52ba614e50d0f1"><td class="memItemLeft" align="right" valign="top"><a id="a2d95f032d5114b8f4c52ba614e50d0f1" name="a2d95f032d5114b8f4c52ba614e50d0f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>binder</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;rhs)</td></tr>
<tr class="separator:a2d95f032d5114b8f4c52ba614e50d0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ae31b7732a4dbcf9ed895308f56c8e" id="r_a31ae31b7732a4dbcf9ed895308f56c8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classby_1_1instance.html">instance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31ae31b7732a4dbcf9ed895308f56c8e">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a31ae31b7732a4dbcf9ed895308f56c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator to access bound instance  <br /></td></tr>
<tr class="separator:a31ae31b7732a4dbcf9ed895308f56c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107f543708422700dd361477d6b1f2d8" id="r_a107f543708422700dd361477d6b1f2d8"><td class="memItemLeft" align="right" valign="top"><a id="a107f543708422700dd361477d6b1f2d8" name="a107f543708422700dd361477d6b1f2d8"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(<a class="el" href="structby_1_1no_wrap.html">operator</a>-&gt;()) <a class="el" href="classby_1_1instance.html">instance</a> &amp;<a class="el" href="structby_1_1no_wrap.html">operator</a>*()</td></tr>
<tr class="separator:a107f543708422700dd361477d6b1f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e8d38d79c0911aeb647047784660d2" id="r_a50e8d38d79c0911aeb647047784660d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50e8d38d79c0911aeb647047784660d2">operator*</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(<a class="el" href="structby_1_1no_wrap.html">operator</a>*()) me &amp;<a class="el" href="structby_1_1no_wrap.html">operator</a></td></tr>
<tr class="memdesc:a50e8d38d79c0911aeb647047784660d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns another binder's bound instance to this binder.  <br /></td></tr>
<tr class="separator:a50e8d38d79c0911aeb647047784660d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e19ad120640f64ba322a497cae7a10" id="r_ab9e19ad120640f64ba322a497cae7a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1id.html">id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9e19ad120640f64ba322a497cae7a10">getItsId</a> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:ab9e19ad120640f64ba322a497cae7a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the unique ID of the instance currently bound by this binder.  <br /></td></tr>
<tr class="separator:ab9e19ad120640f64ba322a497cae7a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9096a1115c2e48a07f7464f2a1c1bb1a" id="r_a9096a1115c2e48a07f7464f2a1c1bb1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9096a1115c2e48a07f7464f2a1c1bb1a">isBind</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="separator:a9096a1115c2e48a07f7464f2a1c1bb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ea5de5075f5815ca96352ec350422" id="r_a038ea5de5075f5815ca96352ec350422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a038ea5de5075f5815ca96352ec350422">rel</a> () <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="separator:a038ea5de5075f5815ca96352ec350422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62644cd115f0e1dc528fde6447e2f0a0" id="r_a62644cd115f0e1dc528fde6447e2f0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62644cd115f0e1dc528fde6447e2f0a0">canBind</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="memdesc:a62644cd115f0e1dc528fde6447e2f0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if given type can be bound to this binder  <br /></td></tr>
<tr class="separator:a62644cd115f0e1dc528fde6447e2f0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876d0a090326604be8e4116408ea734f" id="r_a876d0a090326604be8e4116408ea734f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a876d0a090326604be8e4116408ea734f">bind</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="memdesc:a876d0a090326604be8e4116408ea734f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds instance to this binder with reference counting  <br /></td></tr>
<tr class="separator:a876d0a090326604be8e4116408ea734f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd00708a081a71c3c0ba528f051ea40" id="r_acbd00708a081a71c3c0ba528f051ea40"><td class="memItemLeft" align="right" valign="top"><a id="acbd00708a081a71c3c0ba528f051ea40" name="acbd00708a081a71c3c0ba528f051ea40"></a>
<a class="el" href="classby_1_1instance.html">instance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> ()</td></tr>
<tr class="separator:acbd00708a081a71c3c0ba528f051ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a899afabf57bd5908c175bbe9bc954a" id="r_a0a899afabf57bd5908c175bbe9bc954a"><td class="memItemLeft" align="right" valign="top"><a id="a0a899afabf57bd5908c175bbe9bc954a" name="a0a899afabf57bd5908c175bbe9bc954a"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(get()) <a class="el" href="structby_1_1no_wrap.html">template</a>&lt; <a class="el" href="structby_1_1no_wrap.html">typename</a> <a class="el" href="structby_1_1no_wrap.html">E</a> &gt; <a class="el" href="structby_1_1no_wrap.html">E</a> *get()</td></tr>
<tr class="separator:a0a899afabf57bd5908c175bbe9bc954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d2757a9525364fa2b2fa9998ccbcda" id="r_ab5d2757a9525364fa2b2fa9998ccbcda"><td class="memTemplParams" colspan="2"><a id="ab5d2757a9525364fa2b2fa9998ccbcda" name="ab5d2757a9525364fa2b2fa9998ccbcda"></a>
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> <a class="el" href="structby_1_1no_wrap.html">E</a> &gt; </td></tr>
<tr class="memitem:ab5d2757a9525364fa2b2fa9998ccbcda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">E</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(get&lt; <a class="el" href="structby_1_1no_wrap.html">E</a> &gt;()) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;getType() <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="separator:ab5d2757a9525364fa2b2fa9998ccbcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3f0db699fff7666bf08a1f0d23084d" id="r_afc3f0db699fff7666bf08a1f0d23084d"><td class="memItemLeft" align="right" valign="top"><a id="afc3f0db699fff7666bf08a1f0d23084d" name="afc3f0db699fff7666bf08a1f0d23084d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="structby_1_1no_wrap.html">to</a>) <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="separator:afc3f0db699fff7666bf08a1f0d23084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a21c2610ea2c73b81a6c2657acb4be" id="r_ab9a21c2610ea2c73b81a6c2657acb4be"><td class="memItemLeft" align="right" valign="top"><a id="ab9a21c2610ea2c73b81a6c2657acb4be" name="ab9a21c2610ea2c73b81a6c2657acb4be"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> T &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ab9a21c2610ea2c73b81a6c2657acb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b847a63dcc863bd21352cccc2f8c03" id="r_a43b847a63dcc863bd21352cccc2f8c03"><td class="memItemLeft" align="right" valign="top"><a id="a43b847a63dcc863bd21352cccc2f8c03" name="a43b847a63dcc863bd21352cccc2f8c03"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> T *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(canBind)</td></tr>
<tr class="separator:a43b847a63dcc863bd21352cccc2f8c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ed58531270d88871826faf1f3472ee" id="r_a42ed58531270d88871826faf1f3472ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ed58531270d88871826faf1f3472ee">canBind</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a>=0</td></tr>
<tr class="separator:a42ed58531270d88871826faf1f3472ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9178875b22b692a75582354be6292918" id="r_a9178875b22b692a75582354be6292918"><td class="memItemLeft" align="right" valign="top"><a id="a9178875b22b692a75582354be6292918" name="a9178875b22b692a75582354be6292918"></a>
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(canBind)</td></tr>
<tr class="separator:a9178875b22b692a75582354be6292918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e3f362fc3c6183ce44b2997aec3e6d" id="r_a69e3f362fc3c6183ce44b2997aec3e6d"><td class="memItemLeft" align="right" valign="top"><a id="a69e3f362fc3c6183ce44b2997aec3e6d" name="a69e3f362fc3c6183ce44b2997aec3e6d"></a>
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> T &amp;it)</td></tr>
<tr class="separator:a69e3f362fc3c6183ce44b2997aec3e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69159b910a8dbc6b07409dfe68da90de" id="r_a69159b910a8dbc6b07409dfe68da90de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69159b910a8dbc6b07409dfe68da90de">bind</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> T *it)</td></tr>
<tr class="memdesc:a69159b910a8dbc6b07409dfe68da90de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to instance pointer  <br /></td></tr>
<tr class="separator:a69159b910a8dbc6b07409dfe68da90de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329" id="r_af6f60075f199d6eb48d39ed8e33b4329"><td class="memTemplParams" colspan="2"><a id="af6f60075f199d6eb48d39ed8e33b4329" name="af6f60075f199d6eb48d39ed8e33b4329"></a>
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> ()</td></tr>
<tr class="separator:af6f60075f199d6eb48d39ed8e33b4329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3" id="r_ad05c9ba2164853c3e8db3af3cb5198c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad05c9ba2164853c3e8db3af3cb5198c3">cast</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(cast&lt; T &gt;()) <a class="el" href="structby_1_1no_wrap.html">virtual</a> void *cast(<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="structby_1_1no_wrap.html">to</a>)</td></tr>
<tr class="memdesc:ad05c9ba2164853c3e8db3af3cb5198c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast to target type using type hierarchy information  <br /></td></tr>
<tr class="separator:ad05c9ba2164853c3e8db3af3cb5198c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d50919c02f16448bc84396c625dd5b" id="r_a09d50919c02f16448bc84396c625dd5b"><td class="memItemLeft" align="right" valign="top"><a id="a09d50919c02f16448bc84396c625dd5b" name="a09d50919c02f16448bc84396c625dd5b"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="structby_1_1no_wrap.html">to</a>) <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(cast(<a class="el" href="structby_1_1no_wrap.html">to</a>)) void *cast(<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(cast)</td></tr>
<tr class="separator:a09d50919c02f16448bc84396c625dd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1type_providable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classby_1_1type_providable')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1type_providable.html">by::typeProvidable</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:ae79a4ecc80915511509195a4d6949643 inherit pub_methods_classby_1_1type_providable" id="r_ae79a4ecc80915511509195a4d6949643"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;rhs) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ae79a4ecc80915511509195a4d6949643 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588f51a220cf4eca9e7df44ff04977e7 inherit pub_methods_classby_1_1type_providable" id="r_a588f51a220cf4eca9e7df44ff04977e7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;rhs) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a588f51a220cf4eca9e7df44ff04977e7 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e69312548672dbcad53a369ded5630 inherit pub_methods_classby_1_1type_providable" id="r_aa4e69312548672dbcad53a369ded5630"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getType</b> () <a class="el" href="structby_1_1no_wrap.html">const</a> =0</td></tr>
<tr class="separator:aa4e69312548672dbcad53a369ded5630 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07327fb7b52a45b6fbaa48ae0eb89f inherit pub_methods_classby_1_1type_providable" id="r_a2f07327fb7b52a45b6fbaa48ae0eb89f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a2f07327fb7b52a45b6fbaa48ae0eb89f inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390706279ba9b1d3edc72b8e24096931 inherit pub_methods_classby_1_1type_providable" id="r_a390706279ba9b1d3edc72b8e24096931"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:a390706279ba9b1d3edc72b8e24096931 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b7129535e10f7455631f9dd83ef44 inherit pub_methods_classby_1_1type_providable" id="r_a159b7129535e10f7455631f9dd83ef44"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a159b7129535e10f7455631f9dd83ef44 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2461c92af9ee4f424a197beb341135a2 inherit pub_methods_classby_1_1type_providable" id="r_a2461c92af9ee4f424a197beb341135a2"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSub</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSub)</td></tr>
<tr class="separator:a2461c92af9ee4f424a197beb341135a2 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a58d5c9754baf2cac10f00d3c464fb4 inherit pub_methods_classby_1_1type_providable" id="r_a9a58d5c9754baf2cac10f00d3c464fb4"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a9a58d5c9754baf2cac10f00d3c464fb4 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88afd96107b542735244fcc761385f08 inherit pub_methods_classby_1_1type_providable" id="r_a88afd96107b542735244fcc761385f08"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:a88afd96107b542735244fcc761385f08 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a93289f111e4000ee98a943149409c4 inherit pub_methods_classby_1_1type_providable" id="r_a6a93289f111e4000ee98a943149409c4"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a6a93289f111e4000ee98a943149409c4 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24df0319e39a1ebd35cfdd3b9ea09f72 inherit pub_methods_classby_1_1type_providable" id="r_a24df0319e39a1ebd35cfdd3b9ea09f72"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSuper</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> me *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(isSuper)</td></tr>
<tr class="separator:a24df0319e39a1ebd35cfdd3b9ea09f72 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable" id="r_aacf82d8ddf74c862902802dfad217ddc"><td class="memTemplParams" colspan="2">
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSub</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:aacf82d8ddf74c862902802dfad217ddc inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable" id="r_aa64bd64ab1354fb0dc0689389bc485c6"><td class="memTemplParams" colspan="2">
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isSuper</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:aa64bd64ab1354fb0dc0689389bc485c6 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable" id="r_af6f60075f199d6eb48d39ed8e33b4329"><td class="memTemplParams" colspan="2">
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> ()</td></tr>
<tr class="separator:af6f60075f199d6eb48d39ed8e33b4329 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable" id="r_ad05c9ba2164853c3e8db3af3cb5198c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">const</a> T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classby_1_1type_providable.html#ad05c9ba2164853c3e8db3af3cb5198c3">cast</a> () <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(cast&lt; T &gt;()) <a class="el" href="structby_1_1no_wrap.html">virtual</a> void *cast(<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="structby_1_1no_wrap.html">to</a>)</td></tr>
<tr class="memdesc:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe cast to target type using type hierarchy information  <br /></td></tr>
<tr class="separator:ad05c9ba2164853c3e8db3af3cb5198c3 inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d50919c02f16448bc84396c625dd5b inherit pub_methods_classby_1_1type_providable" id="r_a09d50919c02f16448bc84396c625dd5b"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">const</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>cast</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;<a class="el" href="structby_1_1no_wrap.html">to</a>) <a class="el" href="structby_1_1no_wrap.html">const</a> BY_CONST_FUNC(cast(<a class="el" href="structby_1_1no_wrap.html">to</a>)) void *cast(<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(cast)</td></tr>
<tr class="separator:a09d50919c02f16448bc84396c625dd5b inherit pub_methods_classby_1_1type_providable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classby_1_1tbindable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classby_1_1tbindable')"><img src="closed.png" alt="-"/>&#160;<a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>(으)로부터 상속된 Public 멤버 함수</td></tr>
<tr class="memitem:a1308e87b9ed85ad6d75856303e1066c7 inherit pub_methods_classby_1_1tbindable" id="r_a1308e87b9ed85ad6d75856303e1066c7"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>operator nbool</b> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:a1308e87b9ed85ad6d75856303e1066c7 inherit pub_methods_classby_1_1tbindable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69159b910a8dbc6b07409dfe68da90de inherit pub_methods_classby_1_1tbindable" id="r_a69159b910a8dbc6b07409dfe68da90de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1tbindable.html#a69159b910a8dbc6b07409dfe68da90de">bind</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> *it)</td></tr>
<tr class="memdesc:a69159b910a8dbc6b07409dfe68da90de inherit pub_methods_classby_1_1tbindable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to instance pointer  <br /></td></tr>
<tr class="separator:a69159b910a8dbc6b07409dfe68da90de inherit pub_methods_classby_1_1tbindable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a21c2610ea2c73b81a6c2657acb4be inherit pub_methods_classby_1_1tbindable" id="r_ab9a21c2610ea2c73b81a6c2657acb4be"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> &amp;it) <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="separator:ab9a21c2610ea2c73b81a6c2657acb4be inherit pub_methods_classby_1_1tbindable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b847a63dcc863bd21352cccc2f8c03 inherit pub_methods_classby_1_1tbindable" id="r_a43b847a63dcc863bd21352cccc2f8c03"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(canBind)</td></tr>
<tr class="separator:a43b847a63dcc863bd21352cccc2f8c03 inherit pub_methods_classby_1_1tbindable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9178875b22b692a75582354be6292918 inherit pub_methods_classby_1_1tbindable" id="r_a9178875b22b692a75582354be6292918"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canBind</b> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *it) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(canBind)</td></tr>
<tr class="separator:a9178875b22b692a75582354be6292918 inherit pub_methods_classby_1_1tbindable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected 멤버 함수</h2></td></tr>
<tr class="memitem:a67a771ff88056d4cb4bdfcca5db681e4" id="r_a67a771ff88056d4cb4bdfcca5db681e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67a771ff88056d4cb4bdfcca5db681e4">_assign</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1binder.html">binder</a> &amp;rhs)</td></tr>
<tr class="memdesc:a67a771ff88056d4cb4bdfcca5db681e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns binder from another binder  <br /></td></tr>
<tr class="separator:a67a771ff88056d4cb4bdfcca5db681e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcad99d72defbd4df3e158119ba51c2d" id="r_afcad99d72defbd4df3e158119ba51c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structby_1_1no_wrap.html">nbool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcad99d72defbd4df3e158119ba51c2d">_onSame</a> (<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;rhs) <a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="structby_1_1no_wrap.html">override</a></td></tr>
<tr class="memdesc:afcad99d72defbd4df3e158119ba51c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classby_1_1type_providable.html" title="Interface for objects that can provide their type information">typeProvidable</a> objects are same instance  <br /></td></tr>
<tr class="separator:afcad99d72defbd4df3e158119ba51c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74d172ef4ab08dd3a0b479485f87e9" id="r_a7a74d172ef4ab08dd3a0b479485f87e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classby_1_1life.html">life</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a74d172ef4ab08dd3a0b479485f87e9">_getBindTag</a> () <a class="el" href="structby_1_1no_wrap.html">const</a></td></tr>
<tr class="memdesc:a7a74d172ef4ab08dd3a0b479485f87e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves life object associated with bound instance  <br /></td></tr>
<tr class="separator:a7a74d172ef4ab08dd3a0b479485f87e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 속성</h2></td></tr>
<tr class="memitem:a1043ee5517c728dbef01b8313ebc8612" id="r_a1043ee5517c728dbef01b8313ebc8612"><td class="memItemLeft" align="right" valign="top"><a id="a1043ee5517c728dbef01b8313ebc8612" name="a1043ee5517c728dbef01b8313ebc8612"></a>
<a class="el" href="structby_1_1id.html">id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_itsId</b></td></tr>
<tr class="separator:a1043ee5517c728dbef01b8313ebc8612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40ebcb1b13f1f0511f9f5941e435506" id="r_ae40ebcb1b13f1f0511f9f5941e435506"><td class="memItemLeft" align="right" valign="top"><a id="ae40ebcb1b13f1f0511f9f5941e435506" name="ae40ebcb1b13f1f0511f9f5941e435506"></a>
<a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_type</b></td></tr>
<tr class="separator:ae40ebcb1b13f1f0511f9f5941e435506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7209f84466e60b52215735ea0c5776" id="r_a2a7209f84466e60b52215735ea0c5776"><td class="memItemLeft" align="right" valign="top"><a id="a2a7209f84466e60b52215735ea0c5776" name="a2a7209f84466e60b52215735ea0c5776"></a>
<a class="el" href="classby_1_1bind_tacticable.html">bindTacticable</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_tactic</b></td></tr>
<tr class="separator:a2a7209f84466e60b52215735ea0c5776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a60519f1c6bd00b89a29ae86c8942f82d" id="r_a60519f1c6bd00b89a29ae86c8942f82d"><td class="memItemLeft" align="right" valign="top"><a id="a60519f1c6bd00b89a29ae86c8942f82d" name="a60519f1c6bd00b89a29ae86c8942f82d"></a>
<a class="el" href="structby_1_1no_wrap.html">struct</a>&#160;</td><td class="memItemRight" valign="bottom"><b>::binderTest</b></td></tr>
<tr class="separator:a60519f1c6bd00b89a29ae86c8942f82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">상세한 설명</h2>
<div class="textblock"><p>Generalized binding class for managing instance lifecycles </p>
<p>Can bind any object inheriting from instance. Uses reference counting to properly destroy objects at appropriate times. Similar to std::weak_ptr and std::shared_ptr, with <a class="el" href="classby_1_1tweak.html">tweak</a> handling weak pointers and <a class="el" href="classby_1_1tstr.html">tstr</a> handling strong pointers.</p>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<p>Basic usage with <a class="el" href="#a876d0a090326604be8e4116408ea734f" title="Binds instance to this binder with reference counting">bind()</a>, isBind(), and get(): </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_struct" href="structby_1_1no_wrap.html">A</a> : <span class="keyword">public</span> <a class="code hl_class" href="classby_1_1instance.html">instance</a> {}; <span class="comment">// Inherits instance, so bindable</span></div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">A</a>* <a class="code hl_struct" href="structby_1_1no_wrap.html">a</a> = <span class="keyword">new</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">A</a>();</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">tstr&lt;A&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">strBinder</a>;</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">strBinder</a>.bind(<a class="code hl_struct" href="structby_1_1no_wrap.html">a</a>);</div>
<div class="line">    <span class="comment">// a&#39;s life count becomes 1</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">strBinder</a>.isBind(); <span class="comment">// true</span></div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">a</a> == <a class="code hl_struct" href="structby_1_1no_wrap.html">strBinder</a>.get(); <span class="comment">// true</span></div>
<div class="line">} <span class="comment">// strBinder destroys, life count becomes 0, a automatically destroyed</span></div>
<div class="line"> </div>
<div class="line">*a; <span class="comment">// Error: using destroyed object</span></div>
<div class="ttc" id="aclassby_1_1instance_html"><div class="ttname"><a href="classby_1_1instance.html">by::instance</a></div><div class="ttdoc">Base class for all managed instances in memlite system</div><div class="ttdef"><b>Definition</b> instance.hpp:41</div></div>
<div class="ttc" id="astructby_1_1no_wrap_html"><div class="ttname"><a href="structby_1_1no_wrap.html">by::noWrap</a></div><div class="ttdoc">Rich logging support with polymorphic type conversion</div><div class="ttdef"><b>Definition</b> richLog.hpp:34</div></div>
</div><!-- fragment --><p>More concise real-world usage: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_struct" href="structby_1_1no_wrap.html">shell</a> : <span class="keyword">public</span> <a class="code hl_class" href="classby_1_1instance.html">instance</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">age</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">tstr&lt;shell&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">foo</a>() {</div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">tstr&lt;shell&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">ptr</a>(<span class="keyword">new</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">shell</a>()); <span class="comment">// Create and bind simultaneously</span></div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">ptr</a>-&gt;age = 57; <span class="comment">// Supports operator-&gt;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">tweak&lt;shell&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">weak</a> = <a class="code hl_struct" href="structby_1_1no_wrap.html">ptr</a>; <span class="comment">// Binders can be compatible</span></div>
<div class="line">    <a class="code hl_struct" href="structby_1_1no_wrap.html">callShell</a>(*<a class="code hl_struct" href="structby_1_1no_wrap.html">weak</a>); <span class="comment">// Supports operator* too</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">ptr</a>; <span class="comment">// Returns by value, count maintained</span></div>
<div class="line">                <span class="comment">// shell object created with new won&#39;t be destroyed</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="why_not_shared_ptr"></a>
Why not use shared_ptr?</h1>
<p>Several advantages over shared_ptr:</p>
<ol type="1">
<li>Reference counting block attached to instance itself<ul>
<li>shared_ptr creates a "Control block" on the heap for reference counting. This makes the following dangerous: <div class="fragment"><div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">Foo</a>* <a class="code hl_struct" href="structby_1_1no_wrap.html">raw</a> = <span class="keyword">new</span> <a class="code hl_struct" href="structby_1_1no_wrap.html">Foo</a>();</div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">shared_ptr&lt;Foo&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">foo1</a>(<a class="code hl_struct" href="structby_1_1no_wrap.html">raw</a>);</div>
<div class="line"><a class="code hl_struct" href="structby_1_1no_wrap.html">shared_ptr&lt;Foo&gt;</a> <a class="code hl_struct" href="structby_1_1no_wrap.html">foo2</a>(<a class="code hl_struct" href="structby_1_1no_wrap.html">raw</a>); <span class="comment">// Separate control blocks -&gt; double delete</span></div>
</div><!-- fragment --></li>
<li>memlite uses <a class="el" href="classby_1_1life.html">life</a> class for reference counting, assigned per instance by <a class="el" href="classby_1_1watcher.html">watcher</a>. No double deletion problem.</li>
</ul>
</li>
<li>Provides ADT (Abstract Data Type)<ul>
<li>tstr and tweak share same binder base, enabling generic logic: <div class="fragment"><div class="line"><span class="keywordtype">void</span> me::rel(<a class="code hl_class" href="classby_1_1binder.html">binder</a>&amp; me) { <span class="comment">// Works for both tstr and tweak</span></div>
<div class="line">    WHEN(!me.isBind()) .ret();</div>
<div class="line">    <a class="code hl_class" href="classby_1_1life.html">life</a>* l = me.<a class="code hl_function" href="#a7a74d172ef4ab08dd3a0b479485f87e9">_getBindTag</a>();</div>
<div class="line">    <span class="keywordflow">if</span>(l) l-&gt;_onStrong(-1);</div>
<div class="line">}</div>
<div class="ttc" id="aclassby_1_1binder_html"><div class="ttname"><a href="classby_1_1binder.html">by::binder</a></div><div class="ttdoc">Generalized binding class for managing instance lifecycles</div><div class="ttdef"><b>Definition</b> binder.hpp:108</div></div>
<div class="ttc" id="aclassby_1_1binder_html_a7a74d172ef4ab08dd3a0b479485f87e9"><div class="ttname"><a href="#a7a74d172ef4ab08dd3a0b479485f87e9">by::binder::_getBindTag</a></div><div class="ttdeci">life * _getBindTag() const</div><div class="ttdoc">Retrieves life object associated with bound instance</div></div>
<div class="ttc" id="aclassby_1_1life_html"><div class="ttname"><a href="classby_1_1life.html">by::life</a></div><div class="ttdoc">Binding tag for instance reference tracking and lifecycle management</div><div class="ttdef"><b>Definition</b> life.hpp:21</div></div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Dynamic type checking<ul>
<li>binder is ADT and not even a class template. <a class="el" href="#a876d0a090326604be8e4116408ea734f" title="Binds instance to this binder with reference counting">bind()</a> parameter is instance type. tstr allows bind(new B()); without compile error. <a class="el" href="#a876d0a090326604be8e4116408ea734f" title="Binds instance to this binder with reference counting">bind()</a> uses meta module for dynamic type checking, binding only when types match.</li>
</ul>
</li>
</ol>
<dl class="section remark"><dt>Remarks</dt><dd>Abstract nature binder is abstract, so cannot create objects. Only meaningful for generic logic using already created tstr or tweak binders.</dd></dl>
<h1><a class="anchor" id="custom_memory_pool"></a>
Custom memory pool</h1>
<p>Ultimate goal of memlite is lightweight C++ memory management for byeol runtime environment. Requires GC and additional memory management, implying custom memory pool and instance lifecycle management. All instance allocation starts with <a class="el" href="classby_1_1instancer.html">instancer</a>.</p>
<h1><a class="anchor" id="performance_improvements"></a>
Performance improvements</h1>
<p>shared_ptr's algorithm stores reference counting info on heap. Using faster custom memory pool instead of heap and optimizing binding speed provides performance gains. Binding is one of the hotspots consuming most performance in byeol.</p>
<h1><a class="anchor" id="additional_information"></a>
Additional information</h1>
<p>shared_ptr creates objects on heap for reference counting. memlite uses <a class="el" href="classby_1_1watcher.html">watcher</a> to lend empty <a class="el" href="classby_1_1life.html">life</a> objects from pre-allocated memory, using them as reference counting space for instances. If GC features are added later, instances may require additional lifecycle information. Unlike shared_ptr, managing each instance's lifecycle information internally allows appropriate handling of such requirements. </p>
</div><h2 class="groupheader">생성자 &amp; 소멸자 문서화</h2>
<a id="a49b4b4287d4d23a1b5f4475a81a5e31f" name="a49b4b4287d4d23a1b5f4475a81a5e31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b4b4287d4d23a1b5f4475a81a5e31f">&#9670;&#160;</a></span>binder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">by::binder::binder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classby_1_1bind_tacticable.html">bindTacticable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tactic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a binder with a specific type and binding tactic. </p>
<dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the instance this binder will manage. </td></tr>
    <tr><td class="paramname">tactic</td><td>The binding tactic (e.g., strong or weak) to use for reference counting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">멤버 함수 문서화</h2>
<a id="a67a771ff88056d4cb4bdfcca5db681e4" name="a67a771ff88056d4cb4bdfcca5db681e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a771ff88056d4cb4bdfcca5db681e4">&#9670;&#160;</a></span>_assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::binder::_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1binder.html">binder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns binder from another binder </p>
<dl class="section return"><dt>반환값</dt><dd>true on success, false on failure </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Handles reference counting via tactic when copying bindings </dd></dl>

</div>
</div>
<a id="a7a74d172ef4ab08dd3a0b479485f87e9" name="a7a74d172ef4ab08dd3a0b479485f87e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a74d172ef4ab08dd3a0b479485f87e9">&#9670;&#160;</a></span>_getBindTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classby_1_1life.html">life</a> * by::binder::_getBindTag </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves life object associated with bound instance </p>
<dl class="section return"><dt>반환값</dt><dd>Pointer to life object, or nullptr if not bound </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Internal accessor for reference counting operations </dd></dl>

</div>
</div>
<a id="afcad99d72defbd4df3e158119ba51c2d" name="afcad99d72defbd4df3e158119ba51c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcad99d72defbd4df3e158119ba51c2d">&#9670;&#160;</a></span>_onSame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::binder::_onSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type_providable.html">typeProvidable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classby_1_1type_providable.html" title="Interface for objects that can provide their type information">typeProvidable</a> objects are same instance </p>
<dl class="section return"><dt>반환값</dt><dd>true if same object, false otherwise </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Overrides <a class="el" href="classby_1_1type_providable.html" title="Interface for objects that can provide their type information">typeProvidable</a> for binder-specific equality </dd></dl>

</div>
</div>
<a id="a876d0a090326604be8e4116408ea734f" name="a876d0a090326604be8e4116408ea734f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876d0a090326604be8e4116408ea734f">&#9670;&#160;</a></span>bind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::binder::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds instance to this binder with reference counting </p>
<dl class="section return"><dt>반환값</dt><dd>true on success, false if type mismatch or binding fails </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Increases reference count. Type must match via <a class="el" href="#a62644cd115f0e1dc528fde6447e2f0a0" title="Checks if given type can be bound to this binder">canBind()</a> check. </dd></dl>

<p><a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>(으)로부터 재구현되었습니다.</p>

</div>
</div>
<a id="a69159b910a8dbc6b07409dfe68da90de" name="a69159b910a8dbc6b07409dfe68da90de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69159b910a8dbc6b07409dfe68da90de">&#9670;&#160;</a></span>bind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> <a class="el" href="classby_1_1tbindable.html">by::tbindable</a>&lt; T &gt;::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> T *</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to instance pointer </p>
<p>binder will loose previous binding instance whether given parameter <code>it</code> isn't nullptr or not. </p>

</div>
</div>
<a id="a62644cd115f0e1dc528fde6447e2f0a0" name="a62644cd115f0e1dc528fde6447e2f0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62644cd115f0e1dc528fde6447e2f0a0">&#9670;&#160;</a></span>canBind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::binder::canBind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if given type can be bound to this binder </p>
<dl class="section return"><dt>반환값</dt><dd>true if type matches or is subtype of binder's type, false otherwise </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Uses meta module for dynamic type checking </dd></dl>

<p><a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>를 구현.</p>

</div>
</div>
<a id="a42ed58531270d88871826faf1f3472ee" name="a42ed58531270d88871826faf1f3472ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ed58531270d88871826faf1f3472ee">&#9670;&#160;</a></span>canBind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">virtual</a> <a class="el" href="structby_1_1no_wrap.html">nbool</a> <a class="el" href="classby_1_1tbindable.html">by::tbindable</a>&lt; T &gt;::canBind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1type.html">type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>를 구현.</p>

</div>
</div>
<a id="ad05c9ba2164853c3e8db3af3cb5198c3" name="ad05c9ba2164853c3e8db3af3cb5198c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05c9ba2164853c3e8db3af3cb5198c3">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structby_1_1no_wrap.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">const</a> T * by::typeProvidable::cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe cast to target type using type hierarchy information </p>
<dl class="section return"><dt>반환값</dt><dd>Pointer to object if cast is valid, nullptr otherwise </dd></dl>
<dl class="section note"><dt>주의</dt><dd>Uses O(1) tier algorithm instead of slow dynamic_cast </dd></dl>

</div>
</div>
<a id="ab9e19ad120640f64ba322a497cae7a10" name="ab9e19ad120640f64ba322a497cae7a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e19ad120640f64ba322a497cae7a10">&#9670;&#160;</a></span>getItsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1id.html">id</a> by::binder::getItsId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the unique ID of the instance currently bound by this binder. </p>
<dl class="section return"><dt>반환값</dt><dd>The ID of the bound instance. Returns an invalid ID if no instance is bound. </dd></dl>

</div>
</div>
<a id="a9096a1115c2e48a07f7464f2a1c1bb1a" name="a9096a1115c2e48a07f7464f2a1c1bb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9096a1115c2e48a07f7464f2a1c1bb1a">&#9670;&#160;</a></span>isBind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">nbool</a> by::binder::isBind </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>를 구현.</p>

</div>
</div>
<a id="a50e8d38d79c0911aeb647047784660d2" name="a50e8d38d79c0911aeb647047784660d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e8d38d79c0911aeb647047784660d2">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structby_1_1no_wrap.html">const</a> <a class="el" href="classby_1_1instance.html">instance</a> &amp; by::binder::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns another binder's bound instance to this binder. </p>
<p>This operator handles the transfer of binding, ensuring proper reference counting adjustments for both the source and target binders. </p><dl class="params"><dt>매개변수</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The binder to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>반환값</dt><dd>A reference to this binder. </dd></dl>

</div>
</div>
<a id="a31ae31b7732a4dbcf9ed895308f56c8e" name="a31ae31b7732a4dbcf9ed895308f56c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ae31b7732a4dbcf9ed895308f56c8e">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classby_1_1instance.html">instance</a> * by::binder::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference operator to access bound instance </p>
<p>This follows the same policy as tmay and stl. that is, if the binder does not bind any instances and tries to dereference them with <code>get()</code> or <code><a class="el" href="#a50e8d38d79c0911aeb647047784660d2" title="Assigns another binder&#39;s bound instance to this binder.">operator*()</a></code>, it will behave as UB. this is likely to crash. </p>

</div>
</div>
<a id="a038ea5de5075f5815ca96352ec350422" name="a038ea5de5075f5815ca96352ec350422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038ea5de5075f5815ca96352ec350422">&#9670;&#160;</a></span>rel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void by::binder::rel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classby_1_1tbindable.html">by::tbindable&lt; instance &gt;</a>를 구현.</p>

</div>
</div>
<hr/>이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.:<ul>
<li>/home/runner/work/byeol/byeol/module/memlite/binder/<a class="el" href="binder_2binder_8hpp_source.html">binder.hpp</a></li>
<li>/home/runner/work/byeol/byeol/module/memlite/binder/<b>binder.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
