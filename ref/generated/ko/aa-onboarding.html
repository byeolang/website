<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: 여행 코스 가이드</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('aa-onboarding.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">여행 코스 가이드</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2byeol_2byeol_2doc_2ref_2ko_2aa-onboarding"></a> Byeol 프로젝트에 기여하고 싶은 개발자를 위한 가이드입니다.</p>
<p>코드는 C++로 작성되어 있고 다양한 매크로와 독특한 코딩 스타일과 컨벤션 규칙을 가지고 있고, 저 개인적으론 간결한 코드를 항상 지향하기 때문에 라인수는 작지만 독해가 쉬운 편은 아닐꺼예요.</p>
<p>메타프로그래밍이나, 디자인 패턴들(빌더, 전략, 아답터, 방문자 등)나 idium(method chaining, RAII) 여럿 쓰이고 있고, 매크로 오버로딩이나, 메모리풀 등도 가지고 있어서, 해당 개발 경험이 없으시다면 좀 곤란할 수 있습니다. 그리고 bison, flex에 대해서는 따로 설명하지 않고 있으니, 문법을 수정할 거라면 먼저 읽고 오시는 게 좋겠네요.</p>
<p>그래서, 이제부터 많은 문서를 쭉 읽어나가게 되실텐데요. 시작하기에 앞서서, 대량의 문서를 모두 읽기 전에, 원하는 코드를 수정하기 위한 학습 코스를 소개해보려구요. 일단, 가이드 문서는 필수 과정과 시나리오별 과정으로 나눠볼 수 있겠네요.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md1"></a>
필수 과정</h1>
<p>공통 과정에는 코드를 독해하기 위한 사전 지식이나 규칙들을 설명합니다. 다음과 같은 순서로 읽어주세요.</p>
<ul>
<li>ab-dev-env : buiilder를 통한 개발 환경 세팅 방법을 알려줍니다. (10분)</li>
<li><a class="el" href="ac-build-structure.html">프로젝트 구조 및 빌드 산출물</a> : 이 프로젝트의 각 폴더에 어떤 파일들이 들어있는지 소개합니다. (10분)</li>
<li><a class="el" href="ad-convention-rules.html">Byeol 코딩 규칙</a> : c++ 코드의 컨벤션 규칙을 알려줍니다. (20분)<br  />
 byeol 코드는 일반적인 c++ 코드와 코딩 스타일이 많이 다릅니다. 꼭 읽어보시기 바랍니다.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md3"></a>
시나리오별 네비게이션</h1>
<p><a class="el" href="ae-architecture-overview.html">아키텍쳐와 설계</a> 에서 자세히 다루겠지만, Byeol 프로젝트는 layered architecture로 설계되었습니다. 간단히 목록을 소개하면 다음과 같아요. Stack diagram 처럼, 밑으로 갈수록 더 독립적인 모듈입니다.</p>
<ul>
<li><a class="el" href="al-architecture-frontend.html">frontend 모듈 - CLI 인터페이스</a></li>
<li><a class="el" href="ak-architecture-core.html">core 모듈 - 언어 구현의 핵심</a></li>
<li><a class="el" href="aj-architecture-stela.html">stela 모듈 - 경량 설정 언어</a></li>
<li><a class="el" href="ai-architecture-memlite.html">memlite 모듈 - 커스텀 메모리 관리</a></li>
<li><a class="el" href="ah-architecture-meta.html">meta 모듈 - 런타임 타입 시스템</a></li>
<li><a class="el" href="ag-architecture-clog.html">clog 모듈 - 로깅 시스템</a></li>
<li><a class="el" href="af-architecture-indep.html">indep 모듈 - 플랫폼 추상화 계층</a></li>
</ul>
<p>언어의 핵심 기능은 core module이 담당하고 있어요. 그리고 보시다시피 꽤 상위(많은 모듈에 종속하는) 모듈이므로, 핵심 기능을 수정하려고 한다면 core가 종속하고 있는, 그 밑의 많은 모듈을 필수적으로 학습해야만 합니다. 이건 어쩔 수가 없어요.<br  />
 그래서 시간이 충분하시다면, 물론 indep 모듈부터 모든 문서를 천천히 정독하시는 걸 강력하게 추천합니다.</p>
<p>하지만 목적이 분명하고, 시간이 제한되어 있다면, 조금이나마 빠르게 작업할 수 있도록, 시나리오에 맞게 읽고 참조해야할 부분을 소개해드릴꼐요.</p>
<p>참, 각 시나리오별로 어느 모듈의 코드를 수정해야 하는지 적어드릴텐데, 해당 모듈이 종속하는 모듈들은 추가적인 언급이 없어도 필수적으로 읽으셔야 합니다.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md5"></a>
시나리오: 새로운 내장 함수(Native Function) 및 타입을 추가하고 싶어요</h2>
<ul>
<li>core 모듈을 읽기 위해서 core 모듈이 종속하는 모듈을 순서대로 읽으세요: <br  />
 <a class="el" href="af-architecture-indep.html">indep 모듈 - 플랫폼 추상화 계층</a> -&gt; <a class="el" href="ag-architecture-clog.html">clog 모듈 - 로깅 시스템</a> -&gt; <a class="el" href="ah-architecture-meta.html">meta 모듈 - 런타임 타입 시스템</a> -&gt; <a class="el" href="ai-architecture-memlite.html">memlite 모듈 - 커스텀 메모리 관리</a> -&gt; <a class="el" href="aj-architecture-stela.html">stela 모듈 - 경량 설정 언어</a></li>
<li><b>핵심 가이드</b>: ai-architecture-core 문서의 "Native-Script 브리징" 섹션<b>까지를</b> 자세히 읽어보세요. <code>tbridger</code> 클래스가 핵심입니다.</li>
<li>그리고 <code>tbridger</code>를 사용해서 core 모듈의 <code>module/core/builtin</code> 폴더를 수정해야 합니다.</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
튜토리얼</h3>
<p>실제로 함수를 하나 추가해볼까요?</p>
<p><b>요구사항</b><br  />
 Byeol 언어의 <code>str</code> 타입에 <code>foo(msg str)</code> 라는 함수를 추가해봅시다.<br  />
 이 foo()는 c++로 작성할 것이며, 화면에 std::cout 을 사용해서 주어진 인자인 <code>msg</code>값으로 <code>foo says: $msg!\n</code>를 출력하고 3을 반환해야 한다고 해보죠.</p>
<p><b>계획</b><br  />
 <code>str</code>은 c++ 상으로는 <code>core/builtin/scalar/nStr</code> 이 표현합니다. 이 파일을 수정해야 겠죠.<br  />
 여기서, 주의할 점은 우리가 추가할 foo()는 str 타입에 추가한 것이므로 C++ Runtime에서도 nStr객체로 foo() 함수를 호출할 수 있어야 한다는 겁니다.<br  />
 그렇다면 nStr::foo()를 추가하고, 이를 byeol runtime에 노출시켜야 합니다.<br  />
 nStr은 baseObj이므로, <a class="el" href="classby_1_1tbridger.html">tbridger</a>를 사용해서 Byeol Runtime에 공개해야 겠죠.</p>
<p><b>코딩</b><br  />
 그럼 본격적으로 c++ 코드로 foo()함수를 만들어봅시다. 먼저 <code><a class="el" href="n_str_8hpp.html">nStr.hpp</a></code> 헤더부터. </p><div class="fragment"><div class="line">class _nout nStr: public tscalar&lt;std::string&gt;, public tucontainable&lt;nStr&gt; {</div>
<div class="line">    struct _nout nStrType: public ntype {</div>
<div class="line">    public:</div>
<div class="line">        int foo(const std::string&amp; msg); // &lt;-- 추가</div>
<div class="line">        // 이때 tmarshaling에 따라서 인자와 반환형을 결정합니다.</div>
</div><!-- fragment --><p>함수 body를 채웁시다. </p><div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// .....</span></div>
<div class="line">    <span class="keywordtype">int</span> me::foo(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;foo says: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 3;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>좋습니다. 이제 nStr객체를 들고있다면 c++ runtime에서는 <code>foo("wow")</code>와 같이 호출할 수 있습니다.<br  />
 이제 작성한 foo()를 tbridger를 사용해서 Byeol Runtime으로 연결할 겁니다.<br  />
 nStr은 baseObj이므로 이 경우 origin 객체에 의해서 함수가 노출되며, 이 origin 객체는 객체에 속하지 않고 static으로 정의되어 하나를 공유하게 됩니다.<br  />
 그래서 nStr::getOrigin() 함수를 먼저 찾아보면, 어디서 origin 객체를 가져오는 지 알 수 있죠. </p><div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">    <span class="keyword">const</span> baseObj&amp; me::getOrigin()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keyword">const</span> baseObj&amp; supers = super::getOrigin();</div>
<div class="line">        <span class="keywordflow">return</span> &amp;supers == <span class="keyword">this</span> ? _defaultOrg() : supers; <span class="comment">// _defaultOrg()에서 가져오는 군요?</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> baseObj&amp; _defaultOrg() {</div>
<div class="line">        <span class="keyword">static</span> tbaseObjOrigin&lt;me&gt; org(tbridger&lt;me&gt;::ctor() <span class="comment">// 역시 tbridger를 사용합니다.</span></div>
<div class="line">          .ctor&lt;nStr&gt;()</div>
<div class="line">          .func(<span class="stringliteral">&quot;len&quot;</span>, &amp;me::len)</div>
<div class="line">          .func&lt;nchar, nidx&gt;(func::GETTER_NAME, &amp;me::get)</div>
<div class="line">          .func(<span class="stringliteral">&quot;substr&quot;</span>, &amp;me::substr)</div>
<div class="line">          .func(func::GETTER_NAME, <span class="keyword">new</span> getSeqFunc())</div>
<div class="line">          .func(<span class="stringliteral">&quot;iterate&quot;</span>, <span class="keyword">new</span> iterateFunc())</div>
<div class="line">          <span class="comment">// 즉, 대충 여기 어딘가에 우리의 foo() 함수를 정의해야 합니다.</span></div>
<div class="line">          <span class="comment">// 물론 순서는 상관없습니다. 맨 윗줄에 넣어도, 맨 아랫줄에 넣어도.</span></div>
<div class="line">          .func(<span class="stringliteral">&quot;foo&quot;</span>, &amp;me::foo) <span class="comment">// &lt;-- 이 1줄이면 노출이 끝납니다.</span></div>
<div class="line"> </div>
<div class="line">          .func(<span class="stringliteral">&quot;getElemType&quot;</span>, <span class="keyword">new</span> getElemType())</div>
<div class="line">          .subs());</div>
<div class="line">        <span class="keywordflow">return</span> org;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>이제 빌드를 해봐서 테스트 해봅시다.</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">$ ./build/builder.py dbg</div>
</div><!-- fragment --><p>성공했다면, TC를 넣어서 확인 해봅시다.<br  />
 c++ 런타임뿐만 아니라 byeol runtime에서도 확인이 필요하므로 integTest에 넣으면 좋아보입니다.<br  />
 test/integTest/core/usual 에 primitive타입을 테스트하는 primitiveTypeIntegTest에 TC를 추가해봅시다. </p><div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line"> </div>
<div class="line">TEST_F(primitiveTypeIntegTest, testFooFunc) {</div>
<div class="line">    make()</div>
<div class="line">        .parse(R<span class="stringliteral">&quot;SRC(</span></div>
<div class="line"><span class="stringliteral">        main() int</span></div>
<div class="line"><span class="stringliteral">            value := &quot;someString&quot;</span></div>
<div class="line"><span class="stringliteral">            ret value.foo(&#39;hello&#39;)</span></div>
<div class="line"><span class="stringliteral">    )SRC&quot;)</span></div>
<div class="line"><span class="stringliteral">        .shouldVerified(</span><span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    str res = run();</div>
<div class="line">    ASSERT_TRUE(res); <span class="comment">// foo(str)의 결과가 여기에 담겨야 겠죠.</span></div>
<div class="line">    ASSERT_EQ(*res.cast&lt;nint&gt;(), 3); <span class="comment">// 3이 나와야 합니다.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>빌드후 TC를 돌려봐야 겠죠? </p><div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">$ ./build/builder.py dbg</div>
<div class="line"># 빌드 완료후</div>
<div class="line">$ cd /bin # TC 돌릴때는 pod 경로 문제가 있어서 bin 폴더에서 하는게 좋습니다.</div>
<div class="line">$ ./test --gtest_filter=&quot;primitiveTypeIntegTest.testFooFunc&quot;</div>
<div class="line"> </div>
<div class="line"># 잘되면 모든 TC도 한번 돌려보죠.</div>
<div class="line">$ ./test</div>
<div class="line"> </div>
<div class="line"># 에러가 발생하면 verbose로 로그를 상세히 봐도 좋습니다.</div>
<div class="line">$ ./test --gtest_filter=&quot;primitiveTypeIntegTest.testFooFunc&quot; verbose</div>
</div><!-- fragment --><p>자, 커밋할 준비가 된 것 같네요. 그러면 마지막으로 코드 포맷터를 돌려줍니다. </p><div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">$ ./build/builder.py format</div>
</div><!-- fragment --><p>그럼, 이제 commit을 만들고 PR을 올리면 됩니다.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md8"></a>
새로운 문법(Syntax)을 추가하고 싶어요</h2>
<ul>
<li>core 모듈의 <code>parser</code> 클래스를 확인하세요. 그리고 해당 문법을 표현하기 위한 새로운 <code>expr</code> 클래스를 만드세요.</li>
<li>마지막으로 신규 <code>expr</code>을 검증하기 위한 로직을 <code>verifier</code>에 추가해야 합니다.</li>
<li><b>핵심 가이드</b>: ai-architecture-core 문서의 "파싱"과 "표현식 시스템" 섹션이 도움이 될 것입니다.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md10"></a>
버그를 잡기 위해 로그를 추가하거나, 새로운 로그 기능을 넣고 싶어요.</h2>
<ul>
<li>로그 추가라면 <code>BY_I</code> 와 같은 매크로에 대한 사용법까지만 보셔도 됩니다.</li>
<li>새로운 기능이라면 clog 모듈 문서를 참고하세요.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md12"></a>
리플렉션 기능을 더 추가하고 싶어요.</h2>
<ul>
<li>byeol runtime 환경에서의 타입 정보는 기본적으로 meta모듈에 의해서 제공됩니다.</li>
<li>그리고 core는 기본으로 제공되는 meta 모듈의 <code>type</code>을 확장해서 <code>ntype</code>이라고 하는 클래스를 사용합니다.</li>
<li>마지막으로 이 ntype을 byeol runtime 환경으로 노출하기 위해 core 모듈의 <code>tbridger</code> 를 사용하면 됩니다.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md14"></a>
본격적으로 시작해보죠.</h1>
<p>문서는 읽는 순서를 고려해서 위에서부터 아래로 구성되어 있습니다. 전체 문서를 다 순서대로 읽으시려면 맨 아래의 <code>다음 문서</code>를 계속 읽어나가시면 됩니다.</p>
<p>좀 자랑을 해보자면 다이어그램도 열심히 그려넣고 주석도 많이 채우고 공을 들였고, 분량이 너무 길어지지 않도록 간결하게 쓰려고도 노력을 기울였어요.</p>
<p>입맛에 잘 맞길 바라며, 개발 환경부터 구축하러 떠나보죠.</p>
<hr  />
<p> <b>다음 문서</b>: ab-dev-env </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
