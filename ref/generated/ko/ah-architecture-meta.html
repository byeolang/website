<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: meta 모듈 - 런타임 타입 시스템</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('ah-architecture-meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">meta 모듈 - 런타임 타입 시스템</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2byeol_2byeol_2doc_2ref_2ko_2ah-architecture-meta"></a> <a class="el" href="group__meta.html">Meta</a> 모듈은 런타임 타입 정보(RTTI)와 리플렉션 기능을 제공합니다. C++의 기본 RTTI보다 더 강력하고 효율적인 타입 시스템을 구현하고 있으며, Byeol 언어의 타입 시스템 기반이 됩니다. Monostate 패턴, Template Metaprogramming, 재귀적 초기화 등을 활용하여 설계되었습니다. 다음과 같은 기능을 제공합니다:</p>
<ol type="1">
<li>타입 계층 구조 탐색 (상속 관계 확인)</li>
<li>타입 정보 조회 (이름, 추상 클래스 여부, 템플릿 여부 등)</li>
<li>동적 인스턴스 생성</li>
<li>효율적인 타입 캐스팅 (dynamic_cast보다 빠름)</li>
</ol>
<p><b>meta 모듈의 주요 클래스:</b></p>
<div class="plantumlgraph">
<img src="inline_umlgraph_7.png" />
</div>
<hr  />
<h1><a class="anchor" id="autotoc_md191"></a>
type 클래스</h1>
<p><a class="el" href="classby_1_1type.html">type</a> 클래스는 <a class="el" href="group__meta.html">Meta</a> 모듈의 핵심이 되는 클래스예요. <a class="el" href="classby_1_1type.html">type</a> 에 대한 다음의 기본적인 API를 제공합니다.</p>
<h2><a class="anchor" id="autotoc_md192"></a>
기본 타입 식별</h2>
<p>다음 함수들로 타입의 기본 정보를 얻을 수 있습니다:</p>
<ul>
<li><code>isTemplate()</code>: 템플릿 클래스 여부를 반환합니다.</li>
<li><code>isAbstract()</code>: 추상 클래스 여부를 반환합니다.</li>
<li><code>getName()</code>: 클래스명을 반환합니다. 이름은 demangle 되어 반환됩니다.</li>
</ul>
<h2><a class="anchor" id="autotoc_md193"></a>
클래스 계층 관련 정보</h2>
<p><b>getSupers()</b></p>
<p>super class들을 리스트에 담아 반환합니다. 이 클래스의 직접적인 부모 클래스는 리스트 마지막 원소에, 보다 더 super class일 수록 리스트 앞에 담겨있습니다.</p>
<p>예를들어 다음과 같은 코드를 보세요.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const auto&amp; supers = getType().getSupers();</div>
<div class="line"> </div>
<div class="line">// 가장 첫번째 클래스는 항상 adam 이 된다. adam 클래스 참조.</div>
<div class="line">supers[0].getName() // &quot;adam&quot;</div>
<div class="line"> </div>
<div class="line">supers.last()-&gt;getName() // this 클래스의 부모클래스 이름이 나온다.</div>
</div><!-- fragment --><p><b>getSubs()</b></p>
<p>sub class들을 리스트에 담아 반환합니다. getSupers()와 마찬가지 방식으로, 가까운 sub 일 수록 리스트 앞에 담겨있습니다.</p>
<p><b>isSuper(const rhs&amp; type)</b></p>
<p>this class가 rhs보다 super 클래스 인지 체크합니다. dynamic_cast과 동일한 기능이지만 알고리즘 복잡도가 더 뛰어납니다.</p>
<p>일반적으로 dynamic_cast는 vtable을 순회해서 체크합니다. 반면 meta는 메타 정보 생성시 super 클래스 계층도를 통해서 자신이 몇 tier의 자손인지를 미리 계산해둡니다. 이 tier 인덱스를 사용한 배열 접근과 타입 포인터의 주소값 비교를 통해 O(1) 시간에 타입 계층 확인이 가능합니다. 이는 vtable 순회 방식에 비해 캐시 친화적이고 예측 가능한 성능을 제공합니다.</p>
<p><b>isSub(const rhs&amp; type)</b></p>
<p>isSuper와 반대로 동작합니다.</p>
<p><b>타입 계층 검사 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">class Animal {};</div>
<div class="line"> </div>
<div class="line">class Dog : public Animal {</div>
<div class="line">    typedef Animal super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Puppy : public Dog {</div>
<div class="line">    typedef Dog super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 상속 관계 확인</div>
<div class="line">const type&amp; animalType = ttype&lt;Animal&gt;();</div>
<div class="line">const type&amp; dogType = ttype&lt;Dog&gt;();</div>
<div class="line">const type&amp; puppyType = ttype&lt;Puppy&gt;();</div>
<div class="line"> </div>
<div class="line">// Animal이 Dog의 부모인가?</div>
<div class="line">bool isParent = animalType.isSuper(dogType);  // true</div>
<div class="line"> </div>
<div class="line">// Dog가 Animal의 자식인가?</div>
<div class="line">bool isChild = dogType.isSub(animalType);  // true</div>
<div class="line"> </div>
<div class="line">// Puppy는 Animal의 자식인가? (간접 상속도 체크)</div>
<div class="line">bool isDescendant = puppyType.isSub(animalType);  // true</div>
<div class="line"> </div>
<div class="line">// 형제 관계는 false</div>
<div class="line">class Cat : public Animal {</div>
<div class="line">    typedef Animal super;</div>
<div class="line">};</div>
<div class="line">bool areSiblings = ttype&lt;Dog&gt;().isSub(ttype&lt;Cat&gt;());  // false</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md194"></a>
인스턴스 생성</h2>
<p><b>make()</b></p>
<p>이 type의 기본생성자로 인스턴스를 생성합니다. 만약, 기본생성자가 없다면 nullptr가 반환되니 주의하세요.</p>
<h2><a class="anchor" id="autotoc_md195"></a>
메타 타입 정보 관리</h2>
<p><code>init()</code>으로 초기화를, <code>rel()</code>로 해제를 합니다. 이는 <code>BY_INIT_META</code> 매크로를 통해서 자동으로 처리가 되는 부분이라 외부에서 직접 호출할 경우는 드뭅니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md197"></a>
ttype&lt;T&gt; 클래스</h1>
<p><a class="el" href="classby_1_1ttype.html">ttype</a> 클래스는 사용자가 메타 정보를 다루고자할때 진입점이 되는 클래스예요. <a class="el" href="classby_1_1ttype.html">ttype</a> 를 사용할때는 매번 객체를 생성해서 사용해야 합니다. 전체적으로 monostate 패턴으로 설계 되어있어서 매번 객체를 만들어 사용하더라도 값은 공유하기 때문에 추가비용은 들지 않습니다.</p>
<p><a class="el" href="group__meta.html">Meta</a> 모듈의 전체적인 설계에 대해 파악하고자 한다면 핵심이 되는 <a class="el" href="classby_1_1type.html">type</a> 을 먼저 살펴보세요.</p>
<p><b>ttype 기본 사용 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">class myClass {};</div>
<div class="line"> </div>
<div class="line">class myDerivedClass : public myClass {</div>
<div class="line">    typedef myClass super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 타입 정보 조회</div>
<div class="line">const type&amp; typeInfo = ttype&lt;myClass&gt;();</div>
<div class="line">std::cout &lt;&lt; typeInfo.getName();  // &quot;myClass&quot; 출력</div>
<div class="line"> </div>
<div class="line">// 템플릿 여부 확인</div>
<div class="line">bool isTemplate = typeInfo.isTemplate();  // false</div>
<div class="line">isTemplate == ttype&lt;myClass&gt;().isTemplate(); // same</div>
<div class="line"> </div>
<div class="line">// 추상 클래스 여부 확인</div>
<div class="line">bool isAbstract = typeInfo.isAbstract();  // false</div>
<div class="line"> </div>
<div class="line">// 부모 타입 확인</div>
<div class="line">const type&amp; superType = ttype&lt;myDerivedClass&gt;().getSuper();</div>
<div class="line">std::cout &lt;&lt; superType.getName();  // &quot;myClass&quot; 출력</div>
<div class="line"> </div>
<div class="line">// 인스턴스 생성 (단, myClass에 기본 생성자 필요)</div>
<div class="line">myClass* instance = typeInfo.makeAs&lt;myClass&gt;();</div>
<div class="line">delete instance;</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md199"></a>
메타 정보의 생성과 관리</h1>
<h2><a class="anchor" id="autotoc_md200"></a>
메타 정보가 어떻게 생성되나</h2>
<p><code>isTemplate()</code> 이나 <code>isAbstract()</code>, <code>getName()</code> 같은 타입정보는 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 에서 Template Metaprogramming을 통해 컴파일 타임에 채워줍니다. 반면, 클래스 상속과 같은 계층 정보는 불가능해요. 따라서 계층 정보를 채워주는 과정은 프로세스 시작후 최초 1번은 실행이 되어야 되어야 합니다. <a class="el" href="classby_1_1type.html">type</a>에 <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init()</a>이 존재하는 이유는 런타임에 클래스 계층 정보를 구성하기 위해서입니다.</p>
<p>그리고 그 계층을 만드는 핵심 조건은 <b>각 사용자는 자신의 클래스를 정의할때 typedef로 super를 정의해야 한다</b>라는 제약사항으로 해결합니다. 모든 클래스에 <code>super</code>가 존재한다면, <a class="el" href="classby_1_1type.html#a656d9a54739f8457195da12567e4410a">init()</a>함수 안에서 <code>super::init()</code>도 호출할 수 있기 때문에 간단한 재귀함수만으로도 클래스 계층을 구성할 수 있게 됩니다.</p>
<p><b>참고</b>: 부모 클래스가 없는 최상위 클래스는 <code>typedef adam super;</code>로 정의하여 <a class="el" href="classby_1_1adam.html">adam</a> 에 연결됩니다. 이를 통해 모든 타입이 단일 부모로부터의 계층 구조를 이루게 됩니다. <code>init()</code>의 예시 코드를 한번 볼까요?</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// 주의: 다음은 실제 코드 동작을 이해하기 쉽게 간략화 한 겁니다.</div>
<div class="line">nbool me::init() {</div>
<div class="line">    if(_isInit) return false;</div>
<div class="line">    _isInit = true;</div>
<div class="line"> </div>
<div class="line">    // 위 코드로 인해, 여기는 딱 1번만 실행된다.</div>
<div class="line">    type&amp; super = (type&amp;) getSuper(); // getSuper()는 ttype&lt;typename T::super&gt;::get() 를 반환한다.</div>
<div class="line">    super.init(); // 재귀적으로 부모의 타입을 계속 호출하는 과정이 반복된다.</div>
<div class="line">                  // 최종적으로는 adam 클래스까지 올라가게 되며, adam 은 부모가 없기 때문에 취소된다.</div>
<div class="line"> </div>
<div class="line">    // 클래스 계층 정보를 생성한다.</div>
<div class="line">    types&amp; mySupers = getSupers();</div>
<div class="line">    mySupers = super.getSupers(); // 얇은 복사</div>
<div class="line">    mySupers.push_back(&amp;super);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>실제 핵심 코드는 위와 크게 다르지 않습니다. 실제로 몇 줄의 간단한 코드만으로도 클래스 계층을 구성합니다. 이 과정은 재귀를 사용하긴 하지만, 프로그램 실행 후 1번만 발생하기 때문에 비용도 비교적 적습니다.</p>
<h2><a class="anchor" id="autotoc_md201"></a>
메타 정보 자동 생성</h2>
<p>앞서 얘기한 대로 각 type 클래스들의 정보는 <code>init()</code> 함수를 호출하면 생성되고 채워집니다. 문제는 각 클래스들에 대한 타입 객체를 일일이 사용자가 생성하고 각각을 명시적으로 <code>init()</code>을 호출하는 것은 굉장히 비효율적이라는 점입니다.</p>
<p>이걸 해결하고자 BY_INIT_META 매크로를 사용합니다. BY_INIT_META 는 BY_INITIATOR 매크로를 응용하는데, 이 매크로는 static 객체에 람다함수를 끼워넣음으로써 원하는 동작을 main() 함수가 시작되기 전에 실행하는 매크로입니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">    struct _nout Initiator {</div>
<div class="line">        template &lt;typename T&gt; Initiator(T func) { func(); }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">#define BY_INITIATOR(name, body) \</div>
<div class="line">    static inline Initiator* BY_CONCAT(__initi__##name##_, __COUNTER__) = new Initiator([]() body);</div>
<div class="line"> </div>
<div class="line">// 위와 같은 코드가 있을때,</div>
<div class="line">BY_INITIATOR(hello, {</div>
<div class="line">    cout &lt;&lt; &quot;hello world!\n&quot;;</div>
<div class="line">})</div>
<div class="line">// 처럼 하면 main() 함수가 시작되기 전에 화면에 `hello world!` 가 출력되게 됩니다.</div>
</div><!-- fragment --><p>이 매크로를 응용하면 init() 함수를 main() 함수가 호출되기 직전에 실행하는 게 가능해집니다. 한가지 제약사항으로는 각 클래스 선언시에 BY_INIT_META (MyClass)를 추가해야 한다는 점입니다.</p>
<p><b>주의</b>: static 초기화 순서를 사용하므로, 여러 translation unit 간의 초기화 순서는 보장되지 않습니다. 다만, 각 type의 <code>init()</code>은 재귀적으로 부모를 먼저 초기화 하며, 한번 초기화 되면 두번째부터는 skip 되는 구조이므로, 싱글 스레드 환경이라면 타입 계층 구조 내에서는 부모에서 자식으로 가는 초기화 순서가 보장됩니다.</p>
<p>이러한 메타 DSL 형태의 매크로들은 BY 매크로에 의해서 실행되도록 컨벤션으로 정의 되어있습니다. 그리고 나중에 <a class="el" href="group__core.html">Core</a> 모듈에서 후술하겠지만, 이것 말고도 추가로 DSL 매크로를 정의해야 하기 때문에, 매번 <code>BY_</code> prefix를 붙이는 불편함과, 매크로 이름이 충돌될 가능성을 줄이기 위해 <code>BY</code> 라는 DSL 확장 매크로를 사용합니다.</p>
<p><code>BY</code> 매크로는 BY() 안에 <code>BY_</code> prefix를 생략한 DSL 매크로를 <code>,</code> 을 붙여서 여러개 정의할 수 있습니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">class A {</div>
<div class="line">    // core 모듈쯤 가게 되면 이렇게 DSL 매크로가 많아진다.</div>
<div class="line">    BY_INIT_META(....)</div>
<div class="line">    BY_CLONE(..)</div>
<div class="line">    BY_VISIT()</div>
<div class="line">    BY_ME(...)</div>
<div class="line"> </div>
<div class="line">    // 그걸 이렇게 간략하게 줄일 수 있다.</div>
<div class="line">    BY(INIT_META(...), CLONE(..), VISIT(), ME(....))</div>
<div class="line">};</div>
</div><!-- fragment --><p>물론 이 역시 매번 4개나 되는 DSL 매크로를 클래스 정의시마다 추가하는건 매우 귀찮기 때문에 때문에, 대부분의 경우는 자주 사용하는 매크로들을 조합한 <code>BY(CLASS())</code> 나 <code>BY(ADT())</code>를 통해서 한번에 정의합니다.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md203"></a>
adam - 최상위 타입</h1>
<p><a class="el" href="classby_1_1type.html">type</a> 의 클래스 계층구조 상 아무런 부모도 없는 메타타입은 범용적으로 다루기가 어렵습니다. 예를들어 모든 메타타입에 대해서 동작하는 함수를 작성하고자 한다면, 다음과 같은 코드를 작성할 수 있어야 합니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const auto&amp; types = how_to_get_all_meta_types() // ?</div>
<div class="line">for(const auto&amp; t : types)</div>
<div class="line">    cout &lt;&lt; t.getName() &lt;&lt; &quot;\n&quot;;</div>
<div class="line"> </div>
<div class="line">vector&lt;type&gt; how_to_get_all_meta_types() {</div>
<div class="line">    // 모든 타입들을 순회해서 가져올 방법이 없다.</div>
<div class="line">    // 그러니 다음과 같이 해야한다?</div>
<div class="line">    vector&lt;type&gt; ret;</div>
<div class="line">    ret.push_back(ttype&lt;A&gt;());</div>
<div class="line">    ret.push_back(ttype&lt;B&gt;());</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    return ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>이를 해결하고자 메타 정보를 구성할때 어떠한 부모클래스도 없는 클래스라면 부모를 <a class="el" href="classby_1_1adam.html">adam</a> 으로 정의합니다. 이제 다음과 같이 작성할 수 있게 됩니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">for(const auto&amp; t : ttype&lt;adam&gt;().getSubs())</div>
<div class="line">    cout &lt;&lt; t.getName() &lt;&lt; &quot;\n&quot;;</div>
</div><!-- fragment --><p><b>adam을 활용한 타입 순회 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// 부모가 없는 여러 클래스들 정의</div>
<div class="line">class Shape {</div>
<div class="line">    // 부모가 없으므로 자동으로 adam이 부모가 됨</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Vehicle {</div>
<div class="line">    typedef adam super; // 굳이 원한다면 이렇게 해도 되긴 함.</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Rectangle : Shape {</div>
<div class="line">    BY(ME(Rectangle, Shape)) // typedef Rectangle this; typedef Shape super;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 모든 최상위 타입들을 순회</div>
<div class="line">const types&amp; allTopLevelTypes = ttype&lt;adam&gt;().getSubs();</div>
<div class="line"> </div>
<div class="line">for(const type* t : allTopLevelTypes) {</div>
<div class="line">    std::cout &lt;&lt; &quot;Top-level type: &quot; &lt;&lt; t-&gt;getName() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">// 출력: Shape, Vehicle 모든 최상위 클래스들</div>
<div class="line"> </div>
<div class="line">// adam을 통해 특정 타입이 최상위 타입인지 확인</div>
<div class="line">const type&amp; shapeType = ttype&lt;Rectangle&gt;();</div>
<div class="line">bool isTopLevel = (shapeType.getSuper() == ttype&lt;adam&gt;());  // false</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md205"></a>
메타 타입 확장하기</h1>
<p><a class="el" href="classby_1_1type.html">type</a> 은 기본적으로도 비교적 많은 타입 정보를 제공하지만, byeol 처럼 언어를 다루는 경우에는 parameter나 return type과 같이 추가적인 정보를 담고 싶은 경우가 있습니다.</p>
<p>이때 쉽게 생각하면 <a class="el" href="classby_1_1type.html">type</a> 을 상속받은 클래스를 만들면 되는거 아닌가라는 아이디어를 떠올리기 쉽지만 기억을 잘 떠올려보세요. 사용성을 위해서 우리는 <code>ttype&lt;T&gt;</code>에서 언급한 것처럼, 항상 사용자의 최종 진입점은 <code>ttype&lt;T&gt;</code>에 접근하면서 시작되어야 합니다. 문제는 <a class="el" href="classby_1_1ttype.html">ttype</a> 의 코드를 <a class="el" href="group__meta.html">Meta</a> 모듈에 있고, 추가타입 정보를 넣길 원하는 쪽은 meta에 종속되는 더 상위 모듈이라는 점이죠. 이때는 종속하는 쪽에서 수정할 수는 없기 때문에 상속으로는 불가능하고 메타 타입을 주입하는 형태로 문제를 해결합니다. 이는 Template Metaprogramming과 SFINAE(Substitution Failure Is Not An Error) 기법을 사용한 Type Injection 이라고 부르는 패턴을 사용합니다.</p>
<p>핵심 코드는 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 에 있습니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">template &lt;typename T, typename S = typename tmetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line">class ttypeBase: public S {</div>
<div class="line">    ....</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, nbool hasMeta = tifHasMetaTypeDef&lt;T&gt;::is&gt;</div>
<div class="line">struct tmetaTypeDef {</div>
<div class="line">    using is = type;</div>
<div class="line">};</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">struct tmetaTypeDef&lt;T, true&gt; {</div>
<div class="line">    using is = typename T::metaType;</div>
<div class="line">};</div>
</div><!-- fragment --><p>tmetaTypeDef는 template specialization을 사용하여, T에 typedef metaType이 있을 경우에는 해당타입을 반환하고, 없으면 <a class="el" href="classby_1_1type.html">type</a> 을 반환합니다. <a class="el" href="classby_1_1ttype.html">ttype</a> 은 <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 를 상속하며, <a class="el" href="classby_1_1ttype_base.html">ttypeBase</a> 는 바로 tmetaTypeDef&lt;T&gt;::is를 상속합니다.</p>
<p>이걸 통해서 만약 class T에 대해 ttype&lt;T&gt;를 호출하는 순간, class T의 개발자가 <code>typedef metaType MyType;</code> 처럼 새로운 MyType 클래스를 선언하여 추가하면 해당 ttype&lt;T&gt;()로 객체를 만들었을때 MyType을 기반으로 해서 만들어지게 됩니다. 이 메커니즘은 Policy-based Design의 한 형태로, 타입별로 다른 메타 타입 구현을 주입할 수 있게 합니다.</p>
<p>실제로 이 기능은 <a class="el" href="group__core.html">Core</a> 모듈에서 <a class="el" href="classby_1_1ntype.html">ntype</a> 을 주입하기 위해 사용합니다. 자세한 내용은 <a class="el" href="classby_1_1ntype.html">ntype</a> 을 참조하세요.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md207"></a>
정리하기</h1>
<p>마지막으로 meta 정보가 초기화 되는 과정을 다시 복기해 보죠.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_8.png" />
</div>
<hr  />
<p><b>다음 문서</b>: <a class="el" href="ai-architecture-memlite.html">memlite 모듈 - 커스텀 메모리 관리</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
