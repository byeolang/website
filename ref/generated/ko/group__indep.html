<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: Indep</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'검색','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__indep.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">네임스페이스</a> &#124;
<a href="#nested-classes">클래스</a> &#124;
<a href="#define-members">매크로</a>  </div>
  <div class="headertitle"><div class="title">Indep</div></div>
</div><!--header-->
<div class="contents">

<p>Platform Dependent Layer Platform-dependent code layer that contains all platform-specific implementations. This layer handles all platform-specific code and enables the rest of the system to operate platform-independently. Conditional compilation (<code>#IF</code>, <code>#ELSE</code>, etc.) is only permitted in this module.  
<a href="#details">더 자세히 ...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
네임스페이스</h2></td></tr>
<tr class="memitem:namespaceby_1_1platform_a_p_i"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceby_1_1platform_a_p_i.html">by::platformAPI</a></td></tr>
<tr class="memdesc:namespaceby_1_1platform_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-independent API wrapper for OS-specific operations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
클래스</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1fsystem.html">by::fsystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform filesystem utilities for recursive file traversal  <a href="classby_1_1fsystem.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1build_feature.html">by::buildFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides build-time information and feature detection  <a href="classby_1_1build_feature.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1build_feature_1_1date.html">by::buildFeature::date</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build date information  <a href="structby_1_1build_feature_1_1date.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1build_feature_1_1time.html">by::buildFeature::time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build time information  <a href="structby_1_1build_feature_1_1time.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1build_feature_1_1version.html">by::buildFeature::version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version information  <a href="structby_1_1build_feature_1_1version.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1build_feature_1_1platform.html">by::buildFeature::platform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform information  <a href="structby_1_1build_feature_1_1platform.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1build_feature_1_1config.html">by::buildFeature::config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build configuration information  <a href="structby_1_1build_feature_1_1config.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1cp_iter.html">by::cpIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codepoint-based string iterator  <a href="classby_1_1cp_iter.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1dlib.html">by::dlib</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic library loading and management class  <a href="classby_1_1dlib.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1dumpable.html">by::dumpable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for objects that can dump their state  <a href="classby_1_1dumpable.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1end.html">by::end</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deferred execution utility similar to defer keyword in other languages  <a href="classby_1_1end.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1err_lv.html">by::errLv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error level definitions and utilities  <a href="classby_1_1err_lv.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1errorable.html">by::errorable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for objects that can report errors  <a href="classby_1_1errorable.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1tmay.html">by::tmay&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional value wrapper for error indication without exceptions  <a href="classby_1_1tmay.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1tmedium.html">by::tmedium&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Medium class used exclusively in the OR macro for safe reference handling  <a href="classby_1_1tmedium.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classby_1_1tres.html">by::tres&lt; T, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template result container with typed error information  <a href="classby_1_1tres.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1type_trait.html">by::typeTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait utilities for template metaprogramming  <a href="structby_1_1type_trait.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structby_1_1_initiator.html">by::Initiator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for executing code before main() function  <a href="structby_1_1_initiator.html#details">더 자세히 ...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
매크로</h2></td></tr>
<tr class="memitem:gaae355cd9111e9235f78252f886defa0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gaae355cd9111e9235f78252f886defa0f">_ON_EACH_DECL</a>(cmd)&#160;&#160;&#160;__BY__DECL_##cmd</td></tr>
<tr class="memdesc:gaae355cd9111e9235f78252f886defa0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">byeol universal macro  <a href="group__indep.html#gaae355cd9111e9235f78252f886defa0f">더 자세히 ...</a><br /></td></tr>
<tr class="separator:gaae355cd9111e9235f78252f886defa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7eec02f1b120a4b36f33855740484d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gac7eec02f1b120a4b36f33855740484d5">__BY__DECL_ME_1</a>(ME)&#160;&#160;&#160;BY_ME_1(ME)</td></tr>
<tr class="memdesc:gac7eec02f1b120a4b36f33855740484d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">byeolMeta macro's sub-commands, ME  <a href="group__indep.html#gac7eec02f1b120a4b36f33855740484d5">더 자세히 ...</a><br /></td></tr>
<tr class="separator:gac7eec02f1b120a4b36f33855740484d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec14873565c90c84918e0eb1b2c7e15a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gaec14873565c90c84918e0eb1b2c7e15a">BY_DEF_ME_2</a>(ME,  SUPER)&#160;&#160;&#160;__BY__DECL_DEF_ME_2(ME, SUPER)</td></tr>
<tr class="memdesc:gaec14873565c90c84918e0eb1b2c7e15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">byeolMeta macro's sub-commands, DEF_ME  <a href="group__indep.html#gaec14873565c90c84918e0eb1b2c7e15a">더 자세히 ...</a><br /></td></tr>
<tr class="separator:gaec14873565c90c84918e0eb1b2c7e15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de3b2867e4ea8c08be077f49965cca8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#ga9de3b2867e4ea8c08be077f49965cca8">__OR_DO__</a>(_expr_)</td></tr>
<tr class="memdesc:ga9de3b2867e4ea8c08be077f49965cca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR macro  <a href="group__indep.html#ga9de3b2867e4ea8c08be077f49965cca8">더 자세히 ...</a><br /></td></tr>
<tr class="separator:ga9de3b2867e4ea8c08be077f49965cca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898e125d079d4eb8d0b9f339c0fa259f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#ga898e125d079d4eb8d0b9f339c0fa259f">BY_OVERLOAD</a>(NAME, ...)&#160;&#160;&#160;BY_CONCAT(NAME##_, __OVERLOAD_VA_NUM_ARGS(__VA_ARGS__))(__VA_ARGS__)</td></tr>
<tr class="memdesc:ga898e125d079d4eb8d0b9f339c0fa259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro Overloding:  <a href="group__indep.html#ga898e125d079d4eb8d0b9f339c0fa259f">더 자세히 ...</a><br /></td></tr>
<tr class="separator:ga898e125d079d4eb8d0b9f339c0fa259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71175db71a64f99bbf5fc4504445c35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gaf71175db71a64f99bbf5fc4504445c35">BY_PAIR_1</a>(x)&#160;&#160;&#160;x</td></tr>
<tr class="memdesc:gaf71175db71a64f99bbf5fc4504445c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funnel  <a href="group__indep.html#gaf71175db71a64f99bbf5fc4504445c35">더 자세히 ...</a><br /></td></tr>
<tr class="separator:gaf71175db71a64f99bbf5fc4504445c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9728243b720c9bd25896286411e6e11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">BY_SIDE_FUNC</a>(...)&#160;&#160;&#160;<a class="el" href="group__indep.html#ga898e125d079d4eb8d0b9f339c0fa259f">BY_OVERLOAD</a>(BY_SIDE_FUNC, __VA_ARGS__)</td></tr>
<tr class="memdesc:gaf9728243b720c9bd25896286411e6e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Side function macros for safe pointer operations  <a href="group__indep.html#gaf9728243b720c9bd25896286411e6e11">더 자세히 ...</a><br /></td></tr>
<tr class="separator:gaf9728243b720c9bd25896286411e6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66a6cdf25aca4c8eeb667e884fc905a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(fn)</td></tr>
<tr class="separator:gab66a6cdf25aca4c8eeb667e884fc905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ab439db30f8eaf801c4061d1efb11d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__indep.html#ga60ab439db30f8eaf801c4061d1efb11d">__WHEN_OBJECT__</a>&#160;&#160;&#160;__indep_when__</td></tr>
<tr class="memdesc:ga60ab439db30f8eaf801c4061d1efb11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Early-return pattern macro for exception handling  <a href="group__indep.html#ga60ab439db30f8eaf801c4061d1efb11d">더 자세히 ...</a><br /></td></tr>
<tr class="separator:ga60ab439db30f8eaf801c4061d1efb11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">상세한 설명</h2>
<p >Platform Dependent Layer Platform-dependent code layer that contains all platform-specific implementations. This layer handles all platform-specific code and enables the rest of the system to operate platform-independently. Conditional compilation (<code>#IF</code>, <code>#ELSE</code>, etc.) is only permitted in this module. </p>
<h2 class="groupheader">매크로 문서화</h2>
<a id="gac7eec02f1b120a4b36f33855740484d5" name="gac7eec02f1b120a4b36f33855740484d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7eec02f1b120a4b36f33855740484d5">&#9670;&nbsp;</a></span>__BY__DECL_ME_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __BY__DECL_ME_1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ME</td><td>)</td>
          <td>&#160;&#160;&#160;BY_ME_1(ME)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>byeolMeta macro's sub-commands, ME </p>
<p >it defines 2 typedefs, me and super. <code>me</code> is same type to <code>typeof(this)</code> class in c++. and <code>super</code> is literally superclass of <code>me</code>. those typedefs are also available in byeol language.</p>
<p >This is part of an effort to make the environment of the byeol language and the C++ environment as consistent as possible. </p>

</div>
</div>
<a id="ga9de3b2867e4ea8c08be077f49965cca8" name="ga9de3b2867e4ea8c08be077f49965cca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de3b2867e4ea8c08be077f49965cca8">&#9670;&nbsp;</a></span>__OR_DO__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __OR_DO__</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_expr_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>값:</b><div class="fragment"><div class="line">    | [&amp;](<span class="keyword">auto</span>&amp;&amp; __p) -&gt; <span class="keywordtype">void</span> {                       \</div>
<div class="line">        __orStack__::push(nul(__p) ? _expr_ : <span class="keyword">false</span>); \</div>
<div class="line">    };                                                \</div>
<div class="line">    if(__orStack__::pop())</div>
</div><!-- fragment -->
<p>OR macro </p>
<p >It enables <code>return ?:</code>, a type of safe navigation in modern languages, in C++. prerequisites: OR macro is based on <code>WHEN</code> macro. Before learning about OR, you need to know WHEN first.</p>
<p >usage: OR macro is used like this: <code>&lt;expr-evalution-as-pointer&gt; OR.&lt;when-expr&gt;</code> in this case, expr-evaluation-as-pointer must evaluate to a pointer type of a certain type. if not, a compilation error occurs. an expression using the WHEN macro is placed after OR, and is executed instead if the previous pointer was nullptr. if the pointer was not nullptr, it is returned as a reference. as a result, using the OR macro, you can safely perform nullcheck and handle non-null types.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* foo();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// without OR:</span></div>
<div class="line">    <span class="keywordtype">int</span>* value = foo();</div>
<div class="line">    <span class="keywordflow">if</span>(!value) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">return</span> *value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// with OR:</span></div>
<div class="line">    <span class="keywordtype">int</span>&amp; value = foo() OR.ret(-1) <span class="comment">// If foo() returns nullptr, return -1.</span></div>
<div class="line">    <span class="comment">// now, you don&#39;t need to dereference `value` everytime!</span></div>
<div class="line">    return value;</div>
<div class="line">}</div>
</div><!-- fragment --><p >the WHEN macro provides various methods in addition to simply returning an error. please check it if want to know more.</p>
<p >FAQ: Q. I want to use OR and also do casting as <code>(T&amp;)</code>. A. since OR's return type is reference, you may simply write some code like below. </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A {};</div>
<div class="line"> </div>
<div class="line">A* foo() { <span class="keywordflow">return</span> <span class="keyword">new</span> B(); }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    B&amp; value = (A&amp;) foo() OR.ret(-1); <span class="comment">// &lt;-- but a compile error occurs here.</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >the reason is that, as mentioned earlier, the left side of OR must always be a pointer. therefore, it should not be <code>(T&amp;)</code> but <code>(T*)</code>. this is correct codes.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> main() {</div>
<div class="line">        B&amp; value = (B*) foo() OR.ret(-1); <span class="comment">// or you may use `auto&amp;`</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> you want to cast the <span class="keyword">final</span> result of a <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>() chain to T&amp;, you must surround the</div>
<div class="line">entire <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>() chain with parentheses.</div>
<div class="line"> </div>
<div class="line">@code</div>
<div class="line">    B&amp; value = (B*) (foo() <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getA()) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getMayB())) OR.ret();</div>
<div class="ttc" id="agroup__indep_html_gab66a6cdf25aca4c8eeb667e884fc905a"><div class="ttname"><a href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a></div><div class="ttdeci">#define TO(fn)</div><div class="ttdef"><b>Definition:</b> to.hpp:175</div></div>
</div><!-- fragment --><p >Q. Can I use OR after <code>return</code>? A. <code>OR</code> was created based on the precondition that it would be used when defining a variable. It cannot be used with the <code>return</code> keyword.</p>
<p >Q. I used OR macro with auto&amp; and got <code>Non-const lvalue reference to...</code> error. my code is like below, </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; ret = _sub[name].get() OR.ret();</div>
</div><!-- fragment --><p >A. don't use auto keyword. the actual return type of <code>OR</code> macro could be <code>tmedium&lt;T&gt;</code> or <code>tstr</code> or <code>tweak</code>. it differs in context which you're using. it was specified in each operand class file, for instance, '<a class="el" href="tstr_8hpp.html">tstr.hpp</a>'. and if you used OR macro which returns <code>tmedium</code>, it is implicitly returned as T&amp; through this class. therefore, unless you have a special situation where you want to use tmedium, specify the type directly instead of auto.</p>
<div class="fragment"><div class="line">MyClass&amp; ret = _sub[name].get() OR.ret();</div>
<div class="line"><span class="comment">// or,</span></div>
<div class="line">tstr&lt;MyClass&gt; ret = youGetThisInstanceOnHeap() OR.ret();</div>
</div><!-- fragment --><p >Q. I used OR in a function whose return type is tmay and initialized it with a T&amp;&amp; variable, but the value is strange.</p>
<div class="fragment"><div class="line">tmay&lt;A&gt; foo();</div>
<div class="line">A&amp;&amp; a = foo() OR.ret();</div>
</div><!-- fragment --><p >A. TLDR; take rvalue with type <code>tmay&lt;A&gt;&amp;&amp;</code> just like rvalue reference to return type of the function.</p>
<div class="fragment"><div class="line">tmay&lt;A&gt;&amp;&amp; a = foo();</div>
</div><!-- fragment --><p >foo() returns tmay by value. If you receive something returned by value as an rvalue reference, its life would be extended, but in this case, since it is not received as tmay, the value inside it is taken out and returned, so the tmay temporary object does not extend its life and starts to die immediately. as a result, a garbage value is bound to <code>A&amp;&amp; a</code>. </p>

</div>
</div>
<a id="ga60ab439db30f8eaf801c4061d1efb11d" name="ga60ab439db30f8eaf801c4061d1efb11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60ab439db30f8eaf801c4061d1efb11d">&#9670;&nbsp;</a></span>__WHEN_OBJECT__</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __WHEN_OBJECT__&#160;&#160;&#160;__indep_when__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Early-return pattern macro for exception handling </p>
<p >The byeol project actively applies the early-return pattern throughout. This helps reduce code depth, improve code flow clarity, and handle exceptional situations immediately. However, traditional <code>if</code> statements make it difficult to distinguish between normal branching logic and early-return exception handling.</p>
<h1><a class="anchor" id="problem"></a>
Problem</h1>
<p >Consider this traditional early-return code: </p><div class="fragment"><div class="line">str me::eval(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    std::string key = _makeKey(a);</div>
<div class="line">    <span class="keywordflow">if</span>(key.empty()) {</div>
<div class="line">        <a class="code hl_define" href="clog_2common_2macro_8hpp.html#a39decaf05c8269cf9d21c83ff19014a4">BY_E</a>(<span class="stringliteral">&quot;key is empty&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span>(_isSelfMaking(key)) {</div>
<div class="line">        <a class="code hl_define" href="clog_2common_2macro_8hpp.html#a39decaf05c8269cf9d21c83ff19014a4">BY_E</a>(<span class="stringliteral">&quot;error: you tried to clone self generic object.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> tstr&lt;obj&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(!_cache.count(key))</div>
<div class="line">        _makeGeneric(key, params::make(_paramNames, a));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> _cache[key];</div>
<div class="line">}</div>
<div class="ttc" id="aclog_2common_2macro_8hpp_html_a39decaf05c8269cf9d21c83ff19014a4"><div class="ttname"><a href="clog_2common_2macro_8hpp.html#a39decaf05c8269cf9d21c83ff19014a4">BY_E</a></div><div class="ttdeci">#define BY_E(fmt,...)</div><div class="ttdoc">Log macro: prints debug log on console and file.</div><div class="ttdef"><b>Definition:</b> macro.hpp:20</div></div>
</div><!-- fragment --><p >The WHEN macro solves this by explicitly marking early-return cases. It is used exclusively for early-return patterns. Additionally, since over 90% of early-returns involve logging an error and returning an error value, WHEN supports chaining to express both operations in a single line.</p>
<h1><a class="anchor" id="solution"></a>
Solution</h1>
<p >The same code becomes much clearer with WHEN: </p><div class="fragment"><div class="line">str me::eval(<span class="keyword">const</span> args&amp; a) {</div>
<div class="line">    std::string key = _makeKey(a);</div>
<div class="line">    WHEN(key.empty()).err(<span class="stringliteral">&quot;key is empty&quot;</span>).ret(tstr&lt;obj&gt;());</div>
<div class="line">    WHEN(_isSelfMaking(key))</div>
<div class="line">        .err(<span class="stringliteral">&quot;error: you tried to clone self generic object.&quot;</span>)</div>
<div class="line">        .ret(tstr&lt;obj&gt;());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(!_cache.count(key)) _makeGeneric(key, params::make(_paramNames, a));</div>
<div class="line">    <span class="keywordflow">return</span> _cache[key];</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now the purpose of each <code>if</code> is clear, and exception handling is visually distinct from normal branching logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>WHEN macro is used very frequently throughout the project, so it's important to understand it well.</dd>
<dd>
<b>WHEN_OBJECT</b> customization Since byeol uses a multi-layered architecture, different layers may need different behavior when WHEN conditions are met. Low-level layers simply output logs to the screen, but high-level layers require more complex processing like creating exception objects with stacktrace information. This is solved by redefining <code>__WHEN_OBJECT__</code> in each layer. </dd></dl>

</div>
</div>
<a id="gaae355cd9111e9235f78252f886defa0f" name="gaae355cd9111e9235f78252f886defa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae355cd9111e9235f78252f886defa0f">&#9670;&nbsp;</a></span>_ON_EACH_DECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _ON_EACH_DECL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmd</td><td>)</td>
          <td>&#160;&#160;&#160;__BY__DECL_##cmd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>byeol universal macro </p>
<p >This reduces the possibility of macro conflicts between different libraries and makes macro writing easier. and this is generalized API used to describe the metadata of class in byeol. BY can be used to define detailed metadata about a class by chaining sub-command sets. these sub-commands are macros available only inside of BY.</p>
<p >for instance, </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">    BY(CLASS(Foo), VISIT(Foo), ...)</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    ...and your codes...</div>
<div class="line">};</div>
</div><!-- fragment --><p >Each command preceding BY is prefixed with the __BY__DECL_ prefix. The following commands can be used within the BY macro: CLASS: Injects metadata for a concrete class. VISIT: Makes the class visitor-friendly. ME: Adds typedefs named super and me. DEF_ME: Same as ME, but used in the implementation file. ADT: Injects metadata for an abstract class. CLONE: Adds a virtual copy constructor. </p>

</div>
</div>
<a id="gaec14873565c90c84918e0eb1b2c7e15a" name="gaec14873565c90c84918e0eb1b2c7e15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec14873565c90c84918e0eb1b2c7e15a">&#9670;&nbsp;</a></span>BY_DEF_ME_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BY_DEF_ME_2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SUPER&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__BY__DECL_DEF_ME_2(ME, SUPER)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>byeolMeta macro's sub-commands, DEF_ME </p>
<p >Similar to ME, this macro adds typedefs called <code>me</code> and <code>super</code> to the scope of the current compilation unit.</p>
<p >This macro was added for use when writing implementation files. Because the <code>ME</code> sub-command adds typedefs to the class scope, it's not available for you to access them outside of member fuctions when writing implementation file.</p>
<p >let me give you example: </p><div class="fragment"><div class="line"><span class="comment">// Foo.cpp --</span></div>
<div class="line"> </div>
<div class="line">BY(DEF_ME(Foo))</div>
<div class="line"><span class="comment">// From now on, new typedef `me` refers To Foo type, and `super` refers</span></div>
<div class="line"><span class="comment">// to Foo::super.</span></div>
<div class="line"><span class="comment">// if there&#39;s no Foo::super, you&#39;ll have some compile errors when use it.</span></div>
<div class="line"> </div>
<div class="line">me::Foo() {</div>
<div class="line">    <span class="comment">// if you didn&#39;t use DEF_ME above, `me::Foo() {` wouldn&#39;t be possible.</span></div>
<div class="line">    <span class="comment">// Instead, you should use `Foo::Foo() {` &#39;cause by the time use `me::`,</span></div>
<div class="line">    <span class="comment">// it&#39;s not in a member funtion.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga898e125d079d4eb8d0b9f339c0fa259f" name="ga898e125d079d4eb8d0b9f339c0fa259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898e125d079d4eb8d0b9f339c0fa259f">&#9670;&nbsp;</a></span>BY_OVERLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BY_OVERLOAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;BY_CONCAT(NAME##_, __OVERLOAD_VA_NUM_ARGS(__VA_ARGS__))(__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro Overloding: </p>
<p >by count of given arguments, let compiler determine which macro should works. original source code from BuvinJ at <a href="https://stackoverflow.com/questions/11761703/overloading-macro-on-number-of-arguments">https://stackoverflow.com/questions/11761703/overloading-macro-on-number-of-arguments</a></p>
<p >usage: </p><div class="fragment"><div class="line"><span class="comment">//  define macro:</span></div>
<div class="line"><span class="preprocessor">#define MyMacro_0() 100</span></div>
<div class="line"><span class="preprocessor">#define MyMacro_1(x) (x)+5</span></div>
<div class="line"><span class="preprocessor">#define MyMacro_2(x, y) (x)+(y)</span></div>
<div class="line"><span class="preprocessor">#define MyMacro(...) BY_OVERLOAD(MyMacro, __VA_ARGS__)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//  using:</span></div>
<div class="line">cout &lt;&lt; MyMacro(5) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; MyMacro(3, 5) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; MyMacro() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --><p >expected output should be, 10, 8, 100. </p>

</div>
</div>
<a id="gaf71175db71a64f99bbf5fc4504445c35" name="gaf71175db71a64f99bbf5fc4504445c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71175db71a64f99bbf5fc4504445c35">&#9670;&nbsp;</a></span>BY_PAIR_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BY_PAIR_1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;x</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funnel </p>
<p >This macro mostly used to put in arguments to macro behind macro. Why does we need this?: </p><div class="fragment"><div class="line"><span class="preprocessor">#define My_2(X, y) .......</span></div>
</div><!-- fragment --><p >But, if you put class template as macro argument, expanding macro gets messed up. My_2(template&lt;int, float&gt;, template&lt;A, B&gt;) // in fact, preprocessor thought we  passed 4 arguments, not 2.</p>
<p >Then, Use Funnel macro instead: </p><div class="fragment"><div class="line">My_2(BY_PAIR(MyMap&lt;T, U&gt;), BY_PAIR(<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U))</div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf9728243b720c9bd25896286411e6e11" name="gaf9728243b720c9bd25896286411e6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9728243b720c9bd25896286411e6e11">&#9670;&nbsp;</a></span>BY_SIDE_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BY_SIDE_FUNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__indep.html#ga898e125d079d4eb8d0b9f339c0fa259f">BY_OVERLOAD</a>(BY_SIDE_FUNC, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Side function macros for safe pointer operations </p>
<p >Side Func is a term I coined. It refers to an overloaded function added for the convenience of the original function. For example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(std::string name, std::string value);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This is a side func.</span></div>
<div class="line"><span class="keywordtype">void</span> foo(std::string value) { <span class="keywordflow">return</span> foo(<span class="stringliteral">&quot;default&quot;</span>, value); }</div>
</div><!-- fragment --><p> This macro makes it easy to create side functions like the one above. </p>

</div>
</div>
<a id="gab66a6cdf25aca4c8eeb667e884fc905a" name="gab66a6cdf25aca4c8eeb667e884fc905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66a6cdf25aca4c8eeb667e884fc905a">&#9670;&nbsp;</a></span>TO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>값:</b><div class="fragment"><div class="line">    -&gt;*[&amp;](<span class="keyword">auto</span>&amp;&amp; __p) -&gt; <span class="keyword">decltype</span>(__p.fn) { \</div>
<div class="line">        return __p.fn;                       \</div>
<div class="line">    }</div>
</div><!-- fragment --><p >@breif safe navigation feature of c++</p>
<p ><code>TO</code> supports the safe navigation features of modern languages very intuitively and naturally. the basic usage is <code>&lt;expression&gt; <a class="el" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO(yourAccessor())</a></code>. let's explain with an example first before explain further.</p>
<p >usage: let's assume that we have following classes. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Resource {</div>
<div class="line">    Pallete* getPallete(); <span class="comment">// this can return nullptr.</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Pallete {</div>
<div class="line">    Canvas* getCanvas(); <span class="comment">// this can return nullptr.</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Canvas {</div>
<div class="line">    Brush&amp; getBrush(<span class="keywordtype">int</span> type); <span class="comment">// this can&#39;t return nullptr.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >and what if there are funcs utilize above structs. in language spec of c++, there is no sort of safe navigation thing, so we've to do like this. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> getBrushColorCode(Resource r) {</div>
<div class="line">    <span class="keyword">auto</span>* pallete = r.getPallete();</div>
<div class="line">    <span class="keywordflow">if</span>(!pallete) {</div>
<div class="line">        log(<span class="stringliteral">&quot;pallete is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>* canvas = pallete-&gt;getCanvas();</div>
<div class="line">    <span class="keywordflow">if</span>(!canvas) {</div>
<div class="line">        log(<span class="stringliteral">&quot;canvas is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Brush&amp; brush = canvas-&gt;getBrush(BrushType.SYSTEM);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> brush.getColorCode();</div>
<div class="line">}</div>
</div><!-- fragment --><p >of course, this example illustrates a rather extreme train wreck pattern, and is a design that should be avoided, but situations where you need to access a pointer to a certain number of pointers occur frequently, and if you don't always check in advance whether the pointer is valid every time you dereference it, UB will occur.</p>
<p >to be: with safe navigation, whether you will receive nullptr or not is determined after the dereference chain of all pointers is finished. so the resulting code can become very concise. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> getBrushColorCode(Resource r) {</div>
<div class="line">    <span class="keywordtype">int</span>* code = r <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getPallete()) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getCanvas())</div>
<div class="line">    <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getBrush(BrushType.SYSTEM)) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getColorCode()); if(!code) {</div>
<div class="line">        log(<span class="stringliteral">&quot;code is null&quot;</span>)</div>
<div class="line">        return -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return *code;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>as you can see, it looks easy to use, but there are a few things that you should be aware of.<ol type="1">
<li>the previously mentioned <code>&lt;expression&gt;</code> does not simply mean pointers and references, but also includes classes that satisfy the following conditions. <pre class="fragment">a. a class that defines operator-&gt;().
b. a class that defines operator*().
c. a class that defines operator bool().
</pre> you may have noticed that the classes that satisfy the above conditions are usually smart pointers like <code>unique_ptr</code>. the byeol repository provides separate smart pointers and classes that replace std::optional&lt;T&gt; for API consistency and safe type checking. e.g. tstr&lt;T&gt;, tweak&lt;T&gt;, binder, tmay&lt;T&gt;, tres&lt;T&gt; are included here.</li>
</ol>
</dd></dl>
<p>the <a class="el" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO()</a> macro is designed to work properly even if the return value of the function is a value or reference to the above class. it works even if it exists in the middle of safe navigation chain. for example,</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Resource {</div>
<div class="line">    Pallete* getPallete(); <span class="comment">// this can return nullptr.</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Pallete {</div>
<div class="line">    Canvas&amp; getCanvas(); <span class="comment">// this *never* returns nullptr.</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Canvas {</div>
<div class="line">    tstr&lt;Brush&gt; getBrush(<span class="keywordtype">int</span> type); <span class="comment">// this is not pointer, but</span></div>
<div class="line">    pointer-like-variable.</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> getBrushColorCode(Resource r) {</div>
<div class="line">    <span class="comment">// however you can do exactly same like above example.</span></div>
<div class="line">    <span class="keywordtype">int</span>* code = r <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getPallete()) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getCanvas())</div>
<div class="line">    <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getBrush(BrushType.SYSTEM)) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getColorCode())</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// but you may notice that you don&#39;t have to put `TO` for reference</span></div>
<div class="line">    type. so, <span class="keywordtype">int</span>* code = r <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getPallete().getCanvas())</div>
<div class="line">    <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getBrush(BrushType.SYSTEM)) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getColorCode());</div>
<div class="line"> </div>
<div class="line">    if(!code) return -1;</div>
<div class="line">    return code;</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>if nullptr returned during the chain, the final result value becomes the nullptr of last type of the chain. if it is T*, it will be nullptr, but if it is T, i.e. a function that returns by value, the return value will be T{}.</li>
<li>don't recommend you to put a reference in <code><a class="el" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO()</a></code> references are always non-null, so you can access them directly.</li>
<li>it is not recommended for any function to return a pointer type to a pointer-like-variable. pointer-like-variable is a sufficiently lightweight class. You can return it by value, or if you don't like that, return it by reference.</li>
<li>it goes very well with OR macro. please check the usage of OR macro in advance. If you also use WHEN macro, the code will become way more concise.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getBrushColorMode(Resource r) {</div>
<div class="line">    <span class="comment">// this uses OR macro. so final type of the chain is `int&amp;`.</span></div>
<div class="line">    <span class="comment">// but `int&amp;` can be copied into new variable `int`.</span></div>
<div class="line">    <span class="keywordtype">int</span> code = r <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getPallete()) <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getCanvas().getBrush(BrushType.SYSTEM))</div>
<div class="line">        <a class="code hl_define" href="group__indep.html#gab66a6cdf25aca4c8eeb667e884fc905a">TO</a>(getColorCode()) OR.err(&quot;code is null&quot;).ret(-1)</div>
<div class="line">    return code;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
