<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>byeol: clog 모듈 - 로깅 시스템</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link type="text/css" rel="stylesheet" href="../../assets/css/galmuri.css" />
<script type="text/javascript" src="dynsections.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script type="text/javascript" src="https://github.com/byeolang/highlightjs-byeol/releases/download/v0.2.8/highlightjs-byeol-min.js"></script>
<script type="text/javascript" src="postprocess.js"></script>
<script type="text/javascript" src="pageInjector.js"></script>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="byeol.css" rel="stylesheet" type="text/css"/>
<link href="highlightjs-theme-byeol.css" rel="stylesheet" type="text/css"/>
<!-- extensions: -->
<!--    fragement copy to clipboard: -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!--    paragraph linking: -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<!--    interactive toc: -->
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- end of extension -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','검색');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('ae-architecture-clog.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">clog 모듈 - 로깅 시스템</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2byeol_2byeol_2doc_2ref_2ko_2ae-architecture-clog"></a> clog 모듈은 여러 출력 스트림과 필터링 기능을 갖춘 경량화된 C++ 로깅 프레임워크를 제공합니다. 이 모듈은 아키텍처 상 indep 모듈을 제외하고 상위 모듈에 대한 의존성이 없습니다. Facade 패턴, Composite 패턴, Chain of Responsibility 패턴 등을 활용하여 유연하고 확장 가능한 로깅 시스템으로 구현되어있고, richLog 기능, Scope Logging 기능을 통해 사용성이 뛰어납니다.</p>
<p><b>clog 모듈의 주요 클래스:</b></p>
<div class="plantumlgraph">
<img src="inline_umlgraph_4.png" />
</div>
<hr  />
<h1><a class="anchor" id="autotoc_md108"></a>
로깅 시스템 아키텍처</h1>
<p>clog 모듈의 핵심은 <a class="el" href="classby_1_1stream.html">stream</a> 입니다. <a class="el" href="classby_1_1stream.html">stream</a> 은 쉽게 말해 로깅이 출력되는 스트림, 즉 목적지를 표현합니다. 현재는 <a class="el" href="classby_1_1console_stream.html">consoleStream</a> 과 <a class="el" href="classby_1_1file_log_stream.html">fileLogStream</a> 2가지가 존재합니다. 모든 <a class="el" href="classby_1_1stream.html">stream</a> 은 기본적으로 <a class="el" href="classby_1_1logger.html">logger</a> 클래스가 처음부터 소유하고 있습니다.</p>
<p>각 stream은 byeol의 핵심 클래스들과 마찬가지로 다음과 같은 State Machine 패턴을 사용한 상태 전이 도식을 갖습니다:</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">RELEASED ---init()---&gt; INITIALIZED</div>
<div class="line">RELEASED &lt;--rel()----- INITIALIZED</div>
</div><!-- fragment --><p>객체를 처음 생성하면 RELEASED 상태에서 시작하지만, 생성자 내부에서 자동으로 <code>init()</code>을 호출하여 INITIALIZED 상태로 진입합니다. 단, 특정 stream 인스턴스를 명시적으로 <code>rel()</code>한 경우, 다시 명시적으로 <code>init()</code>을 호출하지 않으면 정상적으로 동작하지 않아요.</p>
<p>stream은 또한 enable 여부를 관리합니다. setEnable(false)를 통해 특정 stream을 disable 시키면 해당 stream은 동작하지 않아요.</p>
<p>또하나 중요한 점은 <a class="el" href="classby_1_1logger.html">logger</a> 클래스 자체도 <a class="el" href="classby_1_1stream.html">stream</a> 에서 상속하기 때문에 <a class="el" href="classby_1_1stream.html">stream</a> 과 동일한 API를 제공한다는 점입니다. <a class="el" href="classby_1_1logger.html">logger</a> 는 각 API에 대해 소유한 모든 <a class="el" href="classby_1_1stream.html">stream</a> 들에 대해 redirection 하는 구성으로 구현되어 있습니다. 이는 Composite 패턴의 전형적인 구조로, logger가 여러 stream을 하나의 트리 구조로 관리하면서 동일한 인터페이스를 제공합니다. 예를들어 <code>logger::get().setEnable(false)</code>를 하게 되면, 모든 <a class="el" href="classby_1_1stream.html">stream</a> 이 disable 됩니다.</p>
<p><a class="el" href="classby_1_1stream.html">stream</a> 은 logBypass(const nchar*) 라는 함수를 제공하는데, 이것은 어떠한 가공도 없이 문자열을 그대로 지정한 <a class="el" href="classby_1_1stream.html">stream</a> 으로 로그 메시지를 보냅니다.</p>
<p><b>stream 제어 예제</b></p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">logger&amp; log = logger::get();</div>
<div class="line"> </div>
<div class="line">// 특정 stream 가져오기</div>
<div class="line">stream* console = log.getStream(&quot;consoleStream&quot;);</div>
<div class="line">stream* fileLog = log.getStream(&quot;fileLogStream&quot;);</div>
<div class="line"> </div>
<div class="line">// stream별로 enable/disable 제어</div>
<div class="line">console-&gt;setEnable(true);   // console 출력 활성화</div>
<div class="line">fileLog-&gt;setEnable(false);  // 파일 로깅 비활성화</div>
<div class="line"> </div>
<div class="line">// 로깅 - console에만 출력됨</div>
<div class="line">BY_I(&quot;This goes to console only&quot;);</div>
<div class="line"> </div>
<div class="line">// 모든 stream disable</div>
<div class="line">log.setEnable(false);</div>
<div class="line">BY_I(&quot;This won&#39;t be logged anywhere&quot;);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md110"></a>
로깅의 기본 사용법</h1>
<p><a class="el" href="classby_1_1logger.html">logger</a> 클래스는 <a class="el" href="classby_1_1stream.html">stream</a> 이라고 불리는 복수의 로깅 경로를 통해 체계적으로 로깅이 가능한 경량화된 C++ 로깅 프레임워크의 일종의 facade입니다.</p>
<p>일반적으로는 동봉되는 매크로를 통해, 다음과 같이 사용합니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">BY_I(&quot;slot[%s] origins loaded.&quot;, getName());</div>
</div><!-- fragment --><p>위 코드는 다음과 같이 출력되는데요,</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">Oct 22 2025 21:26:13   I    cppPackLo   &lt;_loadLibs#49&gt;    slot[cpp] origins loaded.</div>
<div class="line">          (1)         (2)     (3)           (4)                    (5)</div>
</div><!-- fragment --><p>위 메시지는 다음과 같은 정보를 보여줍니다:</p>
<ol type="1">
<li>로깅한 날짜(Oct 22 2025)와 시간(21:26:13)</li>
<li>로그 레벨(I, Info). 로그 레벨은 ERR, WARN, INFO 총 3개가 존재합니다.</li>
<li>로깅한 클래스명(cppPackLoading)</li>
<li>로깅한 함수(_loadLibs)와 해당 파일내 라인번호(49)</li>
<li>로그 메시지(slot[cpp] origins loaded)</li>
</ol>
<p>기본적인 사용법은 여기까지만 알아도 충분해요. 로그 레벨은 Error, Warning, Info, 3개가 존재하며, 각각 매크로도 3개가 존재합니다. 또한 만약 디버그 바이너리에서만 로그를 출력하고 싶다면 레벨 앞에 <code>D</code>를 붙입니다. 이를테면 다음과 같습니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">BY_DE(&quot;leaf: ERR: %s&quot;, e);</div>
</div><!-- fragment --><p>위 코드는 printf에서 익숙하게 봤을 서식문자를 사용하고 있습니다. 이렇게 동적인 값을 집어넣는 것도 가능합니다. 결과는 다음과 같이 출력됩니다.</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">Oct 22 2025  21:26:13 E leafPars &lt;_finalize#263&gt; leaf: ERR: src is empty</div>
</div><!-- fragment --><p>해당 macro의 구현은, 출력할 문자열 앞에 날짜나 시간 등을 붙여서 logBypass()에 전달하도록 expand 하는 것이긴 하나, 그외에도 한가지 중요한 기능이 더 있습니다.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md112"></a>
Scope 로깅 매크로</h2>
<p>함수나 블록의 <b>진입과 탈출을 시각화</b>하고 싶을 때는 <code>BY_I_SCOPE</code>, <code>BY_E_SCOPE</code>, <code>BY_W_SCOPE</code> 매크로를 사용합니다. 이 매크로들은 <b>RAII 패턴</b>으로 구현되어 있어서, 스코프에 진입할 때와 벗어날 때 자동으로 로그를 남깁니다.</p>
<p>다음은 기본적인 사용 예시입니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">void processData(int id) {</div>
<div class="line">    BY_I_SCOPE(&quot;processData id=%d&quot;, id);</div>
<div class="line">    // 함수 본문...</div>
<div class="line">    BY_I(&quot;processing...&quot;);</div>
<div class="line">    foo();</div>
<div class="line">}</div>
<div class="line">void foo() {</div>
<div class="line">    BY_I_SCOPE(&quot;inside of foo&quot;);</div>
<div class="line">    BY_I(&quot;hello foo!&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>위 코드는 다음과 같이 출력됩니다:</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">I &lt;processData#130&gt; ▶  processData id=123</div>
<div class="line">I &lt;processData#131&gt; ┣ processing...</div>
<div class="line">I &lt;processData#130&gt; ┣▶  inside of foo</div>
<div class="line">I &lt;processData#131&gt; ┃┣ hello foo!</div>
<div class="line">I &lt;processData#130&gt; ┣◀  inside of foo</div>
<div class="line">I &lt;processData#130&gt; ◀  processData id=123</div>
</div><!-- fragment --><p><code>▶</code> 기호는 스코프 진입을, <code>◀</code> 기호는 스코프 탈출을 나타냅니다. 스코프 안쪽의 로그는 <code>┣</code> 기호로 시각적인 깊이를 표현하며, 내부적으로 <a class="el" href="classby_1_1line.html#a4edc878d49948fd15dc8bff7fcb88915">line::incLv()</a> 를 통해 그래프 깊이가 자동으로 증가/감소합니다.</p>
<p><b>주의사항: 인자가 두 번 평가됩니다</b></p>
<p><code>BY_I_SCOPE</code> 매크로는 내부적으로 BY_END 와 <a class="el" href="classby_1_1scope_log.html">scopeLog</a> 를 사용하는 RAII 패턴으로 구현되어 있습니다. 이때 <b>format string의 인자가 두 번 평가</b>되므로, 부수 효과가 있는 표현식을 사용하면 안 됩니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// ✅ 올바른 사용</div>
<div class="line">void good(int id) {</div>
<div class="line">    BY_I_SCOPE(&quot;good id=%d&quot;, id);  // OK: id는 여러 번 평가해도 안전</div>
<div class="line">    // ... 작업 ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ❌ 잘못된 사용</div>
<div class="line">void bad() {</div>
<div class="line">    BY_I_SCOPE(&quot;count=%d&quot;, counter++);  // WRONG: counter가 두 번 증가함!</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>주의사항: if 블록에서 사용할 때 조심하세요</b></p>
<p><code>BY_I_SCOPE</code> 매크로를 if 문의 블록문으로 사용하면 예상과 다르게 동작할 수 있습니다. 매크로가 expand 되면서 여러 개의 statement로 펼쳐지기 때문이에요. 다음 예제를 보죠.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">void foo() {</div>
<div class="line">    if(isVerbose) BY_I_SCOPE(&quot;okay, verbose mode is on.&quot;);</div>
<div class="line">    BY_I(&quot;hello&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>위 코드는 다음과 같이 expand 됩니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">void foo() {</div>
<div class="line">    if(isVerbose)</div>
<div class="line">        BY_I(&quot;▶  okay, verbose mode is on.&quot;);</div>
<div class="line">    ::by::line::incLv();</div>
<div class="line">    BY_END(scopeLog, ...., &quot;◀  okay, verbose mode is on.&quot;);</div>
<div class="line">    BY_I(&quot;hello&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>보시다시피 if 조건에 걸리는 건 시작 로그뿐이며, <code>incLv()</code>와 <code>BY_END</code>는 항상 실행됩니다. 이는 의도한 동작이 아니죠. 이런 경우에는 <b>반드시 중괄호로 블록을 명시</b>해야 합니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// ✅ 올바른 사용</div>
<div class="line">void foo() {</div>
<div class="line">    if(isVerbose) {</div>
<div class="line">        BY_I_SCOPE(&quot;okay, verbose mode is on.&quot;);</div>
<div class="line">    }</div>
<div class="line">    BY_I(&quot;hello&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md114"></a>
richLog - 다형성 로깅</h1>
<p>richLog 는 서식문자에 입력된 argument를 다형성을 활용해서 적절한 타입으로 변환해서 로깅하는 강력한 기능입니다. 함수 오버로딩을 응용하여, 각 타입에 맞는 변환 함수를 자동으로 선택합니다. 쉽게, 예를들어 보죠.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">struct person {</div>
<div class="line">    std::string name;</div>
<div class="line">    int age;</div>
<div class="line">};</div>
<div class="line">struct address {</div>
<div class="line">    std::string state;</div>
<div class="line">    std::string city;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">person p{&quot;Harland D. Sanders&quot;, 59};</div>
<div class="line">address a{&quot;Henryville&quot;, &quot;Indiana&quot;};</div>
<div class="line"> </div>
<div class="line">BY_I(&quot;Hello I&#39;m %s and %d years old. I live in %s, %s&quot;, p.name, p.age, a.city, a.state);</div>
<div class="line">// 출력: Hello I&#39;m Harland D. Sanders and 59 years old. I live in Henryville, Indiana</div>
</div><!-- fragment --><p>richLog를 사용한다면, 위의 로깅은 다음과 같이 작성할 수 있게 됩니다.</p>
<div class="fragment"><div class="line">BY_I(&quot;Hello I&#39;m %s. I live in %s&quot;, p, a);</div>
<div class="line">// 출력: 위와 동일.</div>
</div><!-- fragment --><p>즉, 각 가변 인자의 타입을 보고 적절한 로깅 메시지를 생성하여 대신 전달하는 기능입니다. 물론 공짜는 없어요. 어딘가에는 Person타입에 대해 어떠한 메시지를 생성하겠다는 걸 추가해줘야 합니다. 하지만 그렇다곤 해도, 어떻게 이런 게 가능할까요.</p>
<h2><a class="anchor" id="autotoc_md115"></a>
핵심 알고리즘</h2>
<div class="plantumlgraph">
<img src="inline_umlgraph_5.png" />
</div>
<p>핵심은 <b>paramter pack을 활용한 변환함수 호출</b>과 <b>값 전달</b> 2가지 입니다. 먼저 <code>BY_I</code> 와 같은 매크로를 사용하면 다음의 richLog 함수를 호출하는데요.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">template &lt;typename... Ts&gt;</div>
<div class="line">void richLog(errLv::level lv, const std::string&amp; filename, const nchar* func, nint line, const nchar* fmt,</div>
<div class="line">    const Ts&amp;... args) {</div>
<div class="line">    ::by::logger::get().log(lv, filename, func, line, fmt, __convert__((const Ts&amp;) args).unwrap()...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>위와 같이 각각의 가변인자에 대해 <b>convert</b>()를 호출해 적절한 타입(예: 문자열)로 변환 되면 wrap&lt;T&gt; 객체가 반환되는데요, wrap::unwrap()을 통해 log() 함수의 가변인자로 넣는 거죠.</p>
<h2><a class="anchor" id="autotoc_md116"></a>
convert()</h2>
<p>각 모듈에 속한 클래스를 어떻게 로깅하기 쉬운 타입으로 변경할지를 정의합니다. 호출자는 <b>convert</b>()에 자신이 받은 구체타입을 넣을 뿐이며, 오버로딩에 의해서 가장 적절한 타입에 대한 __convert__가 호출됩니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">noWrap&lt;nflt&gt; __convert__(nflt rhs) { return rhs; }</div>
<div class="line">noWrap&lt;nflt&gt; __convert__(nflt* rhs) { return rhs ? __convert__(*rhs) : 0.0f; }</div>
<div class="line">noWrap&lt;const nchar*&gt; __convert__(const nchar* rhs) { return rhs ? rhs : &quot;null&quot;; }</div>
<div class="line">noWrap&lt;ndbl&gt; __convert__(ndbl* rhs) { return rhs ? __convert__(*rhs) : 0.0; }</div>
<div class="line">strWrap __convert__(nbool rhs) { return strWrap(rhs ? &quot;true&quot; : &quot;false&quot;); }</div>
<div class="line">strWrap __convert__(nbool* rhs) { return rhs ? __convert__(*rhs) : strWrap(&quot;null&quot;); }</div>
<div class="line">...</div>
</div><!-- fragment --><p>만약 앞서 언급한 Person이나 Address에 대해서도 richLog를 가능하게 하려면 어떻게 할까요?</p>
<div class="fragment"><div class="line">strWrap __convert__(person&amp;&amp; p) { return p.name + p.age + &quot; years old&quot;; }</div>
<div class="line">strWrap __convert__(address&amp;&amp; a) { return a.city + &quot;, &quot; + a.state; }</div>
</div><!-- fragment --><p>생각보다 간단한가요? 위와 같은 설계의 장점은, 범용적인 <b>convert</b>()와 특정 타입에 특화된 <b>convert</b>()를 동시에 정의할 수 있다는 말입니다. 대표적으로는 <b>convert</b>(void*)가 있어요. 어떠한 T*에도 매칭 되지 않으면 이 __convert__가 대신 호출됩니다.</p>
<p>이처럼 __convert__가 필요한 이유는 쉽게 이해가 가능합니다. 근데 왜 wrap을 굳이 사용해야만 할까요?</p>
<h2><a class="anchor" id="autotoc_md117"></a>
wrap</h2>
<p>wrap이 필요한 이유는 richLog() 안쪽에서 <b>convert</b>()를 호출하고 이때 전달받은 값들을 가변인자를 통과할 수 있도록 풀어주는 역할을 합니다.</p>
<p>c++ 스펙상, 가변인자 함수는 scalar type이나 T*만 넘길 수 있기 때문에 값으로는 넘길 수 없습니다. 문제는 위의 <b>convert</b>(person&amp;&amp;)에서 봤듯이 상당수의 __convert__는 안에서 새로운 값을 만들어 값으로 넘겨야 한다는 거예요. 이때 wrap이 등장합니다. __convert__의 반환형을 보면 아시겠지만 wrap*로 넘기지 않죠. 값으로 넘깁니다. 그러니 richLog 함수템플릿 안에선, 임시 객체인 wrap이 생성되며, __convert__안에서 임시로 생성한 문자열 또한 안전하게 <code>const char* strWrap::unwrap()</code>을 호출하면서 char*를 가변인자 안으로 넘길 수 있습니다.</p>
<p>즉, 요약하면 <a class="el" href="classby_1_1logger.html#a704d20510894ee46cdfa91687ba7e0e8">log()</a> 가 가변인자이므로 c++ 스펙상 임시객체를 값으로 넘길 수 없기 때문입니다.</p>
<p><b>convert</b>() 함수들은 크게 <code>strWrap</code> 혹은 <code>noWrap&lt;T&gt;</code> 2가지 중 하나를 반환형으로 정의하는데 noWrap은 아무런 가공없이 받은 걸 그대로 반환하지만 strWrap은 std::string::c_str()를 내부적으로 호출합니다.</p>
<p>기본적으로는 <a class="el" href="structby_1_1str_wrap.html">strWrap</a> 을 사용하면 되지만, richLog 사용 시 format string에 <code>d</code>, <code>f</code> 등 사용자가 직접 타입을 명시하는 서식문자를 사용하고 싶을 때는 noWrap을 사용합니다. 예를 들어:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// strWrap: 자동으로 문자열로 변환 (%s 사용)</div>
<div class="line">strWrap __convert__(const myClass&amp; obj) { return strWrap(obj.toString()); }</div>
<div class="line"> </div>
<div class="line">// noWrap: 원본 타입 유지 (%d 등 명시적 서식문자 사용 가능)</div>
<div class="line">noWrap&lt;int&gt; __convert__(int val) { return noWrap&lt;int&gt;(val); }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md118"></a>
richLog 확장</h2>
<p><a class="el" href="group__clog.html">Clog</a> 모듈은 architecture 상 아랫부분에 위치하기 때문에 <a class="el" href="group__clog.html">Clog</a> 에 종속하는 클래스가 뭐가 있는지 알아서는 안됩니다. 그렇기 때문에 richLog 는 각 모듈마다 정의되어 있으며, 해당 모듈에 포함된 클래스를 어떻게 문자열로 변환할지를 추가로 정의해두고 있어요. 예를 들어 <a class="el" href="group__meta.html">Meta</a> 모듈에서는 다음과 같이 정의합니다:</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// module/meta/common/richLog.hpp</div>
<div class="line">namespace by {</div>
<div class="line">    class type;</div>
<div class="line">    class typeProvidable;</div>
<div class="line"> </div>
<div class="line">    // type 클래스를 로깅할 수 있도록 __convert__ 구현</div>
<div class="line">    _nout strWrap __convert__(const type&amp; rhs);</div>
<div class="line">    _nout strWrap __convert__(const type* rhs);</div>
<div class="line">    _nout strWrap __convert__(const typeProvidable&amp; rhs);</div>
<div class="line">    _nout strWrap __convert__(const typeProvidable* rhs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>이렇게 정의하면 로깅 매크로에서 해당 타입을 직접 사용할 수 있게 되는거죠.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">type&amp; t = ttype&lt;myClass&gt;();</div>
<div class="line">BY_I(&quot;type is %s&quot;, t);  // __convert__(const type&amp;)가 호출되어 적절히 문자열로 변환됨</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md119"></a>
간략화된 주소값</h2>
<p>richLog 로 void*를 넘기게 되면 <a class="el" href="group__indep.html">Indep</a> 모듈에 있는 <a class="el" href="namespaceby_1_1platform_a_p_i.html">platformAPI</a> 를 사용해서 <code>toAddrId()</code>를 호출합니다. addrId란 void*의 주소값의 마지막 4 hex값을 문자열로 표현한 값을 말합니다. 프로젝트 내에서 어느 주소에 있는 객체인지를 구분하기 위해 매우 자주 사용되니 꼭 알아두세요. 로깅할때는 항상 <code>@</code> 뒤에 addrId를 적는 코딩 컨벤션을 가지고 있습니다. 예를 들면 다음과 같이 로그를 남깁니다.</p>
<div class="fragment"><div class="line">@style: language-txt verified</div>
<div class="line">Nov 18 2025  20:02:13 I verifier  &lt;onLeave#87&gt; &#39;&#39; assignExpr@9a50: step#1 --&gt; set evalType</div>
</div><!-- fragment --><p>위 로그에서 assignExpr@9a50은 assignExpr 객체가 heap 주소의 끝자리가 9a50인 곳에 있는 인스턴스라는 얘기입니다. 이는 동일한 타입에 대해 서로 다른 인스턴스가 같은 시점에 로깅되는 경우 좀 더 수월하게 디버깅 하도록 도와주는 용도예요.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md121"></a>
스트림 제어</h1>
<h2><a class="anchor" id="autotoc_md122"></a>
enablesZone 클래스</h2>
<p><a class="el" href="classby_1_1logger.html">logger</a> 클래스는 여러개의 <a class="el" href="classby_1_1stream.html">stream</a> 을 가지고 있고 특정 <a class="el" href="classby_1_1stream.html">stream</a> 을 disable 혹은 enable 함으로써 출력되는 경로를 제어할 수 있어요.</p>
<p>여기서 문제는 특정 코드 블록 혹은 함수에서만 <a class="el" href="classby_1_1stream.html">stream</a> 을 제어 한 후, 블록을 벗어날 때는 원래 상태로 되돌리고자 하는 경우가 매우 자주 일어납니다.</p>
<p><a class="el" href="classby_1_1enables_zone.html">enablesZone</a> 은 이럴때 사용하는 것으로, RAII idiom으로 구현되어 있어서, 객체 생성과 동시에 <a class="el" href="classby_1_1stream.html">stream</a> 의 enable 상태를 기록했다가 <a class="el" href="classby_1_1enables_zone.html">enablesZone</a> 이 소멸될때 각 <a class="el" href="classby_1_1stream.html">stream</a> 의 enable 여부를 초기상태로 되돌립니다.</p>
<p>보통은 다음과 같이 사용합니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">// let&#39;s assume that all streams in logger are enabled.</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    enablesZone zone;</div>
<div class="line">    logger&amp; log = logger::get();</div>
<div class="line">    log.getStream(0).setEnable(false); // 0번째 stream을 disable.</div>
<div class="line">    logger::getStream(&quot;consoleStream&quot;).setEnable(false); // console로 logging 하지 않도록 disable.</div>
<div class="line">    BY_E(&quot;error message1&quot;); // 이 로그는 0번 stream과 console로는 로깅되지 않는다.</div>
<div class="line"> </div>
<div class="line">    logger::setEnable(false); // 모든 stream을 disable.</div>
<div class="line">    BY_E(&quot;this message won&#39;t log on any stream&quot;);</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">BY_E(&quot;this message will definitely be log on entire stream&quot;);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md124"></a>
필터링 시스템</h1>
<p>로깅은 디버깅에서는 아주 유용한 도구이지만, unittest나 release 빌드에서는 필요없는 정보를 잔뜩 남겨서 혼란스럽게 하기도 합니다. 개발중에는 이처럼, 로깅되는 메시지를 보여줬다가 감췄다가 할 필요가 있는데, 필터링은 각 로그의 상세정보를 조건으로 로그를 걸러주는 역할을 합니다.</p>
<p>필터링 시스템은 Strategy 패턴을 사용하여 구현되었습니다. 각 필터는 교체 가능한 알고리즘으로 동작하며, 런타임에 원하는 필터를 선택하여 적용할 수 있습니다.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
filterable 클래스</h2>
<p>각 필터는 filterable 인터페이스를 구현해야하는데요, <a class="el" href="classby_1_1filterable.html">filterable</a>은 <code>filt()</code> 함수를 제공하며, filt() 함수 안쪽에서 parameter로 주어진 Log 정보에 대해 판단후, true를 반환할 경우 해당 Log는 <a class="el" href="classby_1_1stream.html">stream</a> 에 올라가지 않고 무시됩니다.</p>
<p><a class="el" href="classby_1_1logger.html">logger</a> 클래스의 <code>setFilters(const filters&amp;)</code>를 통해서 <a class="el" href="classby_1_1filterable.html">filterable</a> 을 추가할 수 있습니다.</p>
<h2><a class="anchor" id="autotoc_md126"></a>
filters 클래스</h2>
<p><a class="el" href="classby_1_1filters.html">filters</a> 클래스는 <a class="el" href="classby_1_1logger.html">logger</a> 클래스에서 등록된 <a class="el" href="classby_1_1filterable.html">filterable</a> 클래스들을 관리합니다. <a class="el" href="classby_1_1filterable.html">filterable</a> 과 동일한 API를 가지며, 해당 API를 호출하면 소유한 모든 <a class="el" href="classby_1_1filterable.html">filterable</a> 에 해당 API를 호출합니다. 이는 Composite 패턴으로 구현되어, 여러 필터를 하나의 필터처럼 다룰 수 있습니다.</p>
<h2><a class="anchor" id="autotoc_md127"></a>
errPassFilter 클래스</h2>
<p>말 그대로 err만 통과시키는 <a class="el" href="classby_1_1filterable.html">filterable</a> 클래스입니다. 이 filter를 <a class="el" href="classby_1_1logger.html">logger</a> 에 등록하면 warning이나 info는 출력되지 않습니다. 직접 사용하지 않으며, 객체 생성하여 <a class="el" href="classby_1_1logger.html">logger</a> 에 add 하는 용도로 사용합니다.</p>
<p>동작은 매우 단순한데요, <code>errLv</code>이 ERR일때만 통과시키는 필터입니다. 다음과 같이 사용할 수 있습니다.</p>
<div class="fragment"><div class="line">@style: language-cpp verified</div>
<div class="line">const filters&amp; prevFilters = logger::get().getFilters();</div>
<div class="line">filters fs(new errPassFilter());</div>
<div class="line">logger::get().setFilters(fs);</div>
<div class="line"> </div>
<div class="line">// doSomething..</div>
<div class="line"> </div>
<div class="line">logger::get().setFilters(prevFilters);</div>
</div><!-- fragment --> <hr  />
<h1><a class="anchor" id="autotoc_md129"></a>
정리</h1>
<p>자, 시퀸스 다이어그램으로 지금까지의 내용을 정리해보죠.</p>
<div class="plantumlgraph">
<img src="inline_umlgraph_6.png" />
</div>
<hr  />
<p><b>다음 문서</b>: <a class="el" href="af-architecture-meta.html">meta 모듈 - 런타임 타입 시스템</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
